// automatically generated by the FlatBuffers compiler, do not modify


// @generated

use core::mem;
use core::cmp::Ordering;

extern crate flatbuffers;
use self::flatbuffers::{EndianScalar, Follow};

#[allow(unused_imports, dead_code)]
pub mod tflite {

  use core::mem;
  use core::cmp::Ordering;

  extern crate flatbuffers;
  use self::flatbuffers::{EndianScalar, Follow};

#[deprecated(since = "2.0.0", note = "Use associated constants instead. This will no longer be generated in 2021.")]
pub const ENUM_MIN_TENSOR_TYPE: i8 = 0;
#[deprecated(since = "2.0.0", note = "Use associated constants instead. This will no longer be generated in 2021.")]
pub const ENUM_MAX_TENSOR_TYPE: i8 = 9;
#[deprecated(since = "2.0.0", note = "Use associated constants instead. This will no longer be generated in 2021.")]
#[allow(non_camel_case_types)]
pub const ENUM_VALUES_TENSOR_TYPE: [TensorType; 10] = [
  TensorType::FLOAT32,
  TensorType::FLOAT16,
  TensorType::INT32,
  TensorType::UINT8,
  TensorType::INT64,
  TensorType::STRING,
  TensorType::BOOL,
  TensorType::INT16,
  TensorType::COMPLEX64,
  TensorType::INT8,
];

#[derive(Clone, Copy, PartialEq, Eq, PartialOrd, Ord, Hash, Default)]
#[repr(transparent)]
pub struct TensorType(pub i8);
#[allow(non_upper_case_globals)]
impl TensorType {
  pub const FLOAT32: Self = Self(0);
  pub const FLOAT16: Self = Self(1);
  pub const INT32: Self = Self(2);
  pub const UINT8: Self = Self(3);
  pub const INT64: Self = Self(4);
  pub const STRING: Self = Self(5);
  pub const BOOL: Self = Self(6);
  pub const INT16: Self = Self(7);
  pub const COMPLEX64: Self = Self(8);
  pub const INT8: Self = Self(9);

  pub const ENUM_MIN: i8 = 0;
  pub const ENUM_MAX: i8 = 9;
  pub const ENUM_VALUES: &'static [Self] = &[
    Self::FLOAT32,
    Self::FLOAT16,
    Self::INT32,
    Self::UINT8,
    Self::INT64,
    Self::STRING,
    Self::BOOL,
    Self::INT16,
    Self::COMPLEX64,
    Self::INT8,
  ];
  /// Returns the variant's name or "" if unknown.
  pub fn variant_name(self) -> Option<&'static str> {
    match self {
      Self::FLOAT32 => Some("FLOAT32"),
      Self::FLOAT16 => Some("FLOAT16"),
      Self::INT32 => Some("INT32"),
      Self::UINT8 => Some("UINT8"),
      Self::INT64 => Some("INT64"),
      Self::STRING => Some("STRING"),
      Self::BOOL => Some("BOOL"),
      Self::INT16 => Some("INT16"),
      Self::COMPLEX64 => Some("COMPLEX64"),
      Self::INT8 => Some("INT8"),
      _ => None,
    }
  }
}
impl core::fmt::Debug for TensorType {
  fn fmt(&self, f: &mut core::fmt::Formatter) -> core::fmt::Result {
    if let Some(name) = self.variant_name() {
      f.write_str(name)
    } else {
      f.write_fmt(format_args!("<UNKNOWN {:?}>", self.0))
    }
  }
}
impl<'a> flatbuffers::Follow<'a> for TensorType {
  type Inner = Self;
  #[inline]
  fn follow(buf: &'a [u8], loc: usize) -> Self::Inner {
    let b = unsafe {
      flatbuffers::read_scalar_at::<i8>(buf, loc)
    };
    Self(b)
  }
}

impl flatbuffers::Push for TensorType {
    type Output = TensorType;
    #[inline]
    fn push(&self, dst: &mut [u8], _rest: &[u8]) {
        unsafe { flatbuffers::emplace_scalar::<i8>(dst, self.0); }
    }
}

impl flatbuffers::EndianScalar for TensorType {
  #[inline]
  fn to_little_endian(self) -> Self {
    let b = i8::to_le(self.0);
    Self(b)
  }
  #[inline]
  #[allow(clippy::wrong_self_convention)]
  fn from_little_endian(self) -> Self {
    let b = i8::from_le(self.0);
    Self(b)
  }
}

impl<'a> flatbuffers::Verifiable for TensorType {
  #[inline]
  fn run_verifier(
    v: &mut flatbuffers::Verifier, pos: usize
  ) -> Result<(), flatbuffers::InvalidFlatbuffer> {
    use self::flatbuffers::Verifiable;
    i8::run_verifier(v, pos)
  }
}

impl flatbuffers::SimpleToVerifyInSlice for TensorType {}
#[deprecated(since = "2.0.0", note = "Use associated constants instead. This will no longer be generated in 2021.")]
pub const ENUM_MIN_QUANTIZATION_DETAILS: u8 = 0;
#[deprecated(since = "2.0.0", note = "Use associated constants instead. This will no longer be generated in 2021.")]
pub const ENUM_MAX_QUANTIZATION_DETAILS: u8 = 1;
#[deprecated(since = "2.0.0", note = "Use associated constants instead. This will no longer be generated in 2021.")]
#[allow(non_camel_case_types)]
pub const ENUM_VALUES_QUANTIZATION_DETAILS: [QuantizationDetails; 2] = [
  QuantizationDetails::NONE,
  QuantizationDetails::CustomQuantization,
];

#[derive(Clone, Copy, PartialEq, Eq, PartialOrd, Ord, Hash, Default)]
#[repr(transparent)]
pub struct QuantizationDetails(pub u8);
#[allow(non_upper_case_globals)]
impl QuantizationDetails {
  pub const NONE: Self = Self(0);
  pub const CustomQuantization: Self = Self(1);

  pub const ENUM_MIN: u8 = 0;
  pub const ENUM_MAX: u8 = 1;
  pub const ENUM_VALUES: &'static [Self] = &[
    Self::NONE,
    Self::CustomQuantization,
  ];
  /// Returns the variant's name or "" if unknown.
  pub fn variant_name(self) -> Option<&'static str> {
    match self {
      Self::NONE => Some("NONE"),
      Self::CustomQuantization => Some("CustomQuantization"),
      _ => None,
    }
  }
}
impl core::fmt::Debug for QuantizationDetails {
  fn fmt(&self, f: &mut core::fmt::Formatter) -> core::fmt::Result {
    if let Some(name) = self.variant_name() {
      f.write_str(name)
    } else {
      f.write_fmt(format_args!("<UNKNOWN {:?}>", self.0))
    }
  }
}
impl<'a> flatbuffers::Follow<'a> for QuantizationDetails {
  type Inner = Self;
  #[inline]
  fn follow(buf: &'a [u8], loc: usize) -> Self::Inner {
    let b = unsafe {
      flatbuffers::read_scalar_at::<u8>(buf, loc)
    };
    Self(b)
  }
}

impl flatbuffers::Push for QuantizationDetails {
    type Output = QuantizationDetails;
    #[inline]
    fn push(&self, dst: &mut [u8], _rest: &[u8]) {
        unsafe { flatbuffers::emplace_scalar::<u8>(dst, self.0); }
    }
}

impl flatbuffers::EndianScalar for QuantizationDetails {
  #[inline]
  fn to_little_endian(self) -> Self {
    let b = u8::to_le(self.0);
    Self(b)
  }
  #[inline]
  #[allow(clippy::wrong_self_convention)]
  fn from_little_endian(self) -> Self {
    let b = u8::from_le(self.0);
    Self(b)
  }
}

impl<'a> flatbuffers::Verifiable for QuantizationDetails {
  #[inline]
  fn run_verifier(
    v: &mut flatbuffers::Verifier, pos: usize
  ) -> Result<(), flatbuffers::InvalidFlatbuffer> {
    use self::flatbuffers::Verifiable;
    u8::run_verifier(v, pos)
  }
}

impl flatbuffers::SimpleToVerifyInSlice for QuantizationDetails {}
pub struct QuantizationDetailsUnionTableOffset {}

#[allow(clippy::upper_case_acronyms)]
#[non_exhaustive]
#[derive(Debug, Clone, PartialEq)]
pub enum QuantizationDetailsT {
  NONE,
  CustomQuantization(Box<CustomQuantizationT>),
}
impl Default for QuantizationDetailsT {
  fn default() -> Self {
    Self::NONE
  }
}
impl QuantizationDetailsT {
  pub fn quantization_details_type(&self) -> QuantizationDetails {
    match self {
      Self::NONE => QuantizationDetails::NONE,
      Self::CustomQuantization(_) => QuantizationDetails::CustomQuantization,
    }
  }
  pub fn pack(&self, fbb: &mut flatbuffers::FlatBufferBuilder) -> Option<flatbuffers::WIPOffset<flatbuffers::UnionWIPOffset>> {
    match self {
      Self::NONE => None,
      Self::CustomQuantization(v) => Some(v.pack(fbb).as_union_value()),
    }
  }
  /// If the union variant matches, return the owned CustomQuantizationT, setting the union to NONE.
  pub fn take_custom_quantization(&mut self) -> Option<Box<CustomQuantizationT>> {
    if let Self::CustomQuantization(_) = self {
      let v = core::mem::replace(self, Self::NONE);
      if let Self::CustomQuantization(w) = v {
        Some(w)
      } else {
        unreachable!()
      }
    } else {
      None
    }
  }
  /// If the union variant matches, return a reference to the CustomQuantizationT.
  pub fn as_custom_quantization(&self) -> Option<&CustomQuantizationT> {
    if let Self::CustomQuantization(v) = self { Some(v.as_ref()) } else { None }
  }
  /// If the union variant matches, return a mutable reference to the CustomQuantizationT.
  pub fn as_custom_quantization_mut(&mut self) -> Option<&mut CustomQuantizationT> {
    if let Self::CustomQuantization(v) = self { Some(v.as_mut()) } else { None }
  }
}
#[deprecated(since = "2.0.0", note = "Use associated constants instead. This will no longer be generated in 2021.")]
pub const ENUM_MIN_BUILTIN_OPERATOR: i8 = 0;
#[deprecated(since = "2.0.0", note = "Use associated constants instead. This will no longer be generated in 2021.")]
pub const ENUM_MAX_BUILTIN_OPERATOR: i8 = 122;
#[deprecated(since = "2.0.0", note = "Use associated constants instead. This will no longer be generated in 2021.")]
#[allow(non_camel_case_types)]
pub const ENUM_VALUES_BUILTIN_OPERATOR: [BuiltinOperator; 123] = [
  BuiltinOperator::ADD,
  BuiltinOperator::AVERAGE_POOL_2D,
  BuiltinOperator::CONCATENATION,
  BuiltinOperator::CONV_2D,
  BuiltinOperator::DEPTHWISE_CONV_2D,
  BuiltinOperator::DEPTH_TO_SPACE,
  BuiltinOperator::DEQUANTIZE,
  BuiltinOperator::EMBEDDING_LOOKUP,
  BuiltinOperator::FLOOR,
  BuiltinOperator::FULLY_CONNECTED,
  BuiltinOperator::HASHTABLE_LOOKUP,
  BuiltinOperator::L2_NORMALIZATION,
  BuiltinOperator::L2_POOL_2D,
  BuiltinOperator::LOCAL_RESPONSE_NORMALIZATION,
  BuiltinOperator::LOGISTIC,
  BuiltinOperator::LSH_PROJECTION,
  BuiltinOperator::LSTM,
  BuiltinOperator::MAX_POOL_2D,
  BuiltinOperator::MUL,
  BuiltinOperator::RELU,
  BuiltinOperator::RELU_N1_TO_1,
  BuiltinOperator::RELU6,
  BuiltinOperator::RESHAPE,
  BuiltinOperator::RESIZE_BILINEAR,
  BuiltinOperator::RNN,
  BuiltinOperator::SOFTMAX,
  BuiltinOperator::SPACE_TO_DEPTH,
  BuiltinOperator::SVDF,
  BuiltinOperator::TANH,
  BuiltinOperator::CONCAT_EMBEDDINGS,
  BuiltinOperator::SKIP_GRAM,
  BuiltinOperator::CALL,
  BuiltinOperator::CUSTOM,
  BuiltinOperator::EMBEDDING_LOOKUP_SPARSE,
  BuiltinOperator::PAD,
  BuiltinOperator::UNIDIRECTIONAL_SEQUENCE_RNN,
  BuiltinOperator::GATHER,
  BuiltinOperator::BATCH_TO_SPACE_ND,
  BuiltinOperator::SPACE_TO_BATCH_ND,
  BuiltinOperator::TRANSPOSE,
  BuiltinOperator::MEAN,
  BuiltinOperator::SUB,
  BuiltinOperator::DIV,
  BuiltinOperator::SQUEEZE,
  BuiltinOperator::UNIDIRECTIONAL_SEQUENCE_LSTM,
  BuiltinOperator::STRIDED_SLICE,
  BuiltinOperator::BIDIRECTIONAL_SEQUENCE_RNN,
  BuiltinOperator::EXP,
  BuiltinOperator::TOPK_V2,
  BuiltinOperator::SPLIT,
  BuiltinOperator::LOG_SOFTMAX,
  BuiltinOperator::DELEGATE,
  BuiltinOperator::BIDIRECTIONAL_SEQUENCE_LSTM,
  BuiltinOperator::CAST,
  BuiltinOperator::PRELU,
  BuiltinOperator::MAXIMUM,
  BuiltinOperator::ARG_MAX,
  BuiltinOperator::MINIMUM,
  BuiltinOperator::LESS,
  BuiltinOperator::NEG,
  BuiltinOperator::PADV2,
  BuiltinOperator::GREATER,
  BuiltinOperator::GREATER_EQUAL,
  BuiltinOperator::LESS_EQUAL,
  BuiltinOperator::SELECT,
  BuiltinOperator::SLICE,
  BuiltinOperator::SIN,
  BuiltinOperator::TRANSPOSE_CONV,
  BuiltinOperator::SPARSE_TO_DENSE,
  BuiltinOperator::TILE,
  BuiltinOperator::EXPAND_DIMS,
  BuiltinOperator::EQUAL,
  BuiltinOperator::NOT_EQUAL,
  BuiltinOperator::LOG,
  BuiltinOperator::SUM,
  BuiltinOperator::SQRT,
  BuiltinOperator::RSQRT,
  BuiltinOperator::SHAPE,
  BuiltinOperator::POW,
  BuiltinOperator::ARG_MIN,
  BuiltinOperator::FAKE_QUANT,
  BuiltinOperator::REDUCE_PROD,
  BuiltinOperator::REDUCE_MAX,
  BuiltinOperator::PACK,
  BuiltinOperator::LOGICAL_OR,
  BuiltinOperator::ONE_HOT,
  BuiltinOperator::LOGICAL_AND,
  BuiltinOperator::LOGICAL_NOT,
  BuiltinOperator::UNPACK,
  BuiltinOperator::REDUCE_MIN,
  BuiltinOperator::FLOOR_DIV,
  BuiltinOperator::REDUCE_ANY,
  BuiltinOperator::SQUARE,
  BuiltinOperator::ZEROS_LIKE,
  BuiltinOperator::FILL,
  BuiltinOperator::FLOOR_MOD,
  BuiltinOperator::RANGE,
  BuiltinOperator::RESIZE_NEAREST_NEIGHBOR,
  BuiltinOperator::LEAKY_RELU,
  BuiltinOperator::SQUARED_DIFFERENCE,
  BuiltinOperator::MIRROR_PAD,
  BuiltinOperator::ABS,
  BuiltinOperator::SPLIT_V,
  BuiltinOperator::UNIQUE,
  BuiltinOperator::CEIL,
  BuiltinOperator::REVERSE_V2,
  BuiltinOperator::ADD_N,
  BuiltinOperator::GATHER_ND,
  BuiltinOperator::COS,
  BuiltinOperator::WHERE,
  BuiltinOperator::RANK,
  BuiltinOperator::ELU,
  BuiltinOperator::REVERSE_SEQUENCE,
  BuiltinOperator::MATRIX_DIAG,
  BuiltinOperator::QUANTIZE,
  BuiltinOperator::MATRIX_SET_DIAG,
  BuiltinOperator::ROUND,
  BuiltinOperator::HARD_SWISH,
  BuiltinOperator::IF,
  BuiltinOperator::WHILE,
  BuiltinOperator::NON_MAX_SUPPRESSION_V4,
  BuiltinOperator::NON_MAX_SUPPRESSION_V5,
  BuiltinOperator::SCATTER_ND,
];

#[derive(Clone, Copy, PartialEq, Eq, PartialOrd, Ord, Hash, Default)]
#[repr(transparent)]
pub struct BuiltinOperator(pub i8);
#[allow(non_upper_case_globals)]
impl BuiltinOperator {
  pub const ADD: Self = Self(0);
  pub const AVERAGE_POOL_2D: Self = Self(1);
  pub const CONCATENATION: Self = Self(2);
  pub const CONV_2D: Self = Self(3);
  pub const DEPTHWISE_CONV_2D: Self = Self(4);
  pub const DEPTH_TO_SPACE: Self = Self(5);
  pub const DEQUANTIZE: Self = Self(6);
  pub const EMBEDDING_LOOKUP: Self = Self(7);
  pub const FLOOR: Self = Self(8);
  pub const FULLY_CONNECTED: Self = Self(9);
  pub const HASHTABLE_LOOKUP: Self = Self(10);
  pub const L2_NORMALIZATION: Self = Self(11);
  pub const L2_POOL_2D: Self = Self(12);
  pub const LOCAL_RESPONSE_NORMALIZATION: Self = Self(13);
  pub const LOGISTIC: Self = Self(14);
  pub const LSH_PROJECTION: Self = Self(15);
  pub const LSTM: Self = Self(16);
  pub const MAX_POOL_2D: Self = Self(17);
  pub const MUL: Self = Self(18);
  pub const RELU: Self = Self(19);
  pub const RELU_N1_TO_1: Self = Self(20);
  pub const RELU6: Self = Self(21);
  pub const RESHAPE: Self = Self(22);
  pub const RESIZE_BILINEAR: Self = Self(23);
  pub const RNN: Self = Self(24);
  pub const SOFTMAX: Self = Self(25);
  pub const SPACE_TO_DEPTH: Self = Self(26);
  pub const SVDF: Self = Self(27);
  pub const TANH: Self = Self(28);
  pub const CONCAT_EMBEDDINGS: Self = Self(29);
  pub const SKIP_GRAM: Self = Self(30);
  pub const CALL: Self = Self(31);
  pub const CUSTOM: Self = Self(32);
  pub const EMBEDDING_LOOKUP_SPARSE: Self = Self(33);
  pub const PAD: Self = Self(34);
  pub const UNIDIRECTIONAL_SEQUENCE_RNN: Self = Self(35);
  pub const GATHER: Self = Self(36);
  pub const BATCH_TO_SPACE_ND: Self = Self(37);
  pub const SPACE_TO_BATCH_ND: Self = Self(38);
  pub const TRANSPOSE: Self = Self(39);
  pub const MEAN: Self = Self(40);
  pub const SUB: Self = Self(41);
  pub const DIV: Self = Self(42);
  pub const SQUEEZE: Self = Self(43);
  pub const UNIDIRECTIONAL_SEQUENCE_LSTM: Self = Self(44);
  pub const STRIDED_SLICE: Self = Self(45);
  pub const BIDIRECTIONAL_SEQUENCE_RNN: Self = Self(46);
  pub const EXP: Self = Self(47);
  pub const TOPK_V2: Self = Self(48);
  pub const SPLIT: Self = Self(49);
  pub const LOG_SOFTMAX: Self = Self(50);
  pub const DELEGATE: Self = Self(51);
  pub const BIDIRECTIONAL_SEQUENCE_LSTM: Self = Self(52);
  pub const CAST: Self = Self(53);
  pub const PRELU: Self = Self(54);
  pub const MAXIMUM: Self = Self(55);
  pub const ARG_MAX: Self = Self(56);
  pub const MINIMUM: Self = Self(57);
  pub const LESS: Self = Self(58);
  pub const NEG: Self = Self(59);
  pub const PADV2: Self = Self(60);
  pub const GREATER: Self = Self(61);
  pub const GREATER_EQUAL: Self = Self(62);
  pub const LESS_EQUAL: Self = Self(63);
  pub const SELECT: Self = Self(64);
  pub const SLICE: Self = Self(65);
  pub const SIN: Self = Self(66);
  pub const TRANSPOSE_CONV: Self = Self(67);
  pub const SPARSE_TO_DENSE: Self = Self(68);
  pub const TILE: Self = Self(69);
  pub const EXPAND_DIMS: Self = Self(70);
  pub const EQUAL: Self = Self(71);
  pub const NOT_EQUAL: Self = Self(72);
  pub const LOG: Self = Self(73);
  pub const SUM: Self = Self(74);
  pub const SQRT: Self = Self(75);
  pub const RSQRT: Self = Self(76);
  pub const SHAPE: Self = Self(77);
  pub const POW: Self = Self(78);
  pub const ARG_MIN: Self = Self(79);
  pub const FAKE_QUANT: Self = Self(80);
  pub const REDUCE_PROD: Self = Self(81);
  pub const REDUCE_MAX: Self = Self(82);
  pub const PACK: Self = Self(83);
  pub const LOGICAL_OR: Self = Self(84);
  pub const ONE_HOT: Self = Self(85);
  pub const LOGICAL_AND: Self = Self(86);
  pub const LOGICAL_NOT: Self = Self(87);
  pub const UNPACK: Self = Self(88);
  pub const REDUCE_MIN: Self = Self(89);
  pub const FLOOR_DIV: Self = Self(90);
  pub const REDUCE_ANY: Self = Self(91);
  pub const SQUARE: Self = Self(92);
  pub const ZEROS_LIKE: Self = Self(93);
  pub const FILL: Self = Self(94);
  pub const FLOOR_MOD: Self = Self(95);
  pub const RANGE: Self = Self(96);
  pub const RESIZE_NEAREST_NEIGHBOR: Self = Self(97);
  pub const LEAKY_RELU: Self = Self(98);
  pub const SQUARED_DIFFERENCE: Self = Self(99);
  pub const MIRROR_PAD: Self = Self(100);
  pub const ABS: Self = Self(101);
  pub const SPLIT_V: Self = Self(102);
  pub const UNIQUE: Self = Self(103);
  pub const CEIL: Self = Self(104);
  pub const REVERSE_V2: Self = Self(105);
  pub const ADD_N: Self = Self(106);
  pub const GATHER_ND: Self = Self(107);
  pub const COS: Self = Self(108);
  pub const WHERE: Self = Self(109);
  pub const RANK: Self = Self(110);
  pub const ELU: Self = Self(111);
  pub const REVERSE_SEQUENCE: Self = Self(112);
  pub const MATRIX_DIAG: Self = Self(113);
  pub const QUANTIZE: Self = Self(114);
  pub const MATRIX_SET_DIAG: Self = Self(115);
  pub const ROUND: Self = Self(116);
  pub const HARD_SWISH: Self = Self(117);
  pub const IF: Self = Self(118);
  pub const WHILE: Self = Self(119);
  pub const NON_MAX_SUPPRESSION_V4: Self = Self(120);
  pub const NON_MAX_SUPPRESSION_V5: Self = Self(121);
  pub const SCATTER_ND: Self = Self(122);

  pub const ENUM_MIN: i8 = 0;
  pub const ENUM_MAX: i8 = 122;
  pub const ENUM_VALUES: &'static [Self] = &[
    Self::ADD,
    Self::AVERAGE_POOL_2D,
    Self::CONCATENATION,
    Self::CONV_2D,
    Self::DEPTHWISE_CONV_2D,
    Self::DEPTH_TO_SPACE,
    Self::DEQUANTIZE,
    Self::EMBEDDING_LOOKUP,
    Self::FLOOR,
    Self::FULLY_CONNECTED,
    Self::HASHTABLE_LOOKUP,
    Self::L2_NORMALIZATION,
    Self::L2_POOL_2D,
    Self::LOCAL_RESPONSE_NORMALIZATION,
    Self::LOGISTIC,
    Self::LSH_PROJECTION,
    Self::LSTM,
    Self::MAX_POOL_2D,
    Self::MUL,
    Self::RELU,
    Self::RELU_N1_TO_1,
    Self::RELU6,
    Self::RESHAPE,
    Self::RESIZE_BILINEAR,
    Self::RNN,
    Self::SOFTMAX,
    Self::SPACE_TO_DEPTH,
    Self::SVDF,
    Self::TANH,
    Self::CONCAT_EMBEDDINGS,
    Self::SKIP_GRAM,
    Self::CALL,
    Self::CUSTOM,
    Self::EMBEDDING_LOOKUP_SPARSE,
    Self::PAD,
    Self::UNIDIRECTIONAL_SEQUENCE_RNN,
    Self::GATHER,
    Self::BATCH_TO_SPACE_ND,
    Self::SPACE_TO_BATCH_ND,
    Self::TRANSPOSE,
    Self::MEAN,
    Self::SUB,
    Self::DIV,
    Self::SQUEEZE,
    Self::UNIDIRECTIONAL_SEQUENCE_LSTM,
    Self::STRIDED_SLICE,
    Self::BIDIRECTIONAL_SEQUENCE_RNN,
    Self::EXP,
    Self::TOPK_V2,
    Self::SPLIT,
    Self::LOG_SOFTMAX,
    Self::DELEGATE,
    Self::BIDIRECTIONAL_SEQUENCE_LSTM,
    Self::CAST,
    Self::PRELU,
    Self::MAXIMUM,
    Self::ARG_MAX,
    Self::MINIMUM,
    Self::LESS,
    Self::NEG,
    Self::PADV2,
    Self::GREATER,
    Self::GREATER_EQUAL,
    Self::LESS_EQUAL,
    Self::SELECT,
    Self::SLICE,
    Self::SIN,
    Self::TRANSPOSE_CONV,
    Self::SPARSE_TO_DENSE,
    Self::TILE,
    Self::EXPAND_DIMS,
    Self::EQUAL,
    Self::NOT_EQUAL,
    Self::LOG,
    Self::SUM,
    Self::SQRT,
    Self::RSQRT,
    Self::SHAPE,
    Self::POW,
    Self::ARG_MIN,
    Self::FAKE_QUANT,
    Self::REDUCE_PROD,
    Self::REDUCE_MAX,
    Self::PACK,
    Self::LOGICAL_OR,
    Self::ONE_HOT,
    Self::LOGICAL_AND,
    Self::LOGICAL_NOT,
    Self::UNPACK,
    Self::REDUCE_MIN,
    Self::FLOOR_DIV,
    Self::REDUCE_ANY,
    Self::SQUARE,
    Self::ZEROS_LIKE,
    Self::FILL,
    Self::FLOOR_MOD,
    Self::RANGE,
    Self::RESIZE_NEAREST_NEIGHBOR,
    Self::LEAKY_RELU,
    Self::SQUARED_DIFFERENCE,
    Self::MIRROR_PAD,
    Self::ABS,
    Self::SPLIT_V,
    Self::UNIQUE,
    Self::CEIL,
    Self::REVERSE_V2,
    Self::ADD_N,
    Self::GATHER_ND,
    Self::COS,
    Self::WHERE,
    Self::RANK,
    Self::ELU,
    Self::REVERSE_SEQUENCE,
    Self::MATRIX_DIAG,
    Self::QUANTIZE,
    Self::MATRIX_SET_DIAG,
    Self::ROUND,
    Self::HARD_SWISH,
    Self::IF,
    Self::WHILE,
    Self::NON_MAX_SUPPRESSION_V4,
    Self::NON_MAX_SUPPRESSION_V5,
    Self::SCATTER_ND,
  ];
  /// Returns the variant's name or "" if unknown.
  pub fn variant_name(self) -> Option<&'static str> {
    match self {
      Self::ADD => Some("ADD"),
      Self::AVERAGE_POOL_2D => Some("AVERAGE_POOL_2D"),
      Self::CONCATENATION => Some("CONCATENATION"),
      Self::CONV_2D => Some("CONV_2D"),
      Self::DEPTHWISE_CONV_2D => Some("DEPTHWISE_CONV_2D"),
      Self::DEPTH_TO_SPACE => Some("DEPTH_TO_SPACE"),
      Self::DEQUANTIZE => Some("DEQUANTIZE"),
      Self::EMBEDDING_LOOKUP => Some("EMBEDDING_LOOKUP"),
      Self::FLOOR => Some("FLOOR"),
      Self::FULLY_CONNECTED => Some("FULLY_CONNECTED"),
      Self::HASHTABLE_LOOKUP => Some("HASHTABLE_LOOKUP"),
      Self::L2_NORMALIZATION => Some("L2_NORMALIZATION"),
      Self::L2_POOL_2D => Some("L2_POOL_2D"),
      Self::LOCAL_RESPONSE_NORMALIZATION => Some("LOCAL_RESPONSE_NORMALIZATION"),
      Self::LOGISTIC => Some("LOGISTIC"),
      Self::LSH_PROJECTION => Some("LSH_PROJECTION"),
      Self::LSTM => Some("LSTM"),
      Self::MAX_POOL_2D => Some("MAX_POOL_2D"),
      Self::MUL => Some("MUL"),
      Self::RELU => Some("RELU"),
      Self::RELU_N1_TO_1 => Some("RELU_N1_TO_1"),
      Self::RELU6 => Some("RELU6"),
      Self::RESHAPE => Some("RESHAPE"),
      Self::RESIZE_BILINEAR => Some("RESIZE_BILINEAR"),
      Self::RNN => Some("RNN"),
      Self::SOFTMAX => Some("SOFTMAX"),
      Self::SPACE_TO_DEPTH => Some("SPACE_TO_DEPTH"),
      Self::SVDF => Some("SVDF"),
      Self::TANH => Some("TANH"),
      Self::CONCAT_EMBEDDINGS => Some("CONCAT_EMBEDDINGS"),
      Self::SKIP_GRAM => Some("SKIP_GRAM"),
      Self::CALL => Some("CALL"),
      Self::CUSTOM => Some("CUSTOM"),
      Self::EMBEDDING_LOOKUP_SPARSE => Some("EMBEDDING_LOOKUP_SPARSE"),
      Self::PAD => Some("PAD"),
      Self::UNIDIRECTIONAL_SEQUENCE_RNN => Some("UNIDIRECTIONAL_SEQUENCE_RNN"),
      Self::GATHER => Some("GATHER"),
      Self::BATCH_TO_SPACE_ND => Some("BATCH_TO_SPACE_ND"),
      Self::SPACE_TO_BATCH_ND => Some("SPACE_TO_BATCH_ND"),
      Self::TRANSPOSE => Some("TRANSPOSE"),
      Self::MEAN => Some("MEAN"),
      Self::SUB => Some("SUB"),
      Self::DIV => Some("DIV"),
      Self::SQUEEZE => Some("SQUEEZE"),
      Self::UNIDIRECTIONAL_SEQUENCE_LSTM => Some("UNIDIRECTIONAL_SEQUENCE_LSTM"),
      Self::STRIDED_SLICE => Some("STRIDED_SLICE"),
      Self::BIDIRECTIONAL_SEQUENCE_RNN => Some("BIDIRECTIONAL_SEQUENCE_RNN"),
      Self::EXP => Some("EXP"),
      Self::TOPK_V2 => Some("TOPK_V2"),
      Self::SPLIT => Some("SPLIT"),
      Self::LOG_SOFTMAX => Some("LOG_SOFTMAX"),
      Self::DELEGATE => Some("DELEGATE"),
      Self::BIDIRECTIONAL_SEQUENCE_LSTM => Some("BIDIRECTIONAL_SEQUENCE_LSTM"),
      Self::CAST => Some("CAST"),
      Self::PRELU => Some("PRELU"),
      Self::MAXIMUM => Some("MAXIMUM"),
      Self::ARG_MAX => Some("ARG_MAX"),
      Self::MINIMUM => Some("MINIMUM"),
      Self::LESS => Some("LESS"),
      Self::NEG => Some("NEG"),
      Self::PADV2 => Some("PADV2"),
      Self::GREATER => Some("GREATER"),
      Self::GREATER_EQUAL => Some("GREATER_EQUAL"),
      Self::LESS_EQUAL => Some("LESS_EQUAL"),
      Self::SELECT => Some("SELECT"),
      Self::SLICE => Some("SLICE"),
      Self::SIN => Some("SIN"),
      Self::TRANSPOSE_CONV => Some("TRANSPOSE_CONV"),
      Self::SPARSE_TO_DENSE => Some("SPARSE_TO_DENSE"),
      Self::TILE => Some("TILE"),
      Self::EXPAND_DIMS => Some("EXPAND_DIMS"),
      Self::EQUAL => Some("EQUAL"),
      Self::NOT_EQUAL => Some("NOT_EQUAL"),
      Self::LOG => Some("LOG"),
      Self::SUM => Some("SUM"),
      Self::SQRT => Some("SQRT"),
      Self::RSQRT => Some("RSQRT"),
      Self::SHAPE => Some("SHAPE"),
      Self::POW => Some("POW"),
      Self::ARG_MIN => Some("ARG_MIN"),
      Self::FAKE_QUANT => Some("FAKE_QUANT"),
      Self::REDUCE_PROD => Some("REDUCE_PROD"),
      Self::REDUCE_MAX => Some("REDUCE_MAX"),
      Self::PACK => Some("PACK"),
      Self::LOGICAL_OR => Some("LOGICAL_OR"),
      Self::ONE_HOT => Some("ONE_HOT"),
      Self::LOGICAL_AND => Some("LOGICAL_AND"),
      Self::LOGICAL_NOT => Some("LOGICAL_NOT"),
      Self::UNPACK => Some("UNPACK"),
      Self::REDUCE_MIN => Some("REDUCE_MIN"),
      Self::FLOOR_DIV => Some("FLOOR_DIV"),
      Self::REDUCE_ANY => Some("REDUCE_ANY"),
      Self::SQUARE => Some("SQUARE"),
      Self::ZEROS_LIKE => Some("ZEROS_LIKE"),
      Self::FILL => Some("FILL"),
      Self::FLOOR_MOD => Some("FLOOR_MOD"),
      Self::RANGE => Some("RANGE"),
      Self::RESIZE_NEAREST_NEIGHBOR => Some("RESIZE_NEAREST_NEIGHBOR"),
      Self::LEAKY_RELU => Some("LEAKY_RELU"),
      Self::SQUARED_DIFFERENCE => Some("SQUARED_DIFFERENCE"),
      Self::MIRROR_PAD => Some("MIRROR_PAD"),
      Self::ABS => Some("ABS"),
      Self::SPLIT_V => Some("SPLIT_V"),
      Self::UNIQUE => Some("UNIQUE"),
      Self::CEIL => Some("CEIL"),
      Self::REVERSE_V2 => Some("REVERSE_V2"),
      Self::ADD_N => Some("ADD_N"),
      Self::GATHER_ND => Some("GATHER_ND"),
      Self::COS => Some("COS"),
      Self::WHERE => Some("WHERE"),
      Self::RANK => Some("RANK"),
      Self::ELU => Some("ELU"),
      Self::REVERSE_SEQUENCE => Some("REVERSE_SEQUENCE"),
      Self::MATRIX_DIAG => Some("MATRIX_DIAG"),
      Self::QUANTIZE => Some("QUANTIZE"),
      Self::MATRIX_SET_DIAG => Some("MATRIX_SET_DIAG"),
      Self::ROUND => Some("ROUND"),
      Self::HARD_SWISH => Some("HARD_SWISH"),
      Self::IF => Some("IF"),
      Self::WHILE => Some("WHILE"),
      Self::NON_MAX_SUPPRESSION_V4 => Some("NON_MAX_SUPPRESSION_V4"),
      Self::NON_MAX_SUPPRESSION_V5 => Some("NON_MAX_SUPPRESSION_V5"),
      Self::SCATTER_ND => Some("SCATTER_ND"),
      _ => None,
    }
  }
}
impl core::fmt::Debug for BuiltinOperator {
  fn fmt(&self, f: &mut core::fmt::Formatter) -> core::fmt::Result {
    if let Some(name) = self.variant_name() {
      f.write_str(name)
    } else {
      f.write_fmt(format_args!("<UNKNOWN {:?}>", self.0))
    }
  }
}
impl<'a> flatbuffers::Follow<'a> for BuiltinOperator {
  type Inner = Self;
  #[inline]
  fn follow(buf: &'a [u8], loc: usize) -> Self::Inner {
    let b = unsafe {
      flatbuffers::read_scalar_at::<i8>(buf, loc)
    };
    Self(b)
  }
}

impl flatbuffers::Push for BuiltinOperator {
    type Output = BuiltinOperator;
    #[inline]
    fn push(&self, dst: &mut [u8], _rest: &[u8]) {
        unsafe { flatbuffers::emplace_scalar::<i8>(dst, self.0); }
    }
}

impl flatbuffers::EndianScalar for BuiltinOperator {
  #[inline]
  fn to_little_endian(self) -> Self {
    let b = i8::to_le(self.0);
    Self(b)
  }
  #[inline]
  #[allow(clippy::wrong_self_convention)]
  fn from_little_endian(self) -> Self {
    let b = i8::from_le(self.0);
    Self(b)
  }
}

impl<'a> flatbuffers::Verifiable for BuiltinOperator {
  #[inline]
  fn run_verifier(
    v: &mut flatbuffers::Verifier, pos: usize
  ) -> Result<(), flatbuffers::InvalidFlatbuffer> {
    use self::flatbuffers::Verifiable;
    i8::run_verifier(v, pos)
  }
}

impl flatbuffers::SimpleToVerifyInSlice for BuiltinOperator {}
#[deprecated(since = "2.0.0", note = "Use associated constants instead. This will no longer be generated in 2021.")]
pub const ENUM_MIN_BUILTIN_OPTIONS: u8 = 0;
#[deprecated(since = "2.0.0", note = "Use associated constants instead. This will no longer be generated in 2021.")]
pub const ENUM_MAX_BUILTIN_OPTIONS: u8 = 97;
#[deprecated(since = "2.0.0", note = "Use associated constants instead. This will no longer be generated in 2021.")]
#[allow(non_camel_case_types)]
pub const ENUM_VALUES_BUILTIN_OPTIONS: [BuiltinOptions; 98] = [
  BuiltinOptions::NONE,
  BuiltinOptions::Conv2DOptions,
  BuiltinOptions::DepthwiseConv2DOptions,
  BuiltinOptions::ConcatEmbeddingsOptions,
  BuiltinOptions::LSHProjectionOptions,
  BuiltinOptions::Pool2DOptions,
  BuiltinOptions::SVDFOptions,
  BuiltinOptions::RNNOptions,
  BuiltinOptions::FullyConnectedOptions,
  BuiltinOptions::SoftmaxOptions,
  BuiltinOptions::ConcatenationOptions,
  BuiltinOptions::AddOptions,
  BuiltinOptions::L2NormOptions,
  BuiltinOptions::LocalResponseNormalizationOptions,
  BuiltinOptions::LSTMOptions,
  BuiltinOptions::ResizeBilinearOptions,
  BuiltinOptions::CallOptions,
  BuiltinOptions::ReshapeOptions,
  BuiltinOptions::SkipGramOptions,
  BuiltinOptions::SpaceToDepthOptions,
  BuiltinOptions::EmbeddingLookupSparseOptions,
  BuiltinOptions::MulOptions,
  BuiltinOptions::PadOptions,
  BuiltinOptions::GatherOptions,
  BuiltinOptions::BatchToSpaceNDOptions,
  BuiltinOptions::SpaceToBatchNDOptions,
  BuiltinOptions::TransposeOptions,
  BuiltinOptions::ReducerOptions,
  BuiltinOptions::SubOptions,
  BuiltinOptions::DivOptions,
  BuiltinOptions::SqueezeOptions,
  BuiltinOptions::SequenceRNNOptions,
  BuiltinOptions::StridedSliceOptions,
  BuiltinOptions::ExpOptions,
  BuiltinOptions::TopKV2Options,
  BuiltinOptions::SplitOptions,
  BuiltinOptions::LogSoftmaxOptions,
  BuiltinOptions::CastOptions,
  BuiltinOptions::DequantizeOptions,
  BuiltinOptions::MaximumMinimumOptions,
  BuiltinOptions::ArgMaxOptions,
  BuiltinOptions::LessOptions,
  BuiltinOptions::NegOptions,
  BuiltinOptions::PadV2Options,
  BuiltinOptions::GreaterOptions,
  BuiltinOptions::GreaterEqualOptions,
  BuiltinOptions::LessEqualOptions,
  BuiltinOptions::SelectOptions,
  BuiltinOptions::SliceOptions,
  BuiltinOptions::TransposeConvOptions,
  BuiltinOptions::SparseToDenseOptions,
  BuiltinOptions::TileOptions,
  BuiltinOptions::ExpandDimsOptions,
  BuiltinOptions::EqualOptions,
  BuiltinOptions::NotEqualOptions,
  BuiltinOptions::ShapeOptions,
  BuiltinOptions::PowOptions,
  BuiltinOptions::ArgMinOptions,
  BuiltinOptions::FakeQuantOptions,
  BuiltinOptions::PackOptions,
  BuiltinOptions::LogicalOrOptions,
  BuiltinOptions::OneHotOptions,
  BuiltinOptions::LogicalAndOptions,
  BuiltinOptions::LogicalNotOptions,
  BuiltinOptions::UnpackOptions,
  BuiltinOptions::FloorDivOptions,
  BuiltinOptions::SquareOptions,
  BuiltinOptions::ZerosLikeOptions,
  BuiltinOptions::FillOptions,
  BuiltinOptions::BidirectionalSequenceLSTMOptions,
  BuiltinOptions::BidirectionalSequenceRNNOptions,
  BuiltinOptions::UnidirectionalSequenceLSTMOptions,
  BuiltinOptions::FloorModOptions,
  BuiltinOptions::RangeOptions,
  BuiltinOptions::ResizeNearestNeighborOptions,
  BuiltinOptions::LeakyReluOptions,
  BuiltinOptions::SquaredDifferenceOptions,
  BuiltinOptions::MirrorPadOptions,
  BuiltinOptions::AbsOptions,
  BuiltinOptions::SplitVOptions,
  BuiltinOptions::UniqueOptions,
  BuiltinOptions::ReverseV2Options,
  BuiltinOptions::AddNOptions,
  BuiltinOptions::GatherNdOptions,
  BuiltinOptions::CosOptions,
  BuiltinOptions::WhereOptions,
  BuiltinOptions::RankOptions,
  BuiltinOptions::ReverseSequenceOptions,
  BuiltinOptions::MatrixDiagOptions,
  BuiltinOptions::QuantizeOptions,
  BuiltinOptions::MatrixSetDiagOptions,
  BuiltinOptions::HardSwishOptions,
  BuiltinOptions::IfOptions,
  BuiltinOptions::WhileOptions,
  BuiltinOptions::DepthToSpaceOptions,
  BuiltinOptions::NonMaxSuppressionV4Options,
  BuiltinOptions::NonMaxSuppressionV5Options,
  BuiltinOptions::ScatterNdOptions,
];

#[derive(Clone, Copy, PartialEq, Eq, PartialOrd, Ord, Hash, Default)]
#[repr(transparent)]
pub struct BuiltinOptions(pub u8);
#[allow(non_upper_case_globals)]
impl BuiltinOptions {
  pub const NONE: Self = Self(0);
  pub const Conv2DOptions: Self = Self(1);
  pub const DepthwiseConv2DOptions: Self = Self(2);
  pub const ConcatEmbeddingsOptions: Self = Self(3);
  pub const LSHProjectionOptions: Self = Self(4);
  pub const Pool2DOptions: Self = Self(5);
  pub const SVDFOptions: Self = Self(6);
  pub const RNNOptions: Self = Self(7);
  pub const FullyConnectedOptions: Self = Self(8);
  pub const SoftmaxOptions: Self = Self(9);
  pub const ConcatenationOptions: Self = Self(10);
  pub const AddOptions: Self = Self(11);
  pub const L2NormOptions: Self = Self(12);
  pub const LocalResponseNormalizationOptions: Self = Self(13);
  pub const LSTMOptions: Self = Self(14);
  pub const ResizeBilinearOptions: Self = Self(15);
  pub const CallOptions: Self = Self(16);
  pub const ReshapeOptions: Self = Self(17);
  pub const SkipGramOptions: Self = Self(18);
  pub const SpaceToDepthOptions: Self = Self(19);
  pub const EmbeddingLookupSparseOptions: Self = Self(20);
  pub const MulOptions: Self = Self(21);
  pub const PadOptions: Self = Self(22);
  pub const GatherOptions: Self = Self(23);
  pub const BatchToSpaceNDOptions: Self = Self(24);
  pub const SpaceToBatchNDOptions: Self = Self(25);
  pub const TransposeOptions: Self = Self(26);
  pub const ReducerOptions: Self = Self(27);
  pub const SubOptions: Self = Self(28);
  pub const DivOptions: Self = Self(29);
  pub const SqueezeOptions: Self = Self(30);
  pub const SequenceRNNOptions: Self = Self(31);
  pub const StridedSliceOptions: Self = Self(32);
  pub const ExpOptions: Self = Self(33);
  pub const TopKV2Options: Self = Self(34);
  pub const SplitOptions: Self = Self(35);
  pub const LogSoftmaxOptions: Self = Self(36);
  pub const CastOptions: Self = Self(37);
  pub const DequantizeOptions: Self = Self(38);
  pub const MaximumMinimumOptions: Self = Self(39);
  pub const ArgMaxOptions: Self = Self(40);
  pub const LessOptions: Self = Self(41);
  pub const NegOptions: Self = Self(42);
  pub const PadV2Options: Self = Self(43);
  pub const GreaterOptions: Self = Self(44);
  pub const GreaterEqualOptions: Self = Self(45);
  pub const LessEqualOptions: Self = Self(46);
  pub const SelectOptions: Self = Self(47);
  pub const SliceOptions: Self = Self(48);
  pub const TransposeConvOptions: Self = Self(49);
  pub const SparseToDenseOptions: Self = Self(50);
  pub const TileOptions: Self = Self(51);
  pub const ExpandDimsOptions: Self = Self(52);
  pub const EqualOptions: Self = Self(53);
  pub const NotEqualOptions: Self = Self(54);
  pub const ShapeOptions: Self = Self(55);
  pub const PowOptions: Self = Self(56);
  pub const ArgMinOptions: Self = Self(57);
  pub const FakeQuantOptions: Self = Self(58);
  pub const PackOptions: Self = Self(59);
  pub const LogicalOrOptions: Self = Self(60);
  pub const OneHotOptions: Self = Self(61);
  pub const LogicalAndOptions: Self = Self(62);
  pub const LogicalNotOptions: Self = Self(63);
  pub const UnpackOptions: Self = Self(64);
  pub const FloorDivOptions: Self = Self(65);
  pub const SquareOptions: Self = Self(66);
  pub const ZerosLikeOptions: Self = Self(67);
  pub const FillOptions: Self = Self(68);
  pub const BidirectionalSequenceLSTMOptions: Self = Self(69);
  pub const BidirectionalSequenceRNNOptions: Self = Self(70);
  pub const UnidirectionalSequenceLSTMOptions: Self = Self(71);
  pub const FloorModOptions: Self = Self(72);
  pub const RangeOptions: Self = Self(73);
  pub const ResizeNearestNeighborOptions: Self = Self(74);
  pub const LeakyReluOptions: Self = Self(75);
  pub const SquaredDifferenceOptions: Self = Self(76);
  pub const MirrorPadOptions: Self = Self(77);
  pub const AbsOptions: Self = Self(78);
  pub const SplitVOptions: Self = Self(79);
  pub const UniqueOptions: Self = Self(80);
  pub const ReverseV2Options: Self = Self(81);
  pub const AddNOptions: Self = Self(82);
  pub const GatherNdOptions: Self = Self(83);
  pub const CosOptions: Self = Self(84);
  pub const WhereOptions: Self = Self(85);
  pub const RankOptions: Self = Self(86);
  pub const ReverseSequenceOptions: Self = Self(87);
  pub const MatrixDiagOptions: Self = Self(88);
  pub const QuantizeOptions: Self = Self(89);
  pub const MatrixSetDiagOptions: Self = Self(90);
  pub const HardSwishOptions: Self = Self(91);
  pub const IfOptions: Self = Self(92);
  pub const WhileOptions: Self = Self(93);
  pub const DepthToSpaceOptions: Self = Self(94);
  pub const NonMaxSuppressionV4Options: Self = Self(95);
  pub const NonMaxSuppressionV5Options: Self = Self(96);
  pub const ScatterNdOptions: Self = Self(97);

  pub const ENUM_MIN: u8 = 0;
  pub const ENUM_MAX: u8 = 97;
  pub const ENUM_VALUES: &'static [Self] = &[
    Self::NONE,
    Self::Conv2DOptions,
    Self::DepthwiseConv2DOptions,
    Self::ConcatEmbeddingsOptions,
    Self::LSHProjectionOptions,
    Self::Pool2DOptions,
    Self::SVDFOptions,
    Self::RNNOptions,
    Self::FullyConnectedOptions,
    Self::SoftmaxOptions,
    Self::ConcatenationOptions,
    Self::AddOptions,
    Self::L2NormOptions,
    Self::LocalResponseNormalizationOptions,
    Self::LSTMOptions,
    Self::ResizeBilinearOptions,
    Self::CallOptions,
    Self::ReshapeOptions,
    Self::SkipGramOptions,
    Self::SpaceToDepthOptions,
    Self::EmbeddingLookupSparseOptions,
    Self::MulOptions,
    Self::PadOptions,
    Self::GatherOptions,
    Self::BatchToSpaceNDOptions,
    Self::SpaceToBatchNDOptions,
    Self::TransposeOptions,
    Self::ReducerOptions,
    Self::SubOptions,
    Self::DivOptions,
    Self::SqueezeOptions,
    Self::SequenceRNNOptions,
    Self::StridedSliceOptions,
    Self::ExpOptions,
    Self::TopKV2Options,
    Self::SplitOptions,
    Self::LogSoftmaxOptions,
    Self::CastOptions,
    Self::DequantizeOptions,
    Self::MaximumMinimumOptions,
    Self::ArgMaxOptions,
    Self::LessOptions,
    Self::NegOptions,
    Self::PadV2Options,
    Self::GreaterOptions,
    Self::GreaterEqualOptions,
    Self::LessEqualOptions,
    Self::SelectOptions,
    Self::SliceOptions,
    Self::TransposeConvOptions,
    Self::SparseToDenseOptions,
    Self::TileOptions,
    Self::ExpandDimsOptions,
    Self::EqualOptions,
    Self::NotEqualOptions,
    Self::ShapeOptions,
    Self::PowOptions,
    Self::ArgMinOptions,
    Self::FakeQuantOptions,
    Self::PackOptions,
    Self::LogicalOrOptions,
    Self::OneHotOptions,
    Self::LogicalAndOptions,
    Self::LogicalNotOptions,
    Self::UnpackOptions,
    Self::FloorDivOptions,
    Self::SquareOptions,
    Self::ZerosLikeOptions,
    Self::FillOptions,
    Self::BidirectionalSequenceLSTMOptions,
    Self::BidirectionalSequenceRNNOptions,
    Self::UnidirectionalSequenceLSTMOptions,
    Self::FloorModOptions,
    Self::RangeOptions,
    Self::ResizeNearestNeighborOptions,
    Self::LeakyReluOptions,
    Self::SquaredDifferenceOptions,
    Self::MirrorPadOptions,
    Self::AbsOptions,
    Self::SplitVOptions,
    Self::UniqueOptions,
    Self::ReverseV2Options,
    Self::AddNOptions,
    Self::GatherNdOptions,
    Self::CosOptions,
    Self::WhereOptions,
    Self::RankOptions,
    Self::ReverseSequenceOptions,
    Self::MatrixDiagOptions,
    Self::QuantizeOptions,
    Self::MatrixSetDiagOptions,
    Self::HardSwishOptions,
    Self::IfOptions,
    Self::WhileOptions,
    Self::DepthToSpaceOptions,
    Self::NonMaxSuppressionV4Options,
    Self::NonMaxSuppressionV5Options,
    Self::ScatterNdOptions,
  ];
  /// Returns the variant's name or "" if unknown.
  pub fn variant_name(self) -> Option<&'static str> {
    match self {
      Self::NONE => Some("NONE"),
      Self::Conv2DOptions => Some("Conv2DOptions"),
      Self::DepthwiseConv2DOptions => Some("DepthwiseConv2DOptions"),
      Self::ConcatEmbeddingsOptions => Some("ConcatEmbeddingsOptions"),
      Self::LSHProjectionOptions => Some("LSHProjectionOptions"),
      Self::Pool2DOptions => Some("Pool2DOptions"),
      Self::SVDFOptions => Some("SVDFOptions"),
      Self::RNNOptions => Some("RNNOptions"),
      Self::FullyConnectedOptions => Some("FullyConnectedOptions"),
      Self::SoftmaxOptions => Some("SoftmaxOptions"),
      Self::ConcatenationOptions => Some("ConcatenationOptions"),
      Self::AddOptions => Some("AddOptions"),
      Self::L2NormOptions => Some("L2NormOptions"),
      Self::LocalResponseNormalizationOptions => Some("LocalResponseNormalizationOptions"),
      Self::LSTMOptions => Some("LSTMOptions"),
      Self::ResizeBilinearOptions => Some("ResizeBilinearOptions"),
      Self::CallOptions => Some("CallOptions"),
      Self::ReshapeOptions => Some("ReshapeOptions"),
      Self::SkipGramOptions => Some("SkipGramOptions"),
      Self::SpaceToDepthOptions => Some("SpaceToDepthOptions"),
      Self::EmbeddingLookupSparseOptions => Some("EmbeddingLookupSparseOptions"),
      Self::MulOptions => Some("MulOptions"),
      Self::PadOptions => Some("PadOptions"),
      Self::GatherOptions => Some("GatherOptions"),
      Self::BatchToSpaceNDOptions => Some("BatchToSpaceNDOptions"),
      Self::SpaceToBatchNDOptions => Some("SpaceToBatchNDOptions"),
      Self::TransposeOptions => Some("TransposeOptions"),
      Self::ReducerOptions => Some("ReducerOptions"),
      Self::SubOptions => Some("SubOptions"),
      Self::DivOptions => Some("DivOptions"),
      Self::SqueezeOptions => Some("SqueezeOptions"),
      Self::SequenceRNNOptions => Some("SequenceRNNOptions"),
      Self::StridedSliceOptions => Some("StridedSliceOptions"),
      Self::ExpOptions => Some("ExpOptions"),
      Self::TopKV2Options => Some("TopKV2Options"),
      Self::SplitOptions => Some("SplitOptions"),
      Self::LogSoftmaxOptions => Some("LogSoftmaxOptions"),
      Self::CastOptions => Some("CastOptions"),
      Self::DequantizeOptions => Some("DequantizeOptions"),
      Self::MaximumMinimumOptions => Some("MaximumMinimumOptions"),
      Self::ArgMaxOptions => Some("ArgMaxOptions"),
      Self::LessOptions => Some("LessOptions"),
      Self::NegOptions => Some("NegOptions"),
      Self::PadV2Options => Some("PadV2Options"),
      Self::GreaterOptions => Some("GreaterOptions"),
      Self::GreaterEqualOptions => Some("GreaterEqualOptions"),
      Self::LessEqualOptions => Some("LessEqualOptions"),
      Self::SelectOptions => Some("SelectOptions"),
      Self::SliceOptions => Some("SliceOptions"),
      Self::TransposeConvOptions => Some("TransposeConvOptions"),
      Self::SparseToDenseOptions => Some("SparseToDenseOptions"),
      Self::TileOptions => Some("TileOptions"),
      Self::ExpandDimsOptions => Some("ExpandDimsOptions"),
      Self::EqualOptions => Some("EqualOptions"),
      Self::NotEqualOptions => Some("NotEqualOptions"),
      Self::ShapeOptions => Some("ShapeOptions"),
      Self::PowOptions => Some("PowOptions"),
      Self::ArgMinOptions => Some("ArgMinOptions"),
      Self::FakeQuantOptions => Some("FakeQuantOptions"),
      Self::PackOptions => Some("PackOptions"),
      Self::LogicalOrOptions => Some("LogicalOrOptions"),
      Self::OneHotOptions => Some("OneHotOptions"),
      Self::LogicalAndOptions => Some("LogicalAndOptions"),
      Self::LogicalNotOptions => Some("LogicalNotOptions"),
      Self::UnpackOptions => Some("UnpackOptions"),
      Self::FloorDivOptions => Some("FloorDivOptions"),
      Self::SquareOptions => Some("SquareOptions"),
      Self::ZerosLikeOptions => Some("ZerosLikeOptions"),
      Self::FillOptions => Some("FillOptions"),
      Self::BidirectionalSequenceLSTMOptions => Some("BidirectionalSequenceLSTMOptions"),
      Self::BidirectionalSequenceRNNOptions => Some("BidirectionalSequenceRNNOptions"),
      Self::UnidirectionalSequenceLSTMOptions => Some("UnidirectionalSequenceLSTMOptions"),
      Self::FloorModOptions => Some("FloorModOptions"),
      Self::RangeOptions => Some("RangeOptions"),
      Self::ResizeNearestNeighborOptions => Some("ResizeNearestNeighborOptions"),
      Self::LeakyReluOptions => Some("LeakyReluOptions"),
      Self::SquaredDifferenceOptions => Some("SquaredDifferenceOptions"),
      Self::MirrorPadOptions => Some("MirrorPadOptions"),
      Self::AbsOptions => Some("AbsOptions"),
      Self::SplitVOptions => Some("SplitVOptions"),
      Self::UniqueOptions => Some("UniqueOptions"),
      Self::ReverseV2Options => Some("ReverseV2Options"),
      Self::AddNOptions => Some("AddNOptions"),
      Self::GatherNdOptions => Some("GatherNdOptions"),
      Self::CosOptions => Some("CosOptions"),
      Self::WhereOptions => Some("WhereOptions"),
      Self::RankOptions => Some("RankOptions"),
      Self::ReverseSequenceOptions => Some("ReverseSequenceOptions"),
      Self::MatrixDiagOptions => Some("MatrixDiagOptions"),
      Self::QuantizeOptions => Some("QuantizeOptions"),
      Self::MatrixSetDiagOptions => Some("MatrixSetDiagOptions"),
      Self::HardSwishOptions => Some("HardSwishOptions"),
      Self::IfOptions => Some("IfOptions"),
      Self::WhileOptions => Some("WhileOptions"),
      Self::DepthToSpaceOptions => Some("DepthToSpaceOptions"),
      Self::NonMaxSuppressionV4Options => Some("NonMaxSuppressionV4Options"),
      Self::NonMaxSuppressionV5Options => Some("NonMaxSuppressionV5Options"),
      Self::ScatterNdOptions => Some("ScatterNdOptions"),
      _ => None,
    }
  }
}
impl core::fmt::Debug for BuiltinOptions {
  fn fmt(&self, f: &mut core::fmt::Formatter) -> core::fmt::Result {
    if let Some(name) = self.variant_name() {
      f.write_str(name)
    } else {
      f.write_fmt(format_args!("<UNKNOWN {:?}>", self.0))
    }
  }
}
impl<'a> flatbuffers::Follow<'a> for BuiltinOptions {
  type Inner = Self;
  #[inline]
  fn follow(buf: &'a [u8], loc: usize) -> Self::Inner {
    let b = unsafe {
      flatbuffers::read_scalar_at::<u8>(buf, loc)
    };
    Self(b)
  }
}

impl flatbuffers::Push for BuiltinOptions {
    type Output = BuiltinOptions;
    #[inline]
    fn push(&self, dst: &mut [u8], _rest: &[u8]) {
        unsafe { flatbuffers::emplace_scalar::<u8>(dst, self.0); }
    }
}

impl flatbuffers::EndianScalar for BuiltinOptions {
  #[inline]
  fn to_little_endian(self) -> Self {
    let b = u8::to_le(self.0);
    Self(b)
  }
  #[inline]
  #[allow(clippy::wrong_self_convention)]
  fn from_little_endian(self) -> Self {
    let b = u8::from_le(self.0);
    Self(b)
  }
}

impl<'a> flatbuffers::Verifiable for BuiltinOptions {
  #[inline]
  fn run_verifier(
    v: &mut flatbuffers::Verifier, pos: usize
  ) -> Result<(), flatbuffers::InvalidFlatbuffer> {
    use self::flatbuffers::Verifiable;
    u8::run_verifier(v, pos)
  }
}

impl flatbuffers::SimpleToVerifyInSlice for BuiltinOptions {}
pub struct BuiltinOptionsUnionTableOffset {}

#[allow(clippy::upper_case_acronyms)]
#[non_exhaustive]
#[derive(Debug, Clone, PartialEq)]
pub enum BuiltinOptionsT {
  NONE,
  Conv2DOptions(Box<Conv2DOptionsT>),
  DepthwiseConv2DOptions(Box<DepthwiseConv2DOptionsT>),
  ConcatEmbeddingsOptions(Box<ConcatEmbeddingsOptionsT>),
  LSHProjectionOptions(Box<LSHProjectionOptionsT>),
  Pool2DOptions(Box<Pool2DOptionsT>),
  SVDFOptions(Box<SVDFOptionsT>),
  RNNOptions(Box<RNNOptionsT>),
  FullyConnectedOptions(Box<FullyConnectedOptionsT>),
  SoftmaxOptions(Box<SoftmaxOptionsT>),
  ConcatenationOptions(Box<ConcatenationOptionsT>),
  AddOptions(Box<AddOptionsT>),
  L2NormOptions(Box<L2NormOptionsT>),
  LocalResponseNormalizationOptions(Box<LocalResponseNormalizationOptionsT>),
  LSTMOptions(Box<LSTMOptionsT>),
  ResizeBilinearOptions(Box<ResizeBilinearOptionsT>),
  CallOptions(Box<CallOptionsT>),
  ReshapeOptions(Box<ReshapeOptionsT>),
  SkipGramOptions(Box<SkipGramOptionsT>),
  SpaceToDepthOptions(Box<SpaceToDepthOptionsT>),
  EmbeddingLookupSparseOptions(Box<EmbeddingLookupSparseOptionsT>),
  MulOptions(Box<MulOptionsT>),
  PadOptions(Box<PadOptionsT>),
  GatherOptions(Box<GatherOptionsT>),
  BatchToSpaceNDOptions(Box<BatchToSpaceNDOptionsT>),
  SpaceToBatchNDOptions(Box<SpaceToBatchNDOptionsT>),
  TransposeOptions(Box<TransposeOptionsT>),
  ReducerOptions(Box<ReducerOptionsT>),
  SubOptions(Box<SubOptionsT>),
  DivOptions(Box<DivOptionsT>),
  SqueezeOptions(Box<SqueezeOptionsT>),
  SequenceRNNOptions(Box<SequenceRNNOptionsT>),
  StridedSliceOptions(Box<StridedSliceOptionsT>),
  ExpOptions(Box<ExpOptionsT>),
  TopKV2Options(Box<TopKV2OptionsT>),
  SplitOptions(Box<SplitOptionsT>),
  LogSoftmaxOptions(Box<LogSoftmaxOptionsT>),
  CastOptions(Box<CastOptionsT>),
  DequantizeOptions(Box<DequantizeOptionsT>),
  MaximumMinimumOptions(Box<MaximumMinimumOptionsT>),
  ArgMaxOptions(Box<ArgMaxOptionsT>),
  LessOptions(Box<LessOptionsT>),
  NegOptions(Box<NegOptionsT>),
  PadV2Options(Box<PadV2OptionsT>),
  GreaterOptions(Box<GreaterOptionsT>),
  GreaterEqualOptions(Box<GreaterEqualOptionsT>),
  LessEqualOptions(Box<LessEqualOptionsT>),
  SelectOptions(Box<SelectOptionsT>),
  SliceOptions(Box<SliceOptionsT>),
  TransposeConvOptions(Box<TransposeConvOptionsT>),
  SparseToDenseOptions(Box<SparseToDenseOptionsT>),
  TileOptions(Box<TileOptionsT>),
  ExpandDimsOptions(Box<ExpandDimsOptionsT>),
  EqualOptions(Box<EqualOptionsT>),
  NotEqualOptions(Box<NotEqualOptionsT>),
  ShapeOptions(Box<ShapeOptionsT>),
  PowOptions(Box<PowOptionsT>),
  ArgMinOptions(Box<ArgMinOptionsT>),
  FakeQuantOptions(Box<FakeQuantOptionsT>),
  PackOptions(Box<PackOptionsT>),
  LogicalOrOptions(Box<LogicalOrOptionsT>),
  OneHotOptions(Box<OneHotOptionsT>),
  LogicalAndOptions(Box<LogicalAndOptionsT>),
  LogicalNotOptions(Box<LogicalNotOptionsT>),
  UnpackOptions(Box<UnpackOptionsT>),
  FloorDivOptions(Box<FloorDivOptionsT>),
  SquareOptions(Box<SquareOptionsT>),
  ZerosLikeOptions(Box<ZerosLikeOptionsT>),
  FillOptions(Box<FillOptionsT>),
  BidirectionalSequenceLSTMOptions(Box<BidirectionalSequenceLSTMOptionsT>),
  BidirectionalSequenceRNNOptions(Box<BidirectionalSequenceRNNOptionsT>),
  UnidirectionalSequenceLSTMOptions(Box<UnidirectionalSequenceLSTMOptionsT>),
  FloorModOptions(Box<FloorModOptionsT>),
  RangeOptions(Box<RangeOptionsT>),
  ResizeNearestNeighborOptions(Box<ResizeNearestNeighborOptionsT>),
  LeakyReluOptions(Box<LeakyReluOptionsT>),
  SquaredDifferenceOptions(Box<SquaredDifferenceOptionsT>),
  MirrorPadOptions(Box<MirrorPadOptionsT>),
  AbsOptions(Box<AbsOptionsT>),
  SplitVOptions(Box<SplitVOptionsT>),
  UniqueOptions(Box<UniqueOptionsT>),
  ReverseV2Options(Box<ReverseV2OptionsT>),
  AddNOptions(Box<AddNOptionsT>),
  GatherNdOptions(Box<GatherNdOptionsT>),
  CosOptions(Box<CosOptionsT>),
  WhereOptions(Box<WhereOptionsT>),
  RankOptions(Box<RankOptionsT>),
  ReverseSequenceOptions(Box<ReverseSequenceOptionsT>),
  MatrixDiagOptions(Box<MatrixDiagOptionsT>),
  QuantizeOptions(Box<QuantizeOptionsT>),
  MatrixSetDiagOptions(Box<MatrixSetDiagOptionsT>),
  HardSwishOptions(Box<HardSwishOptionsT>),
  IfOptions(Box<IfOptionsT>),
  WhileOptions(Box<WhileOptionsT>),
  DepthToSpaceOptions(Box<DepthToSpaceOptionsT>),
  NonMaxSuppressionV4Options(Box<NonMaxSuppressionV4OptionsT>),
  NonMaxSuppressionV5Options(Box<NonMaxSuppressionV5OptionsT>),
  ScatterNdOptions(Box<ScatterNdOptionsT>),
}
impl Default for BuiltinOptionsT {
  fn default() -> Self {
    Self::NONE
  }
}
impl BuiltinOptionsT {
  pub fn builtin_options_type(&self) -> BuiltinOptions {
    match self {
      Self::NONE => BuiltinOptions::NONE,
      Self::Conv2DOptions(_) => BuiltinOptions::Conv2DOptions,
      Self::DepthwiseConv2DOptions(_) => BuiltinOptions::DepthwiseConv2DOptions,
      Self::ConcatEmbeddingsOptions(_) => BuiltinOptions::ConcatEmbeddingsOptions,
      Self::LSHProjectionOptions(_) => BuiltinOptions::LSHProjectionOptions,
      Self::Pool2DOptions(_) => BuiltinOptions::Pool2DOptions,
      Self::SVDFOptions(_) => BuiltinOptions::SVDFOptions,
      Self::RNNOptions(_) => BuiltinOptions::RNNOptions,
      Self::FullyConnectedOptions(_) => BuiltinOptions::FullyConnectedOptions,
      Self::SoftmaxOptions(_) => BuiltinOptions::SoftmaxOptions,
      Self::ConcatenationOptions(_) => BuiltinOptions::ConcatenationOptions,
      Self::AddOptions(_) => BuiltinOptions::AddOptions,
      Self::L2NormOptions(_) => BuiltinOptions::L2NormOptions,
      Self::LocalResponseNormalizationOptions(_) => BuiltinOptions::LocalResponseNormalizationOptions,
      Self::LSTMOptions(_) => BuiltinOptions::LSTMOptions,
      Self::ResizeBilinearOptions(_) => BuiltinOptions::ResizeBilinearOptions,
      Self::CallOptions(_) => BuiltinOptions::CallOptions,
      Self::ReshapeOptions(_) => BuiltinOptions::ReshapeOptions,
      Self::SkipGramOptions(_) => BuiltinOptions::SkipGramOptions,
      Self::SpaceToDepthOptions(_) => BuiltinOptions::SpaceToDepthOptions,
      Self::EmbeddingLookupSparseOptions(_) => BuiltinOptions::EmbeddingLookupSparseOptions,
      Self::MulOptions(_) => BuiltinOptions::MulOptions,
      Self::PadOptions(_) => BuiltinOptions::PadOptions,
      Self::GatherOptions(_) => BuiltinOptions::GatherOptions,
      Self::BatchToSpaceNDOptions(_) => BuiltinOptions::BatchToSpaceNDOptions,
      Self::SpaceToBatchNDOptions(_) => BuiltinOptions::SpaceToBatchNDOptions,
      Self::TransposeOptions(_) => BuiltinOptions::TransposeOptions,
      Self::ReducerOptions(_) => BuiltinOptions::ReducerOptions,
      Self::SubOptions(_) => BuiltinOptions::SubOptions,
      Self::DivOptions(_) => BuiltinOptions::DivOptions,
      Self::SqueezeOptions(_) => BuiltinOptions::SqueezeOptions,
      Self::SequenceRNNOptions(_) => BuiltinOptions::SequenceRNNOptions,
      Self::StridedSliceOptions(_) => BuiltinOptions::StridedSliceOptions,
      Self::ExpOptions(_) => BuiltinOptions::ExpOptions,
      Self::TopKV2Options(_) => BuiltinOptions::TopKV2Options,
      Self::SplitOptions(_) => BuiltinOptions::SplitOptions,
      Self::LogSoftmaxOptions(_) => BuiltinOptions::LogSoftmaxOptions,
      Self::CastOptions(_) => BuiltinOptions::CastOptions,
      Self::DequantizeOptions(_) => BuiltinOptions::DequantizeOptions,
      Self::MaximumMinimumOptions(_) => BuiltinOptions::MaximumMinimumOptions,
      Self::ArgMaxOptions(_) => BuiltinOptions::ArgMaxOptions,
      Self::LessOptions(_) => BuiltinOptions::LessOptions,
      Self::NegOptions(_) => BuiltinOptions::NegOptions,
      Self::PadV2Options(_) => BuiltinOptions::PadV2Options,
      Self::GreaterOptions(_) => BuiltinOptions::GreaterOptions,
      Self::GreaterEqualOptions(_) => BuiltinOptions::GreaterEqualOptions,
      Self::LessEqualOptions(_) => BuiltinOptions::LessEqualOptions,
      Self::SelectOptions(_) => BuiltinOptions::SelectOptions,
      Self::SliceOptions(_) => BuiltinOptions::SliceOptions,
      Self::TransposeConvOptions(_) => BuiltinOptions::TransposeConvOptions,
      Self::SparseToDenseOptions(_) => BuiltinOptions::SparseToDenseOptions,
      Self::TileOptions(_) => BuiltinOptions::TileOptions,
      Self::ExpandDimsOptions(_) => BuiltinOptions::ExpandDimsOptions,
      Self::EqualOptions(_) => BuiltinOptions::EqualOptions,
      Self::NotEqualOptions(_) => BuiltinOptions::NotEqualOptions,
      Self::ShapeOptions(_) => BuiltinOptions::ShapeOptions,
      Self::PowOptions(_) => BuiltinOptions::PowOptions,
      Self::ArgMinOptions(_) => BuiltinOptions::ArgMinOptions,
      Self::FakeQuantOptions(_) => BuiltinOptions::FakeQuantOptions,
      Self::PackOptions(_) => BuiltinOptions::PackOptions,
      Self::LogicalOrOptions(_) => BuiltinOptions::LogicalOrOptions,
      Self::OneHotOptions(_) => BuiltinOptions::OneHotOptions,
      Self::LogicalAndOptions(_) => BuiltinOptions::LogicalAndOptions,
      Self::LogicalNotOptions(_) => BuiltinOptions::LogicalNotOptions,
      Self::UnpackOptions(_) => BuiltinOptions::UnpackOptions,
      Self::FloorDivOptions(_) => BuiltinOptions::FloorDivOptions,
      Self::SquareOptions(_) => BuiltinOptions::SquareOptions,
      Self::ZerosLikeOptions(_) => BuiltinOptions::ZerosLikeOptions,
      Self::FillOptions(_) => BuiltinOptions::FillOptions,
      Self::BidirectionalSequenceLSTMOptions(_) => BuiltinOptions::BidirectionalSequenceLSTMOptions,
      Self::BidirectionalSequenceRNNOptions(_) => BuiltinOptions::BidirectionalSequenceRNNOptions,
      Self::UnidirectionalSequenceLSTMOptions(_) => BuiltinOptions::UnidirectionalSequenceLSTMOptions,
      Self::FloorModOptions(_) => BuiltinOptions::FloorModOptions,
      Self::RangeOptions(_) => BuiltinOptions::RangeOptions,
      Self::ResizeNearestNeighborOptions(_) => BuiltinOptions::ResizeNearestNeighborOptions,
      Self::LeakyReluOptions(_) => BuiltinOptions::LeakyReluOptions,
      Self::SquaredDifferenceOptions(_) => BuiltinOptions::SquaredDifferenceOptions,
      Self::MirrorPadOptions(_) => BuiltinOptions::MirrorPadOptions,
      Self::AbsOptions(_) => BuiltinOptions::AbsOptions,
      Self::SplitVOptions(_) => BuiltinOptions::SplitVOptions,
      Self::UniqueOptions(_) => BuiltinOptions::UniqueOptions,
      Self::ReverseV2Options(_) => BuiltinOptions::ReverseV2Options,
      Self::AddNOptions(_) => BuiltinOptions::AddNOptions,
      Self::GatherNdOptions(_) => BuiltinOptions::GatherNdOptions,
      Self::CosOptions(_) => BuiltinOptions::CosOptions,
      Self::WhereOptions(_) => BuiltinOptions::WhereOptions,
      Self::RankOptions(_) => BuiltinOptions::RankOptions,
      Self::ReverseSequenceOptions(_) => BuiltinOptions::ReverseSequenceOptions,
      Self::MatrixDiagOptions(_) => BuiltinOptions::MatrixDiagOptions,
      Self::QuantizeOptions(_) => BuiltinOptions::QuantizeOptions,
      Self::MatrixSetDiagOptions(_) => BuiltinOptions::MatrixSetDiagOptions,
      Self::HardSwishOptions(_) => BuiltinOptions::HardSwishOptions,
      Self::IfOptions(_) => BuiltinOptions::IfOptions,
      Self::WhileOptions(_) => BuiltinOptions::WhileOptions,
      Self::DepthToSpaceOptions(_) => BuiltinOptions::DepthToSpaceOptions,
      Self::NonMaxSuppressionV4Options(_) => BuiltinOptions::NonMaxSuppressionV4Options,
      Self::NonMaxSuppressionV5Options(_) => BuiltinOptions::NonMaxSuppressionV5Options,
      Self::ScatterNdOptions(_) => BuiltinOptions::ScatterNdOptions,
    }
  }
  pub fn pack(&self, fbb: &mut flatbuffers::FlatBufferBuilder) -> Option<flatbuffers::WIPOffset<flatbuffers::UnionWIPOffset>> {
    match self {
      Self::NONE => None,
      Self::Conv2DOptions(v) => Some(v.pack(fbb).as_union_value()),
      Self::DepthwiseConv2DOptions(v) => Some(v.pack(fbb).as_union_value()),
      Self::ConcatEmbeddingsOptions(v) => Some(v.pack(fbb).as_union_value()),
      Self::LSHProjectionOptions(v) => Some(v.pack(fbb).as_union_value()),
      Self::Pool2DOptions(v) => Some(v.pack(fbb).as_union_value()),
      Self::SVDFOptions(v) => Some(v.pack(fbb).as_union_value()),
      Self::RNNOptions(v) => Some(v.pack(fbb).as_union_value()),
      Self::FullyConnectedOptions(v) => Some(v.pack(fbb).as_union_value()),
      Self::SoftmaxOptions(v) => Some(v.pack(fbb).as_union_value()),
      Self::ConcatenationOptions(v) => Some(v.pack(fbb).as_union_value()),
      Self::AddOptions(v) => Some(v.pack(fbb).as_union_value()),
      Self::L2NormOptions(v) => Some(v.pack(fbb).as_union_value()),
      Self::LocalResponseNormalizationOptions(v) => Some(v.pack(fbb).as_union_value()),
      Self::LSTMOptions(v) => Some(v.pack(fbb).as_union_value()),
      Self::ResizeBilinearOptions(v) => Some(v.pack(fbb).as_union_value()),
      Self::CallOptions(v) => Some(v.pack(fbb).as_union_value()),
      Self::ReshapeOptions(v) => Some(v.pack(fbb).as_union_value()),
      Self::SkipGramOptions(v) => Some(v.pack(fbb).as_union_value()),
      Self::SpaceToDepthOptions(v) => Some(v.pack(fbb).as_union_value()),
      Self::EmbeddingLookupSparseOptions(v) => Some(v.pack(fbb).as_union_value()),
      Self::MulOptions(v) => Some(v.pack(fbb).as_union_value()),
      Self::PadOptions(v) => Some(v.pack(fbb).as_union_value()),
      Self::GatherOptions(v) => Some(v.pack(fbb).as_union_value()),
      Self::BatchToSpaceNDOptions(v) => Some(v.pack(fbb).as_union_value()),
      Self::SpaceToBatchNDOptions(v) => Some(v.pack(fbb).as_union_value()),
      Self::TransposeOptions(v) => Some(v.pack(fbb).as_union_value()),
      Self::ReducerOptions(v) => Some(v.pack(fbb).as_union_value()),
      Self::SubOptions(v) => Some(v.pack(fbb).as_union_value()),
      Self::DivOptions(v) => Some(v.pack(fbb).as_union_value()),
      Self::SqueezeOptions(v) => Some(v.pack(fbb).as_union_value()),
      Self::SequenceRNNOptions(v) => Some(v.pack(fbb).as_union_value()),
      Self::StridedSliceOptions(v) => Some(v.pack(fbb).as_union_value()),
      Self::ExpOptions(v) => Some(v.pack(fbb).as_union_value()),
      Self::TopKV2Options(v) => Some(v.pack(fbb).as_union_value()),
      Self::SplitOptions(v) => Some(v.pack(fbb).as_union_value()),
      Self::LogSoftmaxOptions(v) => Some(v.pack(fbb).as_union_value()),
      Self::CastOptions(v) => Some(v.pack(fbb).as_union_value()),
      Self::DequantizeOptions(v) => Some(v.pack(fbb).as_union_value()),
      Self::MaximumMinimumOptions(v) => Some(v.pack(fbb).as_union_value()),
      Self::ArgMaxOptions(v) => Some(v.pack(fbb).as_union_value()),
      Self::LessOptions(v) => Some(v.pack(fbb).as_union_value()),
      Self::NegOptions(v) => Some(v.pack(fbb).as_union_value()),
      Self::PadV2Options(v) => Some(v.pack(fbb).as_union_value()),
      Self::GreaterOptions(v) => Some(v.pack(fbb).as_union_value()),
      Self::GreaterEqualOptions(v) => Some(v.pack(fbb).as_union_value()),
      Self::LessEqualOptions(v) => Some(v.pack(fbb).as_union_value()),
      Self::SelectOptions(v) => Some(v.pack(fbb).as_union_value()),
      Self::SliceOptions(v) => Some(v.pack(fbb).as_union_value()),
      Self::TransposeConvOptions(v) => Some(v.pack(fbb).as_union_value()),
      Self::SparseToDenseOptions(v) => Some(v.pack(fbb).as_union_value()),
      Self::TileOptions(v) => Some(v.pack(fbb).as_union_value()),
      Self::ExpandDimsOptions(v) => Some(v.pack(fbb).as_union_value()),
      Self::EqualOptions(v) => Some(v.pack(fbb).as_union_value()),
      Self::NotEqualOptions(v) => Some(v.pack(fbb).as_union_value()),
      Self::ShapeOptions(v) => Some(v.pack(fbb).as_union_value()),
      Self::PowOptions(v) => Some(v.pack(fbb).as_union_value()),
      Self::ArgMinOptions(v) => Some(v.pack(fbb).as_union_value()),
      Self::FakeQuantOptions(v) => Some(v.pack(fbb).as_union_value()),
      Self::PackOptions(v) => Some(v.pack(fbb).as_union_value()),
      Self::LogicalOrOptions(v) => Some(v.pack(fbb).as_union_value()),
      Self::OneHotOptions(v) => Some(v.pack(fbb).as_union_value()),
      Self::LogicalAndOptions(v) => Some(v.pack(fbb).as_union_value()),
      Self::LogicalNotOptions(v) => Some(v.pack(fbb).as_union_value()),
      Self::UnpackOptions(v) => Some(v.pack(fbb).as_union_value()),
      Self::FloorDivOptions(v) => Some(v.pack(fbb).as_union_value()),
      Self::SquareOptions(v) => Some(v.pack(fbb).as_union_value()),
      Self::ZerosLikeOptions(v) => Some(v.pack(fbb).as_union_value()),
      Self::FillOptions(v) => Some(v.pack(fbb).as_union_value()),
      Self::BidirectionalSequenceLSTMOptions(v) => Some(v.pack(fbb).as_union_value()),
      Self::BidirectionalSequenceRNNOptions(v) => Some(v.pack(fbb).as_union_value()),
      Self::UnidirectionalSequenceLSTMOptions(v) => Some(v.pack(fbb).as_union_value()),
      Self::FloorModOptions(v) => Some(v.pack(fbb).as_union_value()),
      Self::RangeOptions(v) => Some(v.pack(fbb).as_union_value()),
      Self::ResizeNearestNeighborOptions(v) => Some(v.pack(fbb).as_union_value()),
      Self::LeakyReluOptions(v) => Some(v.pack(fbb).as_union_value()),
      Self::SquaredDifferenceOptions(v) => Some(v.pack(fbb).as_union_value()),
      Self::MirrorPadOptions(v) => Some(v.pack(fbb).as_union_value()),
      Self::AbsOptions(v) => Some(v.pack(fbb).as_union_value()),
      Self::SplitVOptions(v) => Some(v.pack(fbb).as_union_value()),
      Self::UniqueOptions(v) => Some(v.pack(fbb).as_union_value()),
      Self::ReverseV2Options(v) => Some(v.pack(fbb).as_union_value()),
      Self::AddNOptions(v) => Some(v.pack(fbb).as_union_value()),
      Self::GatherNdOptions(v) => Some(v.pack(fbb).as_union_value()),
      Self::CosOptions(v) => Some(v.pack(fbb).as_union_value()),
      Self::WhereOptions(v) => Some(v.pack(fbb).as_union_value()),
      Self::RankOptions(v) => Some(v.pack(fbb).as_union_value()),
      Self::ReverseSequenceOptions(v) => Some(v.pack(fbb).as_union_value()),
      Self::MatrixDiagOptions(v) => Some(v.pack(fbb).as_union_value()),
      Self::QuantizeOptions(v) => Some(v.pack(fbb).as_union_value()),
      Self::MatrixSetDiagOptions(v) => Some(v.pack(fbb).as_union_value()),
      Self::HardSwishOptions(v) => Some(v.pack(fbb).as_union_value()),
      Self::IfOptions(v) => Some(v.pack(fbb).as_union_value()),
      Self::WhileOptions(v) => Some(v.pack(fbb).as_union_value()),
      Self::DepthToSpaceOptions(v) => Some(v.pack(fbb).as_union_value()),
      Self::NonMaxSuppressionV4Options(v) => Some(v.pack(fbb).as_union_value()),
      Self::NonMaxSuppressionV5Options(v) => Some(v.pack(fbb).as_union_value()),
      Self::ScatterNdOptions(v) => Some(v.pack(fbb).as_union_value()),
    }
  }
  /// If the union variant matches, return the owned Conv2DOptionsT, setting the union to NONE.
  pub fn take_conv_2_doptions(&mut self) -> Option<Box<Conv2DOptionsT>> {
    if let Self::Conv2DOptions(_) = self {
      let v = core::mem::replace(self, Self::NONE);
      if let Self::Conv2DOptions(w) = v {
        Some(w)
      } else {
        unreachable!()
      }
    } else {
      None
    }
  }
  /// If the union variant matches, return a reference to the Conv2DOptionsT.
  pub fn as_conv_2_doptions(&self) -> Option<&Conv2DOptionsT> {
    if let Self::Conv2DOptions(v) = self { Some(v.as_ref()) } else { None }
  }
  /// If the union variant matches, return a mutable reference to the Conv2DOptionsT.
  pub fn as_conv_2_doptions_mut(&mut self) -> Option<&mut Conv2DOptionsT> {
    if let Self::Conv2DOptions(v) = self { Some(v.as_mut()) } else { None }
  }
  /// If the union variant matches, return the owned DepthwiseConv2DOptionsT, setting the union to NONE.
  pub fn take_depthwise_conv_2_doptions(&mut self) -> Option<Box<DepthwiseConv2DOptionsT>> {
    if let Self::DepthwiseConv2DOptions(_) = self {
      let v = core::mem::replace(self, Self::NONE);
      if let Self::DepthwiseConv2DOptions(w) = v {
        Some(w)
      } else {
        unreachable!()
      }
    } else {
      None
    }
  }
  /// If the union variant matches, return a reference to the DepthwiseConv2DOptionsT.
  pub fn as_depthwise_conv_2_doptions(&self) -> Option<&DepthwiseConv2DOptionsT> {
    if let Self::DepthwiseConv2DOptions(v) = self { Some(v.as_ref()) } else { None }
  }
  /// If the union variant matches, return a mutable reference to the DepthwiseConv2DOptionsT.
  pub fn as_depthwise_conv_2_doptions_mut(&mut self) -> Option<&mut DepthwiseConv2DOptionsT> {
    if let Self::DepthwiseConv2DOptions(v) = self { Some(v.as_mut()) } else { None }
  }
  /// If the union variant matches, return the owned ConcatEmbeddingsOptionsT, setting the union to NONE.
  pub fn take_concat_embeddings_options(&mut self) -> Option<Box<ConcatEmbeddingsOptionsT>> {
    if let Self::ConcatEmbeddingsOptions(_) = self {
      let v = core::mem::replace(self, Self::NONE);
      if let Self::ConcatEmbeddingsOptions(w) = v {
        Some(w)
      } else {
        unreachable!()
      }
    } else {
      None
    }
  }
  /// If the union variant matches, return a reference to the ConcatEmbeddingsOptionsT.
  pub fn as_concat_embeddings_options(&self) -> Option<&ConcatEmbeddingsOptionsT> {
    if let Self::ConcatEmbeddingsOptions(v) = self { Some(v.as_ref()) } else { None }
  }
  /// If the union variant matches, return a mutable reference to the ConcatEmbeddingsOptionsT.
  pub fn as_concat_embeddings_options_mut(&mut self) -> Option<&mut ConcatEmbeddingsOptionsT> {
    if let Self::ConcatEmbeddingsOptions(v) = self { Some(v.as_mut()) } else { None }
  }
  /// If the union variant matches, return the owned LSHProjectionOptionsT, setting the union to NONE.
  pub fn take_lshprojection_options(&mut self) -> Option<Box<LSHProjectionOptionsT>> {
    if let Self::LSHProjectionOptions(_) = self {
      let v = core::mem::replace(self, Self::NONE);
      if let Self::LSHProjectionOptions(w) = v {
        Some(w)
      } else {
        unreachable!()
      }
    } else {
      None
    }
  }
  /// If the union variant matches, return a reference to the LSHProjectionOptionsT.
  pub fn as_lshprojection_options(&self) -> Option<&LSHProjectionOptionsT> {
    if let Self::LSHProjectionOptions(v) = self { Some(v.as_ref()) } else { None }
  }
  /// If the union variant matches, return a mutable reference to the LSHProjectionOptionsT.
  pub fn as_lshprojection_options_mut(&mut self) -> Option<&mut LSHProjectionOptionsT> {
    if let Self::LSHProjectionOptions(v) = self { Some(v.as_mut()) } else { None }
  }
  /// If the union variant matches, return the owned Pool2DOptionsT, setting the union to NONE.
  pub fn take_pool_2_doptions(&mut self) -> Option<Box<Pool2DOptionsT>> {
    if let Self::Pool2DOptions(_) = self {
      let v = core::mem::replace(self, Self::NONE);
      if let Self::Pool2DOptions(w) = v {
        Some(w)
      } else {
        unreachable!()
      }
    } else {
      None
    }
  }
  /// If the union variant matches, return a reference to the Pool2DOptionsT.
  pub fn as_pool_2_doptions(&self) -> Option<&Pool2DOptionsT> {
    if let Self::Pool2DOptions(v) = self { Some(v.as_ref()) } else { None }
  }
  /// If the union variant matches, return a mutable reference to the Pool2DOptionsT.
  pub fn as_pool_2_doptions_mut(&mut self) -> Option<&mut Pool2DOptionsT> {
    if let Self::Pool2DOptions(v) = self { Some(v.as_mut()) } else { None }
  }
  /// If the union variant matches, return the owned SVDFOptionsT, setting the union to NONE.
  pub fn take_svdfoptions(&mut self) -> Option<Box<SVDFOptionsT>> {
    if let Self::SVDFOptions(_) = self {
      let v = core::mem::replace(self, Self::NONE);
      if let Self::SVDFOptions(w) = v {
        Some(w)
      } else {
        unreachable!()
      }
    } else {
      None
    }
  }
  /// If the union variant matches, return a reference to the SVDFOptionsT.
  pub fn as_svdfoptions(&self) -> Option<&SVDFOptionsT> {
    if let Self::SVDFOptions(v) = self { Some(v.as_ref()) } else { None }
  }
  /// If the union variant matches, return a mutable reference to the SVDFOptionsT.
  pub fn as_svdfoptions_mut(&mut self) -> Option<&mut SVDFOptionsT> {
    if let Self::SVDFOptions(v) = self { Some(v.as_mut()) } else { None }
  }
  /// If the union variant matches, return the owned RNNOptionsT, setting the union to NONE.
  pub fn take_rnnoptions(&mut self) -> Option<Box<RNNOptionsT>> {
    if let Self::RNNOptions(_) = self {
      let v = core::mem::replace(self, Self::NONE);
      if let Self::RNNOptions(w) = v {
        Some(w)
      } else {
        unreachable!()
      }
    } else {
      None
    }
  }
  /// If the union variant matches, return a reference to the RNNOptionsT.
  pub fn as_rnnoptions(&self) -> Option<&RNNOptionsT> {
    if let Self::RNNOptions(v) = self { Some(v.as_ref()) } else { None }
  }
  /// If the union variant matches, return a mutable reference to the RNNOptionsT.
  pub fn as_rnnoptions_mut(&mut self) -> Option<&mut RNNOptionsT> {
    if let Self::RNNOptions(v) = self { Some(v.as_mut()) } else { None }
  }
  /// If the union variant matches, return the owned FullyConnectedOptionsT, setting the union to NONE.
  pub fn take_fully_connected_options(&mut self) -> Option<Box<FullyConnectedOptionsT>> {
    if let Self::FullyConnectedOptions(_) = self {
      let v = core::mem::replace(self, Self::NONE);
      if let Self::FullyConnectedOptions(w) = v {
        Some(w)
      } else {
        unreachable!()
      }
    } else {
      None
    }
  }
  /// If the union variant matches, return a reference to the FullyConnectedOptionsT.
  pub fn as_fully_connected_options(&self) -> Option<&FullyConnectedOptionsT> {
    if let Self::FullyConnectedOptions(v) = self { Some(v.as_ref()) } else { None }
  }
  /// If the union variant matches, return a mutable reference to the FullyConnectedOptionsT.
  pub fn as_fully_connected_options_mut(&mut self) -> Option<&mut FullyConnectedOptionsT> {
    if let Self::FullyConnectedOptions(v) = self { Some(v.as_mut()) } else { None }
  }
  /// If the union variant matches, return the owned SoftmaxOptionsT, setting the union to NONE.
  pub fn take_softmax_options(&mut self) -> Option<Box<SoftmaxOptionsT>> {
    if let Self::SoftmaxOptions(_) = self {
      let v = core::mem::replace(self, Self::NONE);
      if let Self::SoftmaxOptions(w) = v {
        Some(w)
      } else {
        unreachable!()
      }
    } else {
      None
    }
  }
  /// If the union variant matches, return a reference to the SoftmaxOptionsT.
  pub fn as_softmax_options(&self) -> Option<&SoftmaxOptionsT> {
    if let Self::SoftmaxOptions(v) = self { Some(v.as_ref()) } else { None }
  }
  /// If the union variant matches, return a mutable reference to the SoftmaxOptionsT.
  pub fn as_softmax_options_mut(&mut self) -> Option<&mut SoftmaxOptionsT> {
    if let Self::SoftmaxOptions(v) = self { Some(v.as_mut()) } else { None }
  }
  /// If the union variant matches, return the owned ConcatenationOptionsT, setting the union to NONE.
  pub fn take_concatenation_options(&mut self) -> Option<Box<ConcatenationOptionsT>> {
    if let Self::ConcatenationOptions(_) = self {
      let v = core::mem::replace(self, Self::NONE);
      if let Self::ConcatenationOptions(w) = v {
        Some(w)
      } else {
        unreachable!()
      }
    } else {
      None
    }
  }
  /// If the union variant matches, return a reference to the ConcatenationOptionsT.
  pub fn as_concatenation_options(&self) -> Option<&ConcatenationOptionsT> {
    if let Self::ConcatenationOptions(v) = self { Some(v.as_ref()) } else { None }
  }
  /// If the union variant matches, return a mutable reference to the ConcatenationOptionsT.
  pub fn as_concatenation_options_mut(&mut self) -> Option<&mut ConcatenationOptionsT> {
    if let Self::ConcatenationOptions(v) = self { Some(v.as_mut()) } else { None }
  }
  /// If the union variant matches, return the owned AddOptionsT, setting the union to NONE.
  pub fn take_add_options(&mut self) -> Option<Box<AddOptionsT>> {
    if let Self::AddOptions(_) = self {
      let v = core::mem::replace(self, Self::NONE);
      if let Self::AddOptions(w) = v {
        Some(w)
      } else {
        unreachable!()
      }
    } else {
      None
    }
  }
  /// If the union variant matches, return a reference to the AddOptionsT.
  pub fn as_add_options(&self) -> Option<&AddOptionsT> {
    if let Self::AddOptions(v) = self { Some(v.as_ref()) } else { None }
  }
  /// If the union variant matches, return a mutable reference to the AddOptionsT.
  pub fn as_add_options_mut(&mut self) -> Option<&mut AddOptionsT> {
    if let Self::AddOptions(v) = self { Some(v.as_mut()) } else { None }
  }
  /// If the union variant matches, return the owned L2NormOptionsT, setting the union to NONE.
  pub fn take_l2_norm_options(&mut self) -> Option<Box<L2NormOptionsT>> {
    if let Self::L2NormOptions(_) = self {
      let v = core::mem::replace(self, Self::NONE);
      if let Self::L2NormOptions(w) = v {
        Some(w)
      } else {
        unreachable!()
      }
    } else {
      None
    }
  }
  /// If the union variant matches, return a reference to the L2NormOptionsT.
  pub fn as_l2_norm_options(&self) -> Option<&L2NormOptionsT> {
    if let Self::L2NormOptions(v) = self { Some(v.as_ref()) } else { None }
  }
  /// If the union variant matches, return a mutable reference to the L2NormOptionsT.
  pub fn as_l2_norm_options_mut(&mut self) -> Option<&mut L2NormOptionsT> {
    if let Self::L2NormOptions(v) = self { Some(v.as_mut()) } else { None }
  }
  /// If the union variant matches, return the owned LocalResponseNormalizationOptionsT, setting the union to NONE.
  pub fn take_local_response_normalization_options(&mut self) -> Option<Box<LocalResponseNormalizationOptionsT>> {
    if let Self::LocalResponseNormalizationOptions(_) = self {
      let v = core::mem::replace(self, Self::NONE);
      if let Self::LocalResponseNormalizationOptions(w) = v {
        Some(w)
      } else {
        unreachable!()
      }
    } else {
      None
    }
  }
  /// If the union variant matches, return a reference to the LocalResponseNormalizationOptionsT.
  pub fn as_local_response_normalization_options(&self) -> Option<&LocalResponseNormalizationOptionsT> {
    if let Self::LocalResponseNormalizationOptions(v) = self { Some(v.as_ref()) } else { None }
  }
  /// If the union variant matches, return a mutable reference to the LocalResponseNormalizationOptionsT.
  pub fn as_local_response_normalization_options_mut(&mut self) -> Option<&mut LocalResponseNormalizationOptionsT> {
    if let Self::LocalResponseNormalizationOptions(v) = self { Some(v.as_mut()) } else { None }
  }
  /// If the union variant matches, return the owned LSTMOptionsT, setting the union to NONE.
  pub fn take_lstmoptions(&mut self) -> Option<Box<LSTMOptionsT>> {
    if let Self::LSTMOptions(_) = self {
      let v = core::mem::replace(self, Self::NONE);
      if let Self::LSTMOptions(w) = v {
        Some(w)
      } else {
        unreachable!()
      }
    } else {
      None
    }
  }
  /// If the union variant matches, return a reference to the LSTMOptionsT.
  pub fn as_lstmoptions(&self) -> Option<&LSTMOptionsT> {
    if let Self::LSTMOptions(v) = self { Some(v.as_ref()) } else { None }
  }
  /// If the union variant matches, return a mutable reference to the LSTMOptionsT.
  pub fn as_lstmoptions_mut(&mut self) -> Option<&mut LSTMOptionsT> {
    if let Self::LSTMOptions(v) = self { Some(v.as_mut()) } else { None }
  }
  /// If the union variant matches, return the owned ResizeBilinearOptionsT, setting the union to NONE.
  pub fn take_resize_bilinear_options(&mut self) -> Option<Box<ResizeBilinearOptionsT>> {
    if let Self::ResizeBilinearOptions(_) = self {
      let v = core::mem::replace(self, Self::NONE);
      if let Self::ResizeBilinearOptions(w) = v {
        Some(w)
      } else {
        unreachable!()
      }
    } else {
      None
    }
  }
  /// If the union variant matches, return a reference to the ResizeBilinearOptionsT.
  pub fn as_resize_bilinear_options(&self) -> Option<&ResizeBilinearOptionsT> {
    if let Self::ResizeBilinearOptions(v) = self { Some(v.as_ref()) } else { None }
  }
  /// If the union variant matches, return a mutable reference to the ResizeBilinearOptionsT.
  pub fn as_resize_bilinear_options_mut(&mut self) -> Option<&mut ResizeBilinearOptionsT> {
    if let Self::ResizeBilinearOptions(v) = self { Some(v.as_mut()) } else { None }
  }
  /// If the union variant matches, return the owned CallOptionsT, setting the union to NONE.
  pub fn take_call_options(&mut self) -> Option<Box<CallOptionsT>> {
    if let Self::CallOptions(_) = self {
      let v = core::mem::replace(self, Self::NONE);
      if let Self::CallOptions(w) = v {
        Some(w)
      } else {
        unreachable!()
      }
    } else {
      None
    }
  }
  /// If the union variant matches, return a reference to the CallOptionsT.
  pub fn as_call_options(&self) -> Option<&CallOptionsT> {
    if let Self::CallOptions(v) = self { Some(v.as_ref()) } else { None }
  }
  /// If the union variant matches, return a mutable reference to the CallOptionsT.
  pub fn as_call_options_mut(&mut self) -> Option<&mut CallOptionsT> {
    if let Self::CallOptions(v) = self { Some(v.as_mut()) } else { None }
  }
  /// If the union variant matches, return the owned ReshapeOptionsT, setting the union to NONE.
  pub fn take_reshape_options(&mut self) -> Option<Box<ReshapeOptionsT>> {
    if let Self::ReshapeOptions(_) = self {
      let v = core::mem::replace(self, Self::NONE);
      if let Self::ReshapeOptions(w) = v {
        Some(w)
      } else {
        unreachable!()
      }
    } else {
      None
    }
  }
  /// If the union variant matches, return a reference to the ReshapeOptionsT.
  pub fn as_reshape_options(&self) -> Option<&ReshapeOptionsT> {
    if let Self::ReshapeOptions(v) = self { Some(v.as_ref()) } else { None }
  }
  /// If the union variant matches, return a mutable reference to the ReshapeOptionsT.
  pub fn as_reshape_options_mut(&mut self) -> Option<&mut ReshapeOptionsT> {
    if let Self::ReshapeOptions(v) = self { Some(v.as_mut()) } else { None }
  }
  /// If the union variant matches, return the owned SkipGramOptionsT, setting the union to NONE.
  pub fn take_skip_gram_options(&mut self) -> Option<Box<SkipGramOptionsT>> {
    if let Self::SkipGramOptions(_) = self {
      let v = core::mem::replace(self, Self::NONE);
      if let Self::SkipGramOptions(w) = v {
        Some(w)
      } else {
        unreachable!()
      }
    } else {
      None
    }
  }
  /// If the union variant matches, return a reference to the SkipGramOptionsT.
  pub fn as_skip_gram_options(&self) -> Option<&SkipGramOptionsT> {
    if let Self::SkipGramOptions(v) = self { Some(v.as_ref()) } else { None }
  }
  /// If the union variant matches, return a mutable reference to the SkipGramOptionsT.
  pub fn as_skip_gram_options_mut(&mut self) -> Option<&mut SkipGramOptionsT> {
    if let Self::SkipGramOptions(v) = self { Some(v.as_mut()) } else { None }
  }
  /// If the union variant matches, return the owned SpaceToDepthOptionsT, setting the union to NONE.
  pub fn take_space_to_depth_options(&mut self) -> Option<Box<SpaceToDepthOptionsT>> {
    if let Self::SpaceToDepthOptions(_) = self {
      let v = core::mem::replace(self, Self::NONE);
      if let Self::SpaceToDepthOptions(w) = v {
        Some(w)
      } else {
        unreachable!()
      }
    } else {
      None
    }
  }
  /// If the union variant matches, return a reference to the SpaceToDepthOptionsT.
  pub fn as_space_to_depth_options(&self) -> Option<&SpaceToDepthOptionsT> {
    if let Self::SpaceToDepthOptions(v) = self { Some(v.as_ref()) } else { None }
  }
  /// If the union variant matches, return a mutable reference to the SpaceToDepthOptionsT.
  pub fn as_space_to_depth_options_mut(&mut self) -> Option<&mut SpaceToDepthOptionsT> {
    if let Self::SpaceToDepthOptions(v) = self { Some(v.as_mut()) } else { None }
  }
  /// If the union variant matches, return the owned EmbeddingLookupSparseOptionsT, setting the union to NONE.
  pub fn take_embedding_lookup_sparse_options(&mut self) -> Option<Box<EmbeddingLookupSparseOptionsT>> {
    if let Self::EmbeddingLookupSparseOptions(_) = self {
      let v = core::mem::replace(self, Self::NONE);
      if let Self::EmbeddingLookupSparseOptions(w) = v {
        Some(w)
      } else {
        unreachable!()
      }
    } else {
      None
    }
  }
  /// If the union variant matches, return a reference to the EmbeddingLookupSparseOptionsT.
  pub fn as_embedding_lookup_sparse_options(&self) -> Option<&EmbeddingLookupSparseOptionsT> {
    if let Self::EmbeddingLookupSparseOptions(v) = self { Some(v.as_ref()) } else { None }
  }
  /// If the union variant matches, return a mutable reference to the EmbeddingLookupSparseOptionsT.
  pub fn as_embedding_lookup_sparse_options_mut(&mut self) -> Option<&mut EmbeddingLookupSparseOptionsT> {
    if let Self::EmbeddingLookupSparseOptions(v) = self { Some(v.as_mut()) } else { None }
  }
  /// If the union variant matches, return the owned MulOptionsT, setting the union to NONE.
  pub fn take_mul_options(&mut self) -> Option<Box<MulOptionsT>> {
    if let Self::MulOptions(_) = self {
      let v = core::mem::replace(self, Self::NONE);
      if let Self::MulOptions(w) = v {
        Some(w)
      } else {
        unreachable!()
      }
    } else {
      None
    }
  }
  /// If the union variant matches, return a reference to the MulOptionsT.
  pub fn as_mul_options(&self) -> Option<&MulOptionsT> {
    if let Self::MulOptions(v) = self { Some(v.as_ref()) } else { None }
  }
  /// If the union variant matches, return a mutable reference to the MulOptionsT.
  pub fn as_mul_options_mut(&mut self) -> Option<&mut MulOptionsT> {
    if let Self::MulOptions(v) = self { Some(v.as_mut()) } else { None }
  }
  /// If the union variant matches, return the owned PadOptionsT, setting the union to NONE.
  pub fn take_pad_options(&mut self) -> Option<Box<PadOptionsT>> {
    if let Self::PadOptions(_) = self {
      let v = core::mem::replace(self, Self::NONE);
      if let Self::PadOptions(w) = v {
        Some(w)
      } else {
        unreachable!()
      }
    } else {
      None
    }
  }
  /// If the union variant matches, return a reference to the PadOptionsT.
  pub fn as_pad_options(&self) -> Option<&PadOptionsT> {
    if let Self::PadOptions(v) = self { Some(v.as_ref()) } else { None }
  }
  /// If the union variant matches, return a mutable reference to the PadOptionsT.
  pub fn as_pad_options_mut(&mut self) -> Option<&mut PadOptionsT> {
    if let Self::PadOptions(v) = self { Some(v.as_mut()) } else { None }
  }
  /// If the union variant matches, return the owned GatherOptionsT, setting the union to NONE.
  pub fn take_gather_options(&mut self) -> Option<Box<GatherOptionsT>> {
    if let Self::GatherOptions(_) = self {
      let v = core::mem::replace(self, Self::NONE);
      if let Self::GatherOptions(w) = v {
        Some(w)
      } else {
        unreachable!()
      }
    } else {
      None
    }
  }
  /// If the union variant matches, return a reference to the GatherOptionsT.
  pub fn as_gather_options(&self) -> Option<&GatherOptionsT> {
    if let Self::GatherOptions(v) = self { Some(v.as_ref()) } else { None }
  }
  /// If the union variant matches, return a mutable reference to the GatherOptionsT.
  pub fn as_gather_options_mut(&mut self) -> Option<&mut GatherOptionsT> {
    if let Self::GatherOptions(v) = self { Some(v.as_mut()) } else { None }
  }
  /// If the union variant matches, return the owned BatchToSpaceNDOptionsT, setting the union to NONE.
  pub fn take_batch_to_space_ndoptions(&mut self) -> Option<Box<BatchToSpaceNDOptionsT>> {
    if let Self::BatchToSpaceNDOptions(_) = self {
      let v = core::mem::replace(self, Self::NONE);
      if let Self::BatchToSpaceNDOptions(w) = v {
        Some(w)
      } else {
        unreachable!()
      }
    } else {
      None
    }
  }
  /// If the union variant matches, return a reference to the BatchToSpaceNDOptionsT.
  pub fn as_batch_to_space_ndoptions(&self) -> Option<&BatchToSpaceNDOptionsT> {
    if let Self::BatchToSpaceNDOptions(v) = self { Some(v.as_ref()) } else { None }
  }
  /// If the union variant matches, return a mutable reference to the BatchToSpaceNDOptionsT.
  pub fn as_batch_to_space_ndoptions_mut(&mut self) -> Option<&mut BatchToSpaceNDOptionsT> {
    if let Self::BatchToSpaceNDOptions(v) = self { Some(v.as_mut()) } else { None }
  }
  /// If the union variant matches, return the owned SpaceToBatchNDOptionsT, setting the union to NONE.
  pub fn take_space_to_batch_ndoptions(&mut self) -> Option<Box<SpaceToBatchNDOptionsT>> {
    if let Self::SpaceToBatchNDOptions(_) = self {
      let v = core::mem::replace(self, Self::NONE);
      if let Self::SpaceToBatchNDOptions(w) = v {
        Some(w)
      } else {
        unreachable!()
      }
    } else {
      None
    }
  }
  /// If the union variant matches, return a reference to the SpaceToBatchNDOptionsT.
  pub fn as_space_to_batch_ndoptions(&self) -> Option<&SpaceToBatchNDOptionsT> {
    if let Self::SpaceToBatchNDOptions(v) = self { Some(v.as_ref()) } else { None }
  }
  /// If the union variant matches, return a mutable reference to the SpaceToBatchNDOptionsT.
  pub fn as_space_to_batch_ndoptions_mut(&mut self) -> Option<&mut SpaceToBatchNDOptionsT> {
    if let Self::SpaceToBatchNDOptions(v) = self { Some(v.as_mut()) } else { None }
  }
  /// If the union variant matches, return the owned TransposeOptionsT, setting the union to NONE.
  pub fn take_transpose_options(&mut self) -> Option<Box<TransposeOptionsT>> {
    if let Self::TransposeOptions(_) = self {
      let v = core::mem::replace(self, Self::NONE);
      if let Self::TransposeOptions(w) = v {
        Some(w)
      } else {
        unreachable!()
      }
    } else {
      None
    }
  }
  /// If the union variant matches, return a reference to the TransposeOptionsT.
  pub fn as_transpose_options(&self) -> Option<&TransposeOptionsT> {
    if let Self::TransposeOptions(v) = self { Some(v.as_ref()) } else { None }
  }
  /// If the union variant matches, return a mutable reference to the TransposeOptionsT.
  pub fn as_transpose_options_mut(&mut self) -> Option<&mut TransposeOptionsT> {
    if let Self::TransposeOptions(v) = self { Some(v.as_mut()) } else { None }
  }
  /// If the union variant matches, return the owned ReducerOptionsT, setting the union to NONE.
  pub fn take_reducer_options(&mut self) -> Option<Box<ReducerOptionsT>> {
    if let Self::ReducerOptions(_) = self {
      let v = core::mem::replace(self, Self::NONE);
      if let Self::ReducerOptions(w) = v {
        Some(w)
      } else {
        unreachable!()
      }
    } else {
      None
    }
  }
  /// If the union variant matches, return a reference to the ReducerOptionsT.
  pub fn as_reducer_options(&self) -> Option<&ReducerOptionsT> {
    if let Self::ReducerOptions(v) = self { Some(v.as_ref()) } else { None }
  }
  /// If the union variant matches, return a mutable reference to the ReducerOptionsT.
  pub fn as_reducer_options_mut(&mut self) -> Option<&mut ReducerOptionsT> {
    if let Self::ReducerOptions(v) = self { Some(v.as_mut()) } else { None }
  }
  /// If the union variant matches, return the owned SubOptionsT, setting the union to NONE.
  pub fn take_sub_options(&mut self) -> Option<Box<SubOptionsT>> {
    if let Self::SubOptions(_) = self {
      let v = core::mem::replace(self, Self::NONE);
      if let Self::SubOptions(w) = v {
        Some(w)
      } else {
        unreachable!()
      }
    } else {
      None
    }
  }
  /// If the union variant matches, return a reference to the SubOptionsT.
  pub fn as_sub_options(&self) -> Option<&SubOptionsT> {
    if let Self::SubOptions(v) = self { Some(v.as_ref()) } else { None }
  }
  /// If the union variant matches, return a mutable reference to the SubOptionsT.
  pub fn as_sub_options_mut(&mut self) -> Option<&mut SubOptionsT> {
    if let Self::SubOptions(v) = self { Some(v.as_mut()) } else { None }
  }
  /// If the union variant matches, return the owned DivOptionsT, setting the union to NONE.
  pub fn take_div_options(&mut self) -> Option<Box<DivOptionsT>> {
    if let Self::DivOptions(_) = self {
      let v = core::mem::replace(self, Self::NONE);
      if let Self::DivOptions(w) = v {
        Some(w)
      } else {
        unreachable!()
      }
    } else {
      None
    }
  }
  /// If the union variant matches, return a reference to the DivOptionsT.
  pub fn as_div_options(&self) -> Option<&DivOptionsT> {
    if let Self::DivOptions(v) = self { Some(v.as_ref()) } else { None }
  }
  /// If the union variant matches, return a mutable reference to the DivOptionsT.
  pub fn as_div_options_mut(&mut self) -> Option<&mut DivOptionsT> {
    if let Self::DivOptions(v) = self { Some(v.as_mut()) } else { None }
  }
  /// If the union variant matches, return the owned SqueezeOptionsT, setting the union to NONE.
  pub fn take_squeeze_options(&mut self) -> Option<Box<SqueezeOptionsT>> {
    if let Self::SqueezeOptions(_) = self {
      let v = core::mem::replace(self, Self::NONE);
      if let Self::SqueezeOptions(w) = v {
        Some(w)
      } else {
        unreachable!()
      }
    } else {
      None
    }
  }
  /// If the union variant matches, return a reference to the SqueezeOptionsT.
  pub fn as_squeeze_options(&self) -> Option<&SqueezeOptionsT> {
    if let Self::SqueezeOptions(v) = self { Some(v.as_ref()) } else { None }
  }
  /// If the union variant matches, return a mutable reference to the SqueezeOptionsT.
  pub fn as_squeeze_options_mut(&mut self) -> Option<&mut SqueezeOptionsT> {
    if let Self::SqueezeOptions(v) = self { Some(v.as_mut()) } else { None }
  }
  /// If the union variant matches, return the owned SequenceRNNOptionsT, setting the union to NONE.
  pub fn take_sequence_rnnoptions(&mut self) -> Option<Box<SequenceRNNOptionsT>> {
    if let Self::SequenceRNNOptions(_) = self {
      let v = core::mem::replace(self, Self::NONE);
      if let Self::SequenceRNNOptions(w) = v {
        Some(w)
      } else {
        unreachable!()
      }
    } else {
      None
    }
  }
  /// If the union variant matches, return a reference to the SequenceRNNOptionsT.
  pub fn as_sequence_rnnoptions(&self) -> Option<&SequenceRNNOptionsT> {
    if let Self::SequenceRNNOptions(v) = self { Some(v.as_ref()) } else { None }
  }
  /// If the union variant matches, return a mutable reference to the SequenceRNNOptionsT.
  pub fn as_sequence_rnnoptions_mut(&mut self) -> Option<&mut SequenceRNNOptionsT> {
    if let Self::SequenceRNNOptions(v) = self { Some(v.as_mut()) } else { None }
  }
  /// If the union variant matches, return the owned StridedSliceOptionsT, setting the union to NONE.
  pub fn take_strided_slice_options(&mut self) -> Option<Box<StridedSliceOptionsT>> {
    if let Self::StridedSliceOptions(_) = self {
      let v = core::mem::replace(self, Self::NONE);
      if let Self::StridedSliceOptions(w) = v {
        Some(w)
      } else {
        unreachable!()
      }
    } else {
      None
    }
  }
  /// If the union variant matches, return a reference to the StridedSliceOptionsT.
  pub fn as_strided_slice_options(&self) -> Option<&StridedSliceOptionsT> {
    if let Self::StridedSliceOptions(v) = self { Some(v.as_ref()) } else { None }
  }
  /// If the union variant matches, return a mutable reference to the StridedSliceOptionsT.
  pub fn as_strided_slice_options_mut(&mut self) -> Option<&mut StridedSliceOptionsT> {
    if let Self::StridedSliceOptions(v) = self { Some(v.as_mut()) } else { None }
  }
  /// If the union variant matches, return the owned ExpOptionsT, setting the union to NONE.
  pub fn take_exp_options(&mut self) -> Option<Box<ExpOptionsT>> {
    if let Self::ExpOptions(_) = self {
      let v = core::mem::replace(self, Self::NONE);
      if let Self::ExpOptions(w) = v {
        Some(w)
      } else {
        unreachable!()
      }
    } else {
      None
    }
  }
  /// If the union variant matches, return a reference to the ExpOptionsT.
  pub fn as_exp_options(&self) -> Option<&ExpOptionsT> {
    if let Self::ExpOptions(v) = self { Some(v.as_ref()) } else { None }
  }
  /// If the union variant matches, return a mutable reference to the ExpOptionsT.
  pub fn as_exp_options_mut(&mut self) -> Option<&mut ExpOptionsT> {
    if let Self::ExpOptions(v) = self { Some(v.as_mut()) } else { None }
  }
  /// If the union variant matches, return the owned TopKV2OptionsT, setting the union to NONE.
  pub fn take_top_kv2_options(&mut self) -> Option<Box<TopKV2OptionsT>> {
    if let Self::TopKV2Options(_) = self {
      let v = core::mem::replace(self, Self::NONE);
      if let Self::TopKV2Options(w) = v {
        Some(w)
      } else {
        unreachable!()
      }
    } else {
      None
    }
  }
  /// If the union variant matches, return a reference to the TopKV2OptionsT.
  pub fn as_top_kv2_options(&self) -> Option<&TopKV2OptionsT> {
    if let Self::TopKV2Options(v) = self { Some(v.as_ref()) } else { None }
  }
  /// If the union variant matches, return a mutable reference to the TopKV2OptionsT.
  pub fn as_top_kv2_options_mut(&mut self) -> Option<&mut TopKV2OptionsT> {
    if let Self::TopKV2Options(v) = self { Some(v.as_mut()) } else { None }
  }
  /// If the union variant matches, return the owned SplitOptionsT, setting the union to NONE.
  pub fn take_split_options(&mut self) -> Option<Box<SplitOptionsT>> {
    if let Self::SplitOptions(_) = self {
      let v = core::mem::replace(self, Self::NONE);
      if let Self::SplitOptions(w) = v {
        Some(w)
      } else {
        unreachable!()
      }
    } else {
      None
    }
  }
  /// If the union variant matches, return a reference to the SplitOptionsT.
  pub fn as_split_options(&self) -> Option<&SplitOptionsT> {
    if let Self::SplitOptions(v) = self { Some(v.as_ref()) } else { None }
  }
  /// If the union variant matches, return a mutable reference to the SplitOptionsT.
  pub fn as_split_options_mut(&mut self) -> Option<&mut SplitOptionsT> {
    if let Self::SplitOptions(v) = self { Some(v.as_mut()) } else { None }
  }
  /// If the union variant matches, return the owned LogSoftmaxOptionsT, setting the union to NONE.
  pub fn take_log_softmax_options(&mut self) -> Option<Box<LogSoftmaxOptionsT>> {
    if let Self::LogSoftmaxOptions(_) = self {
      let v = core::mem::replace(self, Self::NONE);
      if let Self::LogSoftmaxOptions(w) = v {
        Some(w)
      } else {
        unreachable!()
      }
    } else {
      None
    }
  }
  /// If the union variant matches, return a reference to the LogSoftmaxOptionsT.
  pub fn as_log_softmax_options(&self) -> Option<&LogSoftmaxOptionsT> {
    if let Self::LogSoftmaxOptions(v) = self { Some(v.as_ref()) } else { None }
  }
  /// If the union variant matches, return a mutable reference to the LogSoftmaxOptionsT.
  pub fn as_log_softmax_options_mut(&mut self) -> Option<&mut LogSoftmaxOptionsT> {
    if let Self::LogSoftmaxOptions(v) = self { Some(v.as_mut()) } else { None }
  }
  /// If the union variant matches, return the owned CastOptionsT, setting the union to NONE.
  pub fn take_cast_options(&mut self) -> Option<Box<CastOptionsT>> {
    if let Self::CastOptions(_) = self {
      let v = core::mem::replace(self, Self::NONE);
      if let Self::CastOptions(w) = v {
        Some(w)
      } else {
        unreachable!()
      }
    } else {
      None
    }
  }
  /// If the union variant matches, return a reference to the CastOptionsT.
  pub fn as_cast_options(&self) -> Option<&CastOptionsT> {
    if let Self::CastOptions(v) = self { Some(v.as_ref()) } else { None }
  }
  /// If the union variant matches, return a mutable reference to the CastOptionsT.
  pub fn as_cast_options_mut(&mut self) -> Option<&mut CastOptionsT> {
    if let Self::CastOptions(v) = self { Some(v.as_mut()) } else { None }
  }
  /// If the union variant matches, return the owned DequantizeOptionsT, setting the union to NONE.
  pub fn take_dequantize_options(&mut self) -> Option<Box<DequantizeOptionsT>> {
    if let Self::DequantizeOptions(_) = self {
      let v = core::mem::replace(self, Self::NONE);
      if let Self::DequantizeOptions(w) = v {
        Some(w)
      } else {
        unreachable!()
      }
    } else {
      None
    }
  }
  /// If the union variant matches, return a reference to the DequantizeOptionsT.
  pub fn as_dequantize_options(&self) -> Option<&DequantizeOptionsT> {
    if let Self::DequantizeOptions(v) = self { Some(v.as_ref()) } else { None }
  }
  /// If the union variant matches, return a mutable reference to the DequantizeOptionsT.
  pub fn as_dequantize_options_mut(&mut self) -> Option<&mut DequantizeOptionsT> {
    if let Self::DequantizeOptions(v) = self { Some(v.as_mut()) } else { None }
  }
  /// If the union variant matches, return the owned MaximumMinimumOptionsT, setting the union to NONE.
  pub fn take_maximum_minimum_options(&mut self) -> Option<Box<MaximumMinimumOptionsT>> {
    if let Self::MaximumMinimumOptions(_) = self {
      let v = core::mem::replace(self, Self::NONE);
      if let Self::MaximumMinimumOptions(w) = v {
        Some(w)
      } else {
        unreachable!()
      }
    } else {
      None
    }
  }
  /// If the union variant matches, return a reference to the MaximumMinimumOptionsT.
  pub fn as_maximum_minimum_options(&self) -> Option<&MaximumMinimumOptionsT> {
    if let Self::MaximumMinimumOptions(v) = self { Some(v.as_ref()) } else { None }
  }
  /// If the union variant matches, return a mutable reference to the MaximumMinimumOptionsT.
  pub fn as_maximum_minimum_options_mut(&mut self) -> Option<&mut MaximumMinimumOptionsT> {
    if let Self::MaximumMinimumOptions(v) = self { Some(v.as_mut()) } else { None }
  }
  /// If the union variant matches, return the owned ArgMaxOptionsT, setting the union to NONE.
  pub fn take_arg_max_options(&mut self) -> Option<Box<ArgMaxOptionsT>> {
    if let Self::ArgMaxOptions(_) = self {
      let v = core::mem::replace(self, Self::NONE);
      if let Self::ArgMaxOptions(w) = v {
        Some(w)
      } else {
        unreachable!()
      }
    } else {
      None
    }
  }
  /// If the union variant matches, return a reference to the ArgMaxOptionsT.
  pub fn as_arg_max_options(&self) -> Option<&ArgMaxOptionsT> {
    if let Self::ArgMaxOptions(v) = self { Some(v.as_ref()) } else { None }
  }
  /// If the union variant matches, return a mutable reference to the ArgMaxOptionsT.
  pub fn as_arg_max_options_mut(&mut self) -> Option<&mut ArgMaxOptionsT> {
    if let Self::ArgMaxOptions(v) = self { Some(v.as_mut()) } else { None }
  }
  /// If the union variant matches, return the owned LessOptionsT, setting the union to NONE.
  pub fn take_less_options(&mut self) -> Option<Box<LessOptionsT>> {
    if let Self::LessOptions(_) = self {
      let v = core::mem::replace(self, Self::NONE);
      if let Self::LessOptions(w) = v {
        Some(w)
      } else {
        unreachable!()
      }
    } else {
      None
    }
  }
  /// If the union variant matches, return a reference to the LessOptionsT.
  pub fn as_less_options(&self) -> Option<&LessOptionsT> {
    if let Self::LessOptions(v) = self { Some(v.as_ref()) } else { None }
  }
  /// If the union variant matches, return a mutable reference to the LessOptionsT.
  pub fn as_less_options_mut(&mut self) -> Option<&mut LessOptionsT> {
    if let Self::LessOptions(v) = self { Some(v.as_mut()) } else { None }
  }
  /// If the union variant matches, return the owned NegOptionsT, setting the union to NONE.
  pub fn take_neg_options(&mut self) -> Option<Box<NegOptionsT>> {
    if let Self::NegOptions(_) = self {
      let v = core::mem::replace(self, Self::NONE);
      if let Self::NegOptions(w) = v {
        Some(w)
      } else {
        unreachable!()
      }
    } else {
      None
    }
  }
  /// If the union variant matches, return a reference to the NegOptionsT.
  pub fn as_neg_options(&self) -> Option<&NegOptionsT> {
    if let Self::NegOptions(v) = self { Some(v.as_ref()) } else { None }
  }
  /// If the union variant matches, return a mutable reference to the NegOptionsT.
  pub fn as_neg_options_mut(&mut self) -> Option<&mut NegOptionsT> {
    if let Self::NegOptions(v) = self { Some(v.as_mut()) } else { None }
  }
  /// If the union variant matches, return the owned PadV2OptionsT, setting the union to NONE.
  pub fn take_pad_v2_options(&mut self) -> Option<Box<PadV2OptionsT>> {
    if let Self::PadV2Options(_) = self {
      let v = core::mem::replace(self, Self::NONE);
      if let Self::PadV2Options(w) = v {
        Some(w)
      } else {
        unreachable!()
      }
    } else {
      None
    }
  }
  /// If the union variant matches, return a reference to the PadV2OptionsT.
  pub fn as_pad_v2_options(&self) -> Option<&PadV2OptionsT> {
    if let Self::PadV2Options(v) = self { Some(v.as_ref()) } else { None }
  }
  /// If the union variant matches, return a mutable reference to the PadV2OptionsT.
  pub fn as_pad_v2_options_mut(&mut self) -> Option<&mut PadV2OptionsT> {
    if let Self::PadV2Options(v) = self { Some(v.as_mut()) } else { None }
  }
  /// If the union variant matches, return the owned GreaterOptionsT, setting the union to NONE.
  pub fn take_greater_options(&mut self) -> Option<Box<GreaterOptionsT>> {
    if let Self::GreaterOptions(_) = self {
      let v = core::mem::replace(self, Self::NONE);
      if let Self::GreaterOptions(w) = v {
        Some(w)
      } else {
        unreachable!()
      }
    } else {
      None
    }
  }
  /// If the union variant matches, return a reference to the GreaterOptionsT.
  pub fn as_greater_options(&self) -> Option<&GreaterOptionsT> {
    if let Self::GreaterOptions(v) = self { Some(v.as_ref()) } else { None }
  }
  /// If the union variant matches, return a mutable reference to the GreaterOptionsT.
  pub fn as_greater_options_mut(&mut self) -> Option<&mut GreaterOptionsT> {
    if let Self::GreaterOptions(v) = self { Some(v.as_mut()) } else { None }
  }
  /// If the union variant matches, return the owned GreaterEqualOptionsT, setting the union to NONE.
  pub fn take_greater_equal_options(&mut self) -> Option<Box<GreaterEqualOptionsT>> {
    if let Self::GreaterEqualOptions(_) = self {
      let v = core::mem::replace(self, Self::NONE);
      if let Self::GreaterEqualOptions(w) = v {
        Some(w)
      } else {
        unreachable!()
      }
    } else {
      None
    }
  }
  /// If the union variant matches, return a reference to the GreaterEqualOptionsT.
  pub fn as_greater_equal_options(&self) -> Option<&GreaterEqualOptionsT> {
    if let Self::GreaterEqualOptions(v) = self { Some(v.as_ref()) } else { None }
  }
  /// If the union variant matches, return a mutable reference to the GreaterEqualOptionsT.
  pub fn as_greater_equal_options_mut(&mut self) -> Option<&mut GreaterEqualOptionsT> {
    if let Self::GreaterEqualOptions(v) = self { Some(v.as_mut()) } else { None }
  }
  /// If the union variant matches, return the owned LessEqualOptionsT, setting the union to NONE.
  pub fn take_less_equal_options(&mut self) -> Option<Box<LessEqualOptionsT>> {
    if let Self::LessEqualOptions(_) = self {
      let v = core::mem::replace(self, Self::NONE);
      if let Self::LessEqualOptions(w) = v {
        Some(w)
      } else {
        unreachable!()
      }
    } else {
      None
    }
  }
  /// If the union variant matches, return a reference to the LessEqualOptionsT.
  pub fn as_less_equal_options(&self) -> Option<&LessEqualOptionsT> {
    if let Self::LessEqualOptions(v) = self { Some(v.as_ref()) } else { None }
  }
  /// If the union variant matches, return a mutable reference to the LessEqualOptionsT.
  pub fn as_less_equal_options_mut(&mut self) -> Option<&mut LessEqualOptionsT> {
    if let Self::LessEqualOptions(v) = self { Some(v.as_mut()) } else { None }
  }
  /// If the union variant matches, return the owned SelectOptionsT, setting the union to NONE.
  pub fn take_select_options(&mut self) -> Option<Box<SelectOptionsT>> {
    if let Self::SelectOptions(_) = self {
      let v = core::mem::replace(self, Self::NONE);
      if let Self::SelectOptions(w) = v {
        Some(w)
      } else {
        unreachable!()
      }
    } else {
      None
    }
  }
  /// If the union variant matches, return a reference to the SelectOptionsT.
  pub fn as_select_options(&self) -> Option<&SelectOptionsT> {
    if let Self::SelectOptions(v) = self { Some(v.as_ref()) } else { None }
  }
  /// If the union variant matches, return a mutable reference to the SelectOptionsT.
  pub fn as_select_options_mut(&mut self) -> Option<&mut SelectOptionsT> {
    if let Self::SelectOptions(v) = self { Some(v.as_mut()) } else { None }
  }
  /// If the union variant matches, return the owned SliceOptionsT, setting the union to NONE.
  pub fn take_slice_options(&mut self) -> Option<Box<SliceOptionsT>> {
    if let Self::SliceOptions(_) = self {
      let v = core::mem::replace(self, Self::NONE);
      if let Self::SliceOptions(w) = v {
        Some(w)
      } else {
        unreachable!()
      }
    } else {
      None
    }
  }
  /// If the union variant matches, return a reference to the SliceOptionsT.
  pub fn as_slice_options(&self) -> Option<&SliceOptionsT> {
    if let Self::SliceOptions(v) = self { Some(v.as_ref()) } else { None }
  }
  /// If the union variant matches, return a mutable reference to the SliceOptionsT.
  pub fn as_slice_options_mut(&mut self) -> Option<&mut SliceOptionsT> {
    if let Self::SliceOptions(v) = self { Some(v.as_mut()) } else { None }
  }
  /// If the union variant matches, return the owned TransposeConvOptionsT, setting the union to NONE.
  pub fn take_transpose_conv_options(&mut self) -> Option<Box<TransposeConvOptionsT>> {
    if let Self::TransposeConvOptions(_) = self {
      let v = core::mem::replace(self, Self::NONE);
      if let Self::TransposeConvOptions(w) = v {
        Some(w)
      } else {
        unreachable!()
      }
    } else {
      None
    }
  }
  /// If the union variant matches, return a reference to the TransposeConvOptionsT.
  pub fn as_transpose_conv_options(&self) -> Option<&TransposeConvOptionsT> {
    if let Self::TransposeConvOptions(v) = self { Some(v.as_ref()) } else { None }
  }
  /// If the union variant matches, return a mutable reference to the TransposeConvOptionsT.
  pub fn as_transpose_conv_options_mut(&mut self) -> Option<&mut TransposeConvOptionsT> {
    if let Self::TransposeConvOptions(v) = self { Some(v.as_mut()) } else { None }
  }
  /// If the union variant matches, return the owned SparseToDenseOptionsT, setting the union to NONE.
  pub fn take_sparse_to_dense_options(&mut self) -> Option<Box<SparseToDenseOptionsT>> {
    if let Self::SparseToDenseOptions(_) = self {
      let v = core::mem::replace(self, Self::NONE);
      if let Self::SparseToDenseOptions(w) = v {
        Some(w)
      } else {
        unreachable!()
      }
    } else {
      None
    }
  }
  /// If the union variant matches, return a reference to the SparseToDenseOptionsT.
  pub fn as_sparse_to_dense_options(&self) -> Option<&SparseToDenseOptionsT> {
    if let Self::SparseToDenseOptions(v) = self { Some(v.as_ref()) } else { None }
  }
  /// If the union variant matches, return a mutable reference to the SparseToDenseOptionsT.
  pub fn as_sparse_to_dense_options_mut(&mut self) -> Option<&mut SparseToDenseOptionsT> {
    if let Self::SparseToDenseOptions(v) = self { Some(v.as_mut()) } else { None }
  }
  /// If the union variant matches, return the owned TileOptionsT, setting the union to NONE.
  pub fn take_tile_options(&mut self) -> Option<Box<TileOptionsT>> {
    if let Self::TileOptions(_) = self {
      let v = core::mem::replace(self, Self::NONE);
      if let Self::TileOptions(w) = v {
        Some(w)
      } else {
        unreachable!()
      }
    } else {
      None
    }
  }
  /// If the union variant matches, return a reference to the TileOptionsT.
  pub fn as_tile_options(&self) -> Option<&TileOptionsT> {
    if let Self::TileOptions(v) = self { Some(v.as_ref()) } else { None }
  }
  /// If the union variant matches, return a mutable reference to the TileOptionsT.
  pub fn as_tile_options_mut(&mut self) -> Option<&mut TileOptionsT> {
    if let Self::TileOptions(v) = self { Some(v.as_mut()) } else { None }
  }
  /// If the union variant matches, return the owned ExpandDimsOptionsT, setting the union to NONE.
  pub fn take_expand_dims_options(&mut self) -> Option<Box<ExpandDimsOptionsT>> {
    if let Self::ExpandDimsOptions(_) = self {
      let v = core::mem::replace(self, Self::NONE);
      if let Self::ExpandDimsOptions(w) = v {
        Some(w)
      } else {
        unreachable!()
      }
    } else {
      None
    }
  }
  /// If the union variant matches, return a reference to the ExpandDimsOptionsT.
  pub fn as_expand_dims_options(&self) -> Option<&ExpandDimsOptionsT> {
    if let Self::ExpandDimsOptions(v) = self { Some(v.as_ref()) } else { None }
  }
  /// If the union variant matches, return a mutable reference to the ExpandDimsOptionsT.
  pub fn as_expand_dims_options_mut(&mut self) -> Option<&mut ExpandDimsOptionsT> {
    if let Self::ExpandDimsOptions(v) = self { Some(v.as_mut()) } else { None }
  }
  /// If the union variant matches, return the owned EqualOptionsT, setting the union to NONE.
  pub fn take_equal_options(&mut self) -> Option<Box<EqualOptionsT>> {
    if let Self::EqualOptions(_) = self {
      let v = core::mem::replace(self, Self::NONE);
      if let Self::EqualOptions(w) = v {
        Some(w)
      } else {
        unreachable!()
      }
    } else {
      None
    }
  }
  /// If the union variant matches, return a reference to the EqualOptionsT.
  pub fn as_equal_options(&self) -> Option<&EqualOptionsT> {
    if let Self::EqualOptions(v) = self { Some(v.as_ref()) } else { None }
  }
  /// If the union variant matches, return a mutable reference to the EqualOptionsT.
  pub fn as_equal_options_mut(&mut self) -> Option<&mut EqualOptionsT> {
    if let Self::EqualOptions(v) = self { Some(v.as_mut()) } else { None }
  }
  /// If the union variant matches, return the owned NotEqualOptionsT, setting the union to NONE.
  pub fn take_not_equal_options(&mut self) -> Option<Box<NotEqualOptionsT>> {
    if let Self::NotEqualOptions(_) = self {
      let v = core::mem::replace(self, Self::NONE);
      if let Self::NotEqualOptions(w) = v {
        Some(w)
      } else {
        unreachable!()
      }
    } else {
      None
    }
  }
  /// If the union variant matches, return a reference to the NotEqualOptionsT.
  pub fn as_not_equal_options(&self) -> Option<&NotEqualOptionsT> {
    if let Self::NotEqualOptions(v) = self { Some(v.as_ref()) } else { None }
  }
  /// If the union variant matches, return a mutable reference to the NotEqualOptionsT.
  pub fn as_not_equal_options_mut(&mut self) -> Option<&mut NotEqualOptionsT> {
    if let Self::NotEqualOptions(v) = self { Some(v.as_mut()) } else { None }
  }
  /// If the union variant matches, return the owned ShapeOptionsT, setting the union to NONE.
  pub fn take_shape_options(&mut self) -> Option<Box<ShapeOptionsT>> {
    if let Self::ShapeOptions(_) = self {
      let v = core::mem::replace(self, Self::NONE);
      if let Self::ShapeOptions(w) = v {
        Some(w)
      } else {
        unreachable!()
      }
    } else {
      None
    }
  }
  /// If the union variant matches, return a reference to the ShapeOptionsT.
  pub fn as_shape_options(&self) -> Option<&ShapeOptionsT> {
    if let Self::ShapeOptions(v) = self { Some(v.as_ref()) } else { None }
  }
  /// If the union variant matches, return a mutable reference to the ShapeOptionsT.
  pub fn as_shape_options_mut(&mut self) -> Option<&mut ShapeOptionsT> {
    if let Self::ShapeOptions(v) = self { Some(v.as_mut()) } else { None }
  }
  /// If the union variant matches, return the owned PowOptionsT, setting the union to NONE.
  pub fn take_pow_options(&mut self) -> Option<Box<PowOptionsT>> {
    if let Self::PowOptions(_) = self {
      let v = core::mem::replace(self, Self::NONE);
      if let Self::PowOptions(w) = v {
        Some(w)
      } else {
        unreachable!()
      }
    } else {
      None
    }
  }
  /// If the union variant matches, return a reference to the PowOptionsT.
  pub fn as_pow_options(&self) -> Option<&PowOptionsT> {
    if let Self::PowOptions(v) = self { Some(v.as_ref()) } else { None }
  }
  /// If the union variant matches, return a mutable reference to the PowOptionsT.
  pub fn as_pow_options_mut(&mut self) -> Option<&mut PowOptionsT> {
    if let Self::PowOptions(v) = self { Some(v.as_mut()) } else { None }
  }
  /// If the union variant matches, return the owned ArgMinOptionsT, setting the union to NONE.
  pub fn take_arg_min_options(&mut self) -> Option<Box<ArgMinOptionsT>> {
    if let Self::ArgMinOptions(_) = self {
      let v = core::mem::replace(self, Self::NONE);
      if let Self::ArgMinOptions(w) = v {
        Some(w)
      } else {
        unreachable!()
      }
    } else {
      None
    }
  }
  /// If the union variant matches, return a reference to the ArgMinOptionsT.
  pub fn as_arg_min_options(&self) -> Option<&ArgMinOptionsT> {
    if let Self::ArgMinOptions(v) = self { Some(v.as_ref()) } else { None }
  }
  /// If the union variant matches, return a mutable reference to the ArgMinOptionsT.
  pub fn as_arg_min_options_mut(&mut self) -> Option<&mut ArgMinOptionsT> {
    if let Self::ArgMinOptions(v) = self { Some(v.as_mut()) } else { None }
  }
  /// If the union variant matches, return the owned FakeQuantOptionsT, setting the union to NONE.
  pub fn take_fake_quant_options(&mut self) -> Option<Box<FakeQuantOptionsT>> {
    if let Self::FakeQuantOptions(_) = self {
      let v = core::mem::replace(self, Self::NONE);
      if let Self::FakeQuantOptions(w) = v {
        Some(w)
      } else {
        unreachable!()
      }
    } else {
      None
    }
  }
  /// If the union variant matches, return a reference to the FakeQuantOptionsT.
  pub fn as_fake_quant_options(&self) -> Option<&FakeQuantOptionsT> {
    if let Self::FakeQuantOptions(v) = self { Some(v.as_ref()) } else { None }
  }
  /// If the union variant matches, return a mutable reference to the FakeQuantOptionsT.
  pub fn as_fake_quant_options_mut(&mut self) -> Option<&mut FakeQuantOptionsT> {
    if let Self::FakeQuantOptions(v) = self { Some(v.as_mut()) } else { None }
  }
  /// If the union variant matches, return the owned PackOptionsT, setting the union to NONE.
  pub fn take_pack_options(&mut self) -> Option<Box<PackOptionsT>> {
    if let Self::PackOptions(_) = self {
      let v = core::mem::replace(self, Self::NONE);
      if let Self::PackOptions(w) = v {
        Some(w)
      } else {
        unreachable!()
      }
    } else {
      None
    }
  }
  /// If the union variant matches, return a reference to the PackOptionsT.
  pub fn as_pack_options(&self) -> Option<&PackOptionsT> {
    if let Self::PackOptions(v) = self { Some(v.as_ref()) } else { None }
  }
  /// If the union variant matches, return a mutable reference to the PackOptionsT.
  pub fn as_pack_options_mut(&mut self) -> Option<&mut PackOptionsT> {
    if let Self::PackOptions(v) = self { Some(v.as_mut()) } else { None }
  }
  /// If the union variant matches, return the owned LogicalOrOptionsT, setting the union to NONE.
  pub fn take_logical_or_options(&mut self) -> Option<Box<LogicalOrOptionsT>> {
    if let Self::LogicalOrOptions(_) = self {
      let v = core::mem::replace(self, Self::NONE);
      if let Self::LogicalOrOptions(w) = v {
        Some(w)
      } else {
        unreachable!()
      }
    } else {
      None
    }
  }
  /// If the union variant matches, return a reference to the LogicalOrOptionsT.
  pub fn as_logical_or_options(&self) -> Option<&LogicalOrOptionsT> {
    if let Self::LogicalOrOptions(v) = self { Some(v.as_ref()) } else { None }
  }
  /// If the union variant matches, return a mutable reference to the LogicalOrOptionsT.
  pub fn as_logical_or_options_mut(&mut self) -> Option<&mut LogicalOrOptionsT> {
    if let Self::LogicalOrOptions(v) = self { Some(v.as_mut()) } else { None }
  }
  /// If the union variant matches, return the owned OneHotOptionsT, setting the union to NONE.
  pub fn take_one_hot_options(&mut self) -> Option<Box<OneHotOptionsT>> {
    if let Self::OneHotOptions(_) = self {
      let v = core::mem::replace(self, Self::NONE);
      if let Self::OneHotOptions(w) = v {
        Some(w)
      } else {
        unreachable!()
      }
    } else {
      None
    }
  }
  /// If the union variant matches, return a reference to the OneHotOptionsT.
  pub fn as_one_hot_options(&self) -> Option<&OneHotOptionsT> {
    if let Self::OneHotOptions(v) = self { Some(v.as_ref()) } else { None }
  }
  /// If the union variant matches, return a mutable reference to the OneHotOptionsT.
  pub fn as_one_hot_options_mut(&mut self) -> Option<&mut OneHotOptionsT> {
    if let Self::OneHotOptions(v) = self { Some(v.as_mut()) } else { None }
  }
  /// If the union variant matches, return the owned LogicalAndOptionsT, setting the union to NONE.
  pub fn take_logical_and_options(&mut self) -> Option<Box<LogicalAndOptionsT>> {
    if let Self::LogicalAndOptions(_) = self {
      let v = core::mem::replace(self, Self::NONE);
      if let Self::LogicalAndOptions(w) = v {
        Some(w)
      } else {
        unreachable!()
      }
    } else {
      None
    }
  }
  /// If the union variant matches, return a reference to the LogicalAndOptionsT.
  pub fn as_logical_and_options(&self) -> Option<&LogicalAndOptionsT> {
    if let Self::LogicalAndOptions(v) = self { Some(v.as_ref()) } else { None }
  }
  /// If the union variant matches, return a mutable reference to the LogicalAndOptionsT.
  pub fn as_logical_and_options_mut(&mut self) -> Option<&mut LogicalAndOptionsT> {
    if let Self::LogicalAndOptions(v) = self { Some(v.as_mut()) } else { None }
  }
  /// If the union variant matches, return the owned LogicalNotOptionsT, setting the union to NONE.
  pub fn take_logical_not_options(&mut self) -> Option<Box<LogicalNotOptionsT>> {
    if let Self::LogicalNotOptions(_) = self {
      let v = core::mem::replace(self, Self::NONE);
      if let Self::LogicalNotOptions(w) = v {
        Some(w)
      } else {
        unreachable!()
      }
    } else {
      None
    }
  }
  /// If the union variant matches, return a reference to the LogicalNotOptionsT.
  pub fn as_logical_not_options(&self) -> Option<&LogicalNotOptionsT> {
    if let Self::LogicalNotOptions(v) = self { Some(v.as_ref()) } else { None }
  }
  /// If the union variant matches, return a mutable reference to the LogicalNotOptionsT.
  pub fn as_logical_not_options_mut(&mut self) -> Option<&mut LogicalNotOptionsT> {
    if let Self::LogicalNotOptions(v) = self { Some(v.as_mut()) } else { None }
  }
  /// If the union variant matches, return the owned UnpackOptionsT, setting the union to NONE.
  pub fn take_unpack_options(&mut self) -> Option<Box<UnpackOptionsT>> {
    if let Self::UnpackOptions(_) = self {
      let v = core::mem::replace(self, Self::NONE);
      if let Self::UnpackOptions(w) = v {
        Some(w)
      } else {
        unreachable!()
      }
    } else {
      None
    }
  }
  /// If the union variant matches, return a reference to the UnpackOptionsT.
  pub fn as_unpack_options(&self) -> Option<&UnpackOptionsT> {
    if let Self::UnpackOptions(v) = self { Some(v.as_ref()) } else { None }
  }
  /// If the union variant matches, return a mutable reference to the UnpackOptionsT.
  pub fn as_unpack_options_mut(&mut self) -> Option<&mut UnpackOptionsT> {
    if let Self::UnpackOptions(v) = self { Some(v.as_mut()) } else { None }
  }
  /// If the union variant matches, return the owned FloorDivOptionsT, setting the union to NONE.
  pub fn take_floor_div_options(&mut self) -> Option<Box<FloorDivOptionsT>> {
    if let Self::FloorDivOptions(_) = self {
      let v = core::mem::replace(self, Self::NONE);
      if let Self::FloorDivOptions(w) = v {
        Some(w)
      } else {
        unreachable!()
      }
    } else {
      None
    }
  }
  /// If the union variant matches, return a reference to the FloorDivOptionsT.
  pub fn as_floor_div_options(&self) -> Option<&FloorDivOptionsT> {
    if let Self::FloorDivOptions(v) = self { Some(v.as_ref()) } else { None }
  }
  /// If the union variant matches, return a mutable reference to the FloorDivOptionsT.
  pub fn as_floor_div_options_mut(&mut self) -> Option<&mut FloorDivOptionsT> {
    if let Self::FloorDivOptions(v) = self { Some(v.as_mut()) } else { None }
  }
  /// If the union variant matches, return the owned SquareOptionsT, setting the union to NONE.
  pub fn take_square_options(&mut self) -> Option<Box<SquareOptionsT>> {
    if let Self::SquareOptions(_) = self {
      let v = core::mem::replace(self, Self::NONE);
      if let Self::SquareOptions(w) = v {
        Some(w)
      } else {
        unreachable!()
      }
    } else {
      None
    }
  }
  /// If the union variant matches, return a reference to the SquareOptionsT.
  pub fn as_square_options(&self) -> Option<&SquareOptionsT> {
    if let Self::SquareOptions(v) = self { Some(v.as_ref()) } else { None }
  }
  /// If the union variant matches, return a mutable reference to the SquareOptionsT.
  pub fn as_square_options_mut(&mut self) -> Option<&mut SquareOptionsT> {
    if let Self::SquareOptions(v) = self { Some(v.as_mut()) } else { None }
  }
  /// If the union variant matches, return the owned ZerosLikeOptionsT, setting the union to NONE.
  pub fn take_zeros_like_options(&mut self) -> Option<Box<ZerosLikeOptionsT>> {
    if let Self::ZerosLikeOptions(_) = self {
      let v = core::mem::replace(self, Self::NONE);
      if let Self::ZerosLikeOptions(w) = v {
        Some(w)
      } else {
        unreachable!()
      }
    } else {
      None
    }
  }
  /// If the union variant matches, return a reference to the ZerosLikeOptionsT.
  pub fn as_zeros_like_options(&self) -> Option<&ZerosLikeOptionsT> {
    if let Self::ZerosLikeOptions(v) = self { Some(v.as_ref()) } else { None }
  }
  /// If the union variant matches, return a mutable reference to the ZerosLikeOptionsT.
  pub fn as_zeros_like_options_mut(&mut self) -> Option<&mut ZerosLikeOptionsT> {
    if let Self::ZerosLikeOptions(v) = self { Some(v.as_mut()) } else { None }
  }
  /// If the union variant matches, return the owned FillOptionsT, setting the union to NONE.
  pub fn take_fill_options(&mut self) -> Option<Box<FillOptionsT>> {
    if let Self::FillOptions(_) = self {
      let v = core::mem::replace(self, Self::NONE);
      if let Self::FillOptions(w) = v {
        Some(w)
      } else {
        unreachable!()
      }
    } else {
      None
    }
  }
  /// If the union variant matches, return a reference to the FillOptionsT.
  pub fn as_fill_options(&self) -> Option<&FillOptionsT> {
    if let Self::FillOptions(v) = self { Some(v.as_ref()) } else { None }
  }
  /// If the union variant matches, return a mutable reference to the FillOptionsT.
  pub fn as_fill_options_mut(&mut self) -> Option<&mut FillOptionsT> {
    if let Self::FillOptions(v) = self { Some(v.as_mut()) } else { None }
  }
  /// If the union variant matches, return the owned BidirectionalSequenceLSTMOptionsT, setting the union to NONE.
  pub fn take_bidirectional_sequence_lstmoptions(&mut self) -> Option<Box<BidirectionalSequenceLSTMOptionsT>> {
    if let Self::BidirectionalSequenceLSTMOptions(_) = self {
      let v = core::mem::replace(self, Self::NONE);
      if let Self::BidirectionalSequenceLSTMOptions(w) = v {
        Some(w)
      } else {
        unreachable!()
      }
    } else {
      None
    }
  }
  /// If the union variant matches, return a reference to the BidirectionalSequenceLSTMOptionsT.
  pub fn as_bidirectional_sequence_lstmoptions(&self) -> Option<&BidirectionalSequenceLSTMOptionsT> {
    if let Self::BidirectionalSequenceLSTMOptions(v) = self { Some(v.as_ref()) } else { None }
  }
  /// If the union variant matches, return a mutable reference to the BidirectionalSequenceLSTMOptionsT.
  pub fn as_bidirectional_sequence_lstmoptions_mut(&mut self) -> Option<&mut BidirectionalSequenceLSTMOptionsT> {
    if let Self::BidirectionalSequenceLSTMOptions(v) = self { Some(v.as_mut()) } else { None }
  }
  /// If the union variant matches, return the owned BidirectionalSequenceRNNOptionsT, setting the union to NONE.
  pub fn take_bidirectional_sequence_rnnoptions(&mut self) -> Option<Box<BidirectionalSequenceRNNOptionsT>> {
    if let Self::BidirectionalSequenceRNNOptions(_) = self {
      let v = core::mem::replace(self, Self::NONE);
      if let Self::BidirectionalSequenceRNNOptions(w) = v {
        Some(w)
      } else {
        unreachable!()
      }
    } else {
      None
    }
  }
  /// If the union variant matches, return a reference to the BidirectionalSequenceRNNOptionsT.
  pub fn as_bidirectional_sequence_rnnoptions(&self) -> Option<&BidirectionalSequenceRNNOptionsT> {
    if let Self::BidirectionalSequenceRNNOptions(v) = self { Some(v.as_ref()) } else { None }
  }
  /// If the union variant matches, return a mutable reference to the BidirectionalSequenceRNNOptionsT.
  pub fn as_bidirectional_sequence_rnnoptions_mut(&mut self) -> Option<&mut BidirectionalSequenceRNNOptionsT> {
    if let Self::BidirectionalSequenceRNNOptions(v) = self { Some(v.as_mut()) } else { None }
  }
  /// If the union variant matches, return the owned UnidirectionalSequenceLSTMOptionsT, setting the union to NONE.
  pub fn take_unidirectional_sequence_lstmoptions(&mut self) -> Option<Box<UnidirectionalSequenceLSTMOptionsT>> {
    if let Self::UnidirectionalSequenceLSTMOptions(_) = self {
      let v = core::mem::replace(self, Self::NONE);
      if let Self::UnidirectionalSequenceLSTMOptions(w) = v {
        Some(w)
      } else {
        unreachable!()
      }
    } else {
      None
    }
  }
  /// If the union variant matches, return a reference to the UnidirectionalSequenceLSTMOptionsT.
  pub fn as_unidirectional_sequence_lstmoptions(&self) -> Option<&UnidirectionalSequenceLSTMOptionsT> {
    if let Self::UnidirectionalSequenceLSTMOptions(v) = self { Some(v.as_ref()) } else { None }
  }
  /// If the union variant matches, return a mutable reference to the UnidirectionalSequenceLSTMOptionsT.
  pub fn as_unidirectional_sequence_lstmoptions_mut(&mut self) -> Option<&mut UnidirectionalSequenceLSTMOptionsT> {
    if let Self::UnidirectionalSequenceLSTMOptions(v) = self { Some(v.as_mut()) } else { None }
  }
  /// If the union variant matches, return the owned FloorModOptionsT, setting the union to NONE.
  pub fn take_floor_mod_options(&mut self) -> Option<Box<FloorModOptionsT>> {
    if let Self::FloorModOptions(_) = self {
      let v = core::mem::replace(self, Self::NONE);
      if let Self::FloorModOptions(w) = v {
        Some(w)
      } else {
        unreachable!()
      }
    } else {
      None
    }
  }
  /// If the union variant matches, return a reference to the FloorModOptionsT.
  pub fn as_floor_mod_options(&self) -> Option<&FloorModOptionsT> {
    if let Self::FloorModOptions(v) = self { Some(v.as_ref()) } else { None }
  }
  /// If the union variant matches, return a mutable reference to the FloorModOptionsT.
  pub fn as_floor_mod_options_mut(&mut self) -> Option<&mut FloorModOptionsT> {
    if let Self::FloorModOptions(v) = self { Some(v.as_mut()) } else { None }
  }
  /// If the union variant matches, return the owned RangeOptionsT, setting the union to NONE.
  pub fn take_range_options(&mut self) -> Option<Box<RangeOptionsT>> {
    if let Self::RangeOptions(_) = self {
      let v = core::mem::replace(self, Self::NONE);
      if let Self::RangeOptions(w) = v {
        Some(w)
      } else {
        unreachable!()
      }
    } else {
      None
    }
  }
  /// If the union variant matches, return a reference to the RangeOptionsT.
  pub fn as_range_options(&self) -> Option<&RangeOptionsT> {
    if let Self::RangeOptions(v) = self { Some(v.as_ref()) } else { None }
  }
  /// If the union variant matches, return a mutable reference to the RangeOptionsT.
  pub fn as_range_options_mut(&mut self) -> Option<&mut RangeOptionsT> {
    if let Self::RangeOptions(v) = self { Some(v.as_mut()) } else { None }
  }
  /// If the union variant matches, return the owned ResizeNearestNeighborOptionsT, setting the union to NONE.
  pub fn take_resize_nearest_neighbor_options(&mut self) -> Option<Box<ResizeNearestNeighborOptionsT>> {
    if let Self::ResizeNearestNeighborOptions(_) = self {
      let v = core::mem::replace(self, Self::NONE);
      if let Self::ResizeNearestNeighborOptions(w) = v {
        Some(w)
      } else {
        unreachable!()
      }
    } else {
      None
    }
  }
  /// If the union variant matches, return a reference to the ResizeNearestNeighborOptionsT.
  pub fn as_resize_nearest_neighbor_options(&self) -> Option<&ResizeNearestNeighborOptionsT> {
    if let Self::ResizeNearestNeighborOptions(v) = self { Some(v.as_ref()) } else { None }
  }
  /// If the union variant matches, return a mutable reference to the ResizeNearestNeighborOptionsT.
  pub fn as_resize_nearest_neighbor_options_mut(&mut self) -> Option<&mut ResizeNearestNeighborOptionsT> {
    if let Self::ResizeNearestNeighborOptions(v) = self { Some(v.as_mut()) } else { None }
  }
  /// If the union variant matches, return the owned LeakyReluOptionsT, setting the union to NONE.
  pub fn take_leaky_relu_options(&mut self) -> Option<Box<LeakyReluOptionsT>> {
    if let Self::LeakyReluOptions(_) = self {
      let v = core::mem::replace(self, Self::NONE);
      if let Self::LeakyReluOptions(w) = v {
        Some(w)
      } else {
        unreachable!()
      }
    } else {
      None
    }
  }
  /// If the union variant matches, return a reference to the LeakyReluOptionsT.
  pub fn as_leaky_relu_options(&self) -> Option<&LeakyReluOptionsT> {
    if let Self::LeakyReluOptions(v) = self { Some(v.as_ref()) } else { None }
  }
  /// If the union variant matches, return a mutable reference to the LeakyReluOptionsT.
  pub fn as_leaky_relu_options_mut(&mut self) -> Option<&mut LeakyReluOptionsT> {
    if let Self::LeakyReluOptions(v) = self { Some(v.as_mut()) } else { None }
  }
  /// If the union variant matches, return the owned SquaredDifferenceOptionsT, setting the union to NONE.
  pub fn take_squared_difference_options(&mut self) -> Option<Box<SquaredDifferenceOptionsT>> {
    if let Self::SquaredDifferenceOptions(_) = self {
      let v = core::mem::replace(self, Self::NONE);
      if let Self::SquaredDifferenceOptions(w) = v {
        Some(w)
      } else {
        unreachable!()
      }
    } else {
      None
    }
  }
  /// If the union variant matches, return a reference to the SquaredDifferenceOptionsT.
  pub fn as_squared_difference_options(&self) -> Option<&SquaredDifferenceOptionsT> {
    if let Self::SquaredDifferenceOptions(v) = self { Some(v.as_ref()) } else { None }
  }
  /// If the union variant matches, return a mutable reference to the SquaredDifferenceOptionsT.
  pub fn as_squared_difference_options_mut(&mut self) -> Option<&mut SquaredDifferenceOptionsT> {
    if let Self::SquaredDifferenceOptions(v) = self { Some(v.as_mut()) } else { None }
  }
  /// If the union variant matches, return the owned MirrorPadOptionsT, setting the union to NONE.
  pub fn take_mirror_pad_options(&mut self) -> Option<Box<MirrorPadOptionsT>> {
    if let Self::MirrorPadOptions(_) = self {
      let v = core::mem::replace(self, Self::NONE);
      if let Self::MirrorPadOptions(w) = v {
        Some(w)
      } else {
        unreachable!()
      }
    } else {
      None
    }
  }
  /// If the union variant matches, return a reference to the MirrorPadOptionsT.
  pub fn as_mirror_pad_options(&self) -> Option<&MirrorPadOptionsT> {
    if let Self::MirrorPadOptions(v) = self { Some(v.as_ref()) } else { None }
  }
  /// If the union variant matches, return a mutable reference to the MirrorPadOptionsT.
  pub fn as_mirror_pad_options_mut(&mut self) -> Option<&mut MirrorPadOptionsT> {
    if let Self::MirrorPadOptions(v) = self { Some(v.as_mut()) } else { None }
  }
  /// If the union variant matches, return the owned AbsOptionsT, setting the union to NONE.
  pub fn take_abs_options(&mut self) -> Option<Box<AbsOptionsT>> {
    if let Self::AbsOptions(_) = self {
      let v = core::mem::replace(self, Self::NONE);
      if let Self::AbsOptions(w) = v {
        Some(w)
      } else {
        unreachable!()
      }
    } else {
      None
    }
  }
  /// If the union variant matches, return a reference to the AbsOptionsT.
  pub fn as_abs_options(&self) -> Option<&AbsOptionsT> {
    if let Self::AbsOptions(v) = self { Some(v.as_ref()) } else { None }
  }
  /// If the union variant matches, return a mutable reference to the AbsOptionsT.
  pub fn as_abs_options_mut(&mut self) -> Option<&mut AbsOptionsT> {
    if let Self::AbsOptions(v) = self { Some(v.as_mut()) } else { None }
  }
  /// If the union variant matches, return the owned SplitVOptionsT, setting the union to NONE.
  pub fn take_split_voptions(&mut self) -> Option<Box<SplitVOptionsT>> {
    if let Self::SplitVOptions(_) = self {
      let v = core::mem::replace(self, Self::NONE);
      if let Self::SplitVOptions(w) = v {
        Some(w)
      } else {
        unreachable!()
      }
    } else {
      None
    }
  }
  /// If the union variant matches, return a reference to the SplitVOptionsT.
  pub fn as_split_voptions(&self) -> Option<&SplitVOptionsT> {
    if let Self::SplitVOptions(v) = self { Some(v.as_ref()) } else { None }
  }
  /// If the union variant matches, return a mutable reference to the SplitVOptionsT.
  pub fn as_split_voptions_mut(&mut self) -> Option<&mut SplitVOptionsT> {
    if let Self::SplitVOptions(v) = self { Some(v.as_mut()) } else { None }
  }
  /// If the union variant matches, return the owned UniqueOptionsT, setting the union to NONE.
  pub fn take_unique_options(&mut self) -> Option<Box<UniqueOptionsT>> {
    if let Self::UniqueOptions(_) = self {
      let v = core::mem::replace(self, Self::NONE);
      if let Self::UniqueOptions(w) = v {
        Some(w)
      } else {
        unreachable!()
      }
    } else {
      None
    }
  }
  /// If the union variant matches, return a reference to the UniqueOptionsT.
  pub fn as_unique_options(&self) -> Option<&UniqueOptionsT> {
    if let Self::UniqueOptions(v) = self { Some(v.as_ref()) } else { None }
  }
  /// If the union variant matches, return a mutable reference to the UniqueOptionsT.
  pub fn as_unique_options_mut(&mut self) -> Option<&mut UniqueOptionsT> {
    if let Self::UniqueOptions(v) = self { Some(v.as_mut()) } else { None }
  }
  /// If the union variant matches, return the owned ReverseV2OptionsT, setting the union to NONE.
  pub fn take_reverse_v2_options(&mut self) -> Option<Box<ReverseV2OptionsT>> {
    if let Self::ReverseV2Options(_) = self {
      let v = core::mem::replace(self, Self::NONE);
      if let Self::ReverseV2Options(w) = v {
        Some(w)
      } else {
        unreachable!()
      }
    } else {
      None
    }
  }
  /// If the union variant matches, return a reference to the ReverseV2OptionsT.
  pub fn as_reverse_v2_options(&self) -> Option<&ReverseV2OptionsT> {
    if let Self::ReverseV2Options(v) = self { Some(v.as_ref()) } else { None }
  }
  /// If the union variant matches, return a mutable reference to the ReverseV2OptionsT.
  pub fn as_reverse_v2_options_mut(&mut self) -> Option<&mut ReverseV2OptionsT> {
    if let Self::ReverseV2Options(v) = self { Some(v.as_mut()) } else { None }
  }
  /// If the union variant matches, return the owned AddNOptionsT, setting the union to NONE.
  pub fn take_add_noptions(&mut self) -> Option<Box<AddNOptionsT>> {
    if let Self::AddNOptions(_) = self {
      let v = core::mem::replace(self, Self::NONE);
      if let Self::AddNOptions(w) = v {
        Some(w)
      } else {
        unreachable!()
      }
    } else {
      None
    }
  }
  /// If the union variant matches, return a reference to the AddNOptionsT.
  pub fn as_add_noptions(&self) -> Option<&AddNOptionsT> {
    if let Self::AddNOptions(v) = self { Some(v.as_ref()) } else { None }
  }
  /// If the union variant matches, return a mutable reference to the AddNOptionsT.
  pub fn as_add_noptions_mut(&mut self) -> Option<&mut AddNOptionsT> {
    if let Self::AddNOptions(v) = self { Some(v.as_mut()) } else { None }
  }
  /// If the union variant matches, return the owned GatherNdOptionsT, setting the union to NONE.
  pub fn take_gather_nd_options(&mut self) -> Option<Box<GatherNdOptionsT>> {
    if let Self::GatherNdOptions(_) = self {
      let v = core::mem::replace(self, Self::NONE);
      if let Self::GatherNdOptions(w) = v {
        Some(w)
      } else {
        unreachable!()
      }
    } else {
      None
    }
  }
  /// If the union variant matches, return a reference to the GatherNdOptionsT.
  pub fn as_gather_nd_options(&self) -> Option<&GatherNdOptionsT> {
    if let Self::GatherNdOptions(v) = self { Some(v.as_ref()) } else { None }
  }
  /// If the union variant matches, return a mutable reference to the GatherNdOptionsT.
  pub fn as_gather_nd_options_mut(&mut self) -> Option<&mut GatherNdOptionsT> {
    if let Self::GatherNdOptions(v) = self { Some(v.as_mut()) } else { None }
  }
  /// If the union variant matches, return the owned CosOptionsT, setting the union to NONE.
  pub fn take_cos_options(&mut self) -> Option<Box<CosOptionsT>> {
    if let Self::CosOptions(_) = self {
      let v = core::mem::replace(self, Self::NONE);
      if let Self::CosOptions(w) = v {
        Some(w)
      } else {
        unreachable!()
      }
    } else {
      None
    }
  }
  /// If the union variant matches, return a reference to the CosOptionsT.
  pub fn as_cos_options(&self) -> Option<&CosOptionsT> {
    if let Self::CosOptions(v) = self { Some(v.as_ref()) } else { None }
  }
  /// If the union variant matches, return a mutable reference to the CosOptionsT.
  pub fn as_cos_options_mut(&mut self) -> Option<&mut CosOptionsT> {
    if let Self::CosOptions(v) = self { Some(v.as_mut()) } else { None }
  }
  /// If the union variant matches, return the owned WhereOptionsT, setting the union to NONE.
  pub fn take_where_options(&mut self) -> Option<Box<WhereOptionsT>> {
    if let Self::WhereOptions(_) = self {
      let v = core::mem::replace(self, Self::NONE);
      if let Self::WhereOptions(w) = v {
        Some(w)
      } else {
        unreachable!()
      }
    } else {
      None
    }
  }
  /// If the union variant matches, return a reference to the WhereOptionsT.
  pub fn as_where_options(&self) -> Option<&WhereOptionsT> {
    if let Self::WhereOptions(v) = self { Some(v.as_ref()) } else { None }
  }
  /// If the union variant matches, return a mutable reference to the WhereOptionsT.
  pub fn as_where_options_mut(&mut self) -> Option<&mut WhereOptionsT> {
    if let Self::WhereOptions(v) = self { Some(v.as_mut()) } else { None }
  }
  /// If the union variant matches, return the owned RankOptionsT, setting the union to NONE.
  pub fn take_rank_options(&mut self) -> Option<Box<RankOptionsT>> {
    if let Self::RankOptions(_) = self {
      let v = core::mem::replace(self, Self::NONE);
      if let Self::RankOptions(w) = v {
        Some(w)
      } else {
        unreachable!()
      }
    } else {
      None
    }
  }
  /// If the union variant matches, return a reference to the RankOptionsT.
  pub fn as_rank_options(&self) -> Option<&RankOptionsT> {
    if let Self::RankOptions(v) = self { Some(v.as_ref()) } else { None }
  }
  /// If the union variant matches, return a mutable reference to the RankOptionsT.
  pub fn as_rank_options_mut(&mut self) -> Option<&mut RankOptionsT> {
    if let Self::RankOptions(v) = self { Some(v.as_mut()) } else { None }
  }
  /// If the union variant matches, return the owned ReverseSequenceOptionsT, setting the union to NONE.
  pub fn take_reverse_sequence_options(&mut self) -> Option<Box<ReverseSequenceOptionsT>> {
    if let Self::ReverseSequenceOptions(_) = self {
      let v = core::mem::replace(self, Self::NONE);
      if let Self::ReverseSequenceOptions(w) = v {
        Some(w)
      } else {
        unreachable!()
      }
    } else {
      None
    }
  }
  /// If the union variant matches, return a reference to the ReverseSequenceOptionsT.
  pub fn as_reverse_sequence_options(&self) -> Option<&ReverseSequenceOptionsT> {
    if let Self::ReverseSequenceOptions(v) = self { Some(v.as_ref()) } else { None }
  }
  /// If the union variant matches, return a mutable reference to the ReverseSequenceOptionsT.
  pub fn as_reverse_sequence_options_mut(&mut self) -> Option<&mut ReverseSequenceOptionsT> {
    if let Self::ReverseSequenceOptions(v) = self { Some(v.as_mut()) } else { None }
  }
  /// If the union variant matches, return the owned MatrixDiagOptionsT, setting the union to NONE.
  pub fn take_matrix_diag_options(&mut self) -> Option<Box<MatrixDiagOptionsT>> {
    if let Self::MatrixDiagOptions(_) = self {
      let v = core::mem::replace(self, Self::NONE);
      if let Self::MatrixDiagOptions(w) = v {
        Some(w)
      } else {
        unreachable!()
      }
    } else {
      None
    }
  }
  /// If the union variant matches, return a reference to the MatrixDiagOptionsT.
  pub fn as_matrix_diag_options(&self) -> Option<&MatrixDiagOptionsT> {
    if let Self::MatrixDiagOptions(v) = self { Some(v.as_ref()) } else { None }
  }
  /// If the union variant matches, return a mutable reference to the MatrixDiagOptionsT.
  pub fn as_matrix_diag_options_mut(&mut self) -> Option<&mut MatrixDiagOptionsT> {
    if let Self::MatrixDiagOptions(v) = self { Some(v.as_mut()) } else { None }
  }
  /// If the union variant matches, return the owned QuantizeOptionsT, setting the union to NONE.
  pub fn take_quantize_options(&mut self) -> Option<Box<QuantizeOptionsT>> {
    if let Self::QuantizeOptions(_) = self {
      let v = core::mem::replace(self, Self::NONE);
      if let Self::QuantizeOptions(w) = v {
        Some(w)
      } else {
        unreachable!()
      }
    } else {
      None
    }
  }
  /// If the union variant matches, return a reference to the QuantizeOptionsT.
  pub fn as_quantize_options(&self) -> Option<&QuantizeOptionsT> {
    if let Self::QuantizeOptions(v) = self { Some(v.as_ref()) } else { None }
  }
  /// If the union variant matches, return a mutable reference to the QuantizeOptionsT.
  pub fn as_quantize_options_mut(&mut self) -> Option<&mut QuantizeOptionsT> {
    if let Self::QuantizeOptions(v) = self { Some(v.as_mut()) } else { None }
  }
  /// If the union variant matches, return the owned MatrixSetDiagOptionsT, setting the union to NONE.
  pub fn take_matrix_set_diag_options(&mut self) -> Option<Box<MatrixSetDiagOptionsT>> {
    if let Self::MatrixSetDiagOptions(_) = self {
      let v = core::mem::replace(self, Self::NONE);
      if let Self::MatrixSetDiagOptions(w) = v {
        Some(w)
      } else {
        unreachable!()
      }
    } else {
      None
    }
  }
  /// If the union variant matches, return a reference to the MatrixSetDiagOptionsT.
  pub fn as_matrix_set_diag_options(&self) -> Option<&MatrixSetDiagOptionsT> {
    if let Self::MatrixSetDiagOptions(v) = self { Some(v.as_ref()) } else { None }
  }
  /// If the union variant matches, return a mutable reference to the MatrixSetDiagOptionsT.
  pub fn as_matrix_set_diag_options_mut(&mut self) -> Option<&mut MatrixSetDiagOptionsT> {
    if let Self::MatrixSetDiagOptions(v) = self { Some(v.as_mut()) } else { None }
  }
  /// If the union variant matches, return the owned HardSwishOptionsT, setting the union to NONE.
  pub fn take_hard_swish_options(&mut self) -> Option<Box<HardSwishOptionsT>> {
    if let Self::HardSwishOptions(_) = self {
      let v = core::mem::replace(self, Self::NONE);
      if let Self::HardSwishOptions(w) = v {
        Some(w)
      } else {
        unreachable!()
      }
    } else {
      None
    }
  }
  /// If the union variant matches, return a reference to the HardSwishOptionsT.
  pub fn as_hard_swish_options(&self) -> Option<&HardSwishOptionsT> {
    if let Self::HardSwishOptions(v) = self { Some(v.as_ref()) } else { None }
  }
  /// If the union variant matches, return a mutable reference to the HardSwishOptionsT.
  pub fn as_hard_swish_options_mut(&mut self) -> Option<&mut HardSwishOptionsT> {
    if let Self::HardSwishOptions(v) = self { Some(v.as_mut()) } else { None }
  }
  /// If the union variant matches, return the owned IfOptionsT, setting the union to NONE.
  pub fn take_if_options(&mut self) -> Option<Box<IfOptionsT>> {
    if let Self::IfOptions(_) = self {
      let v = core::mem::replace(self, Self::NONE);
      if let Self::IfOptions(w) = v {
        Some(w)
      } else {
        unreachable!()
      }
    } else {
      None
    }
  }
  /// If the union variant matches, return a reference to the IfOptionsT.
  pub fn as_if_options(&self) -> Option<&IfOptionsT> {
    if let Self::IfOptions(v) = self { Some(v.as_ref()) } else { None }
  }
  /// If the union variant matches, return a mutable reference to the IfOptionsT.
  pub fn as_if_options_mut(&mut self) -> Option<&mut IfOptionsT> {
    if let Self::IfOptions(v) = self { Some(v.as_mut()) } else { None }
  }
  /// If the union variant matches, return the owned WhileOptionsT, setting the union to NONE.
  pub fn take_while_options(&mut self) -> Option<Box<WhileOptionsT>> {
    if let Self::WhileOptions(_) = self {
      let v = core::mem::replace(self, Self::NONE);
      if let Self::WhileOptions(w) = v {
        Some(w)
      } else {
        unreachable!()
      }
    } else {
      None
    }
  }
  /// If the union variant matches, return a reference to the WhileOptionsT.
  pub fn as_while_options(&self) -> Option<&WhileOptionsT> {
    if let Self::WhileOptions(v) = self { Some(v.as_ref()) } else { None }
  }
  /// If the union variant matches, return a mutable reference to the WhileOptionsT.
  pub fn as_while_options_mut(&mut self) -> Option<&mut WhileOptionsT> {
    if let Self::WhileOptions(v) = self { Some(v.as_mut()) } else { None }
  }
  /// If the union variant matches, return the owned DepthToSpaceOptionsT, setting the union to NONE.
  pub fn take_depth_to_space_options(&mut self) -> Option<Box<DepthToSpaceOptionsT>> {
    if let Self::DepthToSpaceOptions(_) = self {
      let v = core::mem::replace(self, Self::NONE);
      if let Self::DepthToSpaceOptions(w) = v {
        Some(w)
      } else {
        unreachable!()
      }
    } else {
      None
    }
  }
  /// If the union variant matches, return a reference to the DepthToSpaceOptionsT.
  pub fn as_depth_to_space_options(&self) -> Option<&DepthToSpaceOptionsT> {
    if let Self::DepthToSpaceOptions(v) = self { Some(v.as_ref()) } else { None }
  }
  /// If the union variant matches, return a mutable reference to the DepthToSpaceOptionsT.
  pub fn as_depth_to_space_options_mut(&mut self) -> Option<&mut DepthToSpaceOptionsT> {
    if let Self::DepthToSpaceOptions(v) = self { Some(v.as_mut()) } else { None }
  }
  /// If the union variant matches, return the owned NonMaxSuppressionV4OptionsT, setting the union to NONE.
  pub fn take_non_max_suppression_v4_options(&mut self) -> Option<Box<NonMaxSuppressionV4OptionsT>> {
    if let Self::NonMaxSuppressionV4Options(_) = self {
      let v = core::mem::replace(self, Self::NONE);
      if let Self::NonMaxSuppressionV4Options(w) = v {
        Some(w)
      } else {
        unreachable!()
      }
    } else {
      None
    }
  }
  /// If the union variant matches, return a reference to the NonMaxSuppressionV4OptionsT.
  pub fn as_non_max_suppression_v4_options(&self) -> Option<&NonMaxSuppressionV4OptionsT> {
    if let Self::NonMaxSuppressionV4Options(v) = self { Some(v.as_ref()) } else { None }
  }
  /// If the union variant matches, return a mutable reference to the NonMaxSuppressionV4OptionsT.
  pub fn as_non_max_suppression_v4_options_mut(&mut self) -> Option<&mut NonMaxSuppressionV4OptionsT> {
    if let Self::NonMaxSuppressionV4Options(v) = self { Some(v.as_mut()) } else { None }
  }
  /// If the union variant matches, return the owned NonMaxSuppressionV5OptionsT, setting the union to NONE.
  pub fn take_non_max_suppression_v5_options(&mut self) -> Option<Box<NonMaxSuppressionV5OptionsT>> {
    if let Self::NonMaxSuppressionV5Options(_) = self {
      let v = core::mem::replace(self, Self::NONE);
      if let Self::NonMaxSuppressionV5Options(w) = v {
        Some(w)
      } else {
        unreachable!()
      }
    } else {
      None
    }
  }
  /// If the union variant matches, return a reference to the NonMaxSuppressionV5OptionsT.
  pub fn as_non_max_suppression_v5_options(&self) -> Option<&NonMaxSuppressionV5OptionsT> {
    if let Self::NonMaxSuppressionV5Options(v) = self { Some(v.as_ref()) } else { None }
  }
  /// If the union variant matches, return a mutable reference to the NonMaxSuppressionV5OptionsT.
  pub fn as_non_max_suppression_v5_options_mut(&mut self) -> Option<&mut NonMaxSuppressionV5OptionsT> {
    if let Self::NonMaxSuppressionV5Options(v) = self { Some(v.as_mut()) } else { None }
  }
  /// If the union variant matches, return the owned ScatterNdOptionsT, setting the union to NONE.
  pub fn take_scatter_nd_options(&mut self) -> Option<Box<ScatterNdOptionsT>> {
    if let Self::ScatterNdOptions(_) = self {
      let v = core::mem::replace(self, Self::NONE);
      if let Self::ScatterNdOptions(w) = v {
        Some(w)
      } else {
        unreachable!()
      }
    } else {
      None
    }
  }
  /// If the union variant matches, return a reference to the ScatterNdOptionsT.
  pub fn as_scatter_nd_options(&self) -> Option<&ScatterNdOptionsT> {
    if let Self::ScatterNdOptions(v) = self { Some(v.as_ref()) } else { None }
  }
  /// If the union variant matches, return a mutable reference to the ScatterNdOptionsT.
  pub fn as_scatter_nd_options_mut(&mut self) -> Option<&mut ScatterNdOptionsT> {
    if let Self::ScatterNdOptions(v) = self { Some(v.as_mut()) } else { None }
  }
}
#[deprecated(since = "2.0.0", note = "Use associated constants instead. This will no longer be generated in 2021.")]
pub const ENUM_MIN_PADDING: i8 = 0;
#[deprecated(since = "2.0.0", note = "Use associated constants instead. This will no longer be generated in 2021.")]
pub const ENUM_MAX_PADDING: i8 = 1;
#[deprecated(since = "2.0.0", note = "Use associated constants instead. This will no longer be generated in 2021.")]
#[allow(non_camel_case_types)]
pub const ENUM_VALUES_PADDING: [Padding; 2] = [
  Padding::SAME,
  Padding::VALID,
];

#[derive(Clone, Copy, PartialEq, Eq, PartialOrd, Ord, Hash, Default)]
#[repr(transparent)]
pub struct Padding(pub i8);
#[allow(non_upper_case_globals)]
impl Padding {
  pub const SAME: Self = Self(0);
  pub const VALID: Self = Self(1);

  pub const ENUM_MIN: i8 = 0;
  pub const ENUM_MAX: i8 = 1;
  pub const ENUM_VALUES: &'static [Self] = &[
    Self::SAME,
    Self::VALID,
  ];
  /// Returns the variant's name or "" if unknown.
  pub fn variant_name(self) -> Option<&'static str> {
    match self {
      Self::SAME => Some("SAME"),
      Self::VALID => Some("VALID"),
      _ => None,
    }
  }
}
impl core::fmt::Debug for Padding {
  fn fmt(&self, f: &mut core::fmt::Formatter) -> core::fmt::Result {
    if let Some(name) = self.variant_name() {
      f.write_str(name)
    } else {
      f.write_fmt(format_args!("<UNKNOWN {:?}>", self.0))
    }
  }
}
impl<'a> flatbuffers::Follow<'a> for Padding {
  type Inner = Self;
  #[inline]
  fn follow(buf: &'a [u8], loc: usize) -> Self::Inner {
    let b = unsafe {
      flatbuffers::read_scalar_at::<i8>(buf, loc)
    };
    Self(b)
  }
}

impl flatbuffers::Push for Padding {
    type Output = Padding;
    #[inline]
    fn push(&self, dst: &mut [u8], _rest: &[u8]) {
        unsafe { flatbuffers::emplace_scalar::<i8>(dst, self.0); }
    }
}

impl flatbuffers::EndianScalar for Padding {
  #[inline]
  fn to_little_endian(self) -> Self {
    let b = i8::to_le(self.0);
    Self(b)
  }
  #[inline]
  #[allow(clippy::wrong_self_convention)]
  fn from_little_endian(self) -> Self {
    let b = i8::from_le(self.0);
    Self(b)
  }
}

impl<'a> flatbuffers::Verifiable for Padding {
  #[inline]
  fn run_verifier(
    v: &mut flatbuffers::Verifier, pos: usize
  ) -> Result<(), flatbuffers::InvalidFlatbuffer> {
    use self::flatbuffers::Verifiable;
    i8::run_verifier(v, pos)
  }
}

impl flatbuffers::SimpleToVerifyInSlice for Padding {}
#[deprecated(since = "2.0.0", note = "Use associated constants instead. This will no longer be generated in 2021.")]
pub const ENUM_MIN_ACTIVATION_FUNCTION_TYPE: i8 = 0;
#[deprecated(since = "2.0.0", note = "Use associated constants instead. This will no longer be generated in 2021.")]
pub const ENUM_MAX_ACTIVATION_FUNCTION_TYPE: i8 = 5;
#[deprecated(since = "2.0.0", note = "Use associated constants instead. This will no longer be generated in 2021.")]
#[allow(non_camel_case_types)]
pub const ENUM_VALUES_ACTIVATION_FUNCTION_TYPE: [ActivationFunctionType; 6] = [
  ActivationFunctionType::NONE,
  ActivationFunctionType::RELU,
  ActivationFunctionType::RELU_N1_TO_1,
  ActivationFunctionType::RELU6,
  ActivationFunctionType::TANH,
  ActivationFunctionType::SIGN_BIT,
];

#[derive(Clone, Copy, PartialEq, Eq, PartialOrd, Ord, Hash, Default)]
#[repr(transparent)]
pub struct ActivationFunctionType(pub i8);
#[allow(non_upper_case_globals)]
impl ActivationFunctionType {
  pub const NONE: Self = Self(0);
  pub const RELU: Self = Self(1);
  pub const RELU_N1_TO_1: Self = Self(2);
  pub const RELU6: Self = Self(3);
  pub const TANH: Self = Self(4);
  pub const SIGN_BIT: Self = Self(5);

  pub const ENUM_MIN: i8 = 0;
  pub const ENUM_MAX: i8 = 5;
  pub const ENUM_VALUES: &'static [Self] = &[
    Self::NONE,
    Self::RELU,
    Self::RELU_N1_TO_1,
    Self::RELU6,
    Self::TANH,
    Self::SIGN_BIT,
  ];
  /// Returns the variant's name or "" if unknown.
  pub fn variant_name(self) -> Option<&'static str> {
    match self {
      Self::NONE => Some("NONE"),
      Self::RELU => Some("RELU"),
      Self::RELU_N1_TO_1 => Some("RELU_N1_TO_1"),
      Self::RELU6 => Some("RELU6"),
      Self::TANH => Some("TANH"),
      Self::SIGN_BIT => Some("SIGN_BIT"),
      _ => None,
    }
  }
}
impl core::fmt::Debug for ActivationFunctionType {
  fn fmt(&self, f: &mut core::fmt::Formatter) -> core::fmt::Result {
    if let Some(name) = self.variant_name() {
      f.write_str(name)
    } else {
      f.write_fmt(format_args!("<UNKNOWN {:?}>", self.0))
    }
  }
}
impl<'a> flatbuffers::Follow<'a> for ActivationFunctionType {
  type Inner = Self;
  #[inline]
  fn follow(buf: &'a [u8], loc: usize) -> Self::Inner {
    let b = unsafe {
      flatbuffers::read_scalar_at::<i8>(buf, loc)
    };
    Self(b)
  }
}

impl flatbuffers::Push for ActivationFunctionType {
    type Output = ActivationFunctionType;
    #[inline]
    fn push(&self, dst: &mut [u8], _rest: &[u8]) {
        unsafe { flatbuffers::emplace_scalar::<i8>(dst, self.0); }
    }
}

impl flatbuffers::EndianScalar for ActivationFunctionType {
  #[inline]
  fn to_little_endian(self) -> Self {
    let b = i8::to_le(self.0);
    Self(b)
  }
  #[inline]
  #[allow(clippy::wrong_self_convention)]
  fn from_little_endian(self) -> Self {
    let b = i8::from_le(self.0);
    Self(b)
  }
}

impl<'a> flatbuffers::Verifiable for ActivationFunctionType {
  #[inline]
  fn run_verifier(
    v: &mut flatbuffers::Verifier, pos: usize
  ) -> Result<(), flatbuffers::InvalidFlatbuffer> {
    use self::flatbuffers::Verifiable;
    i8::run_verifier(v, pos)
  }
}

impl flatbuffers::SimpleToVerifyInSlice for ActivationFunctionType {}
#[deprecated(since = "2.0.0", note = "Use associated constants instead. This will no longer be generated in 2021.")]
pub const ENUM_MIN_LSHPROJECTION_TYPE: i8 = 0;
#[deprecated(since = "2.0.0", note = "Use associated constants instead. This will no longer be generated in 2021.")]
pub const ENUM_MAX_LSHPROJECTION_TYPE: i8 = 2;
#[deprecated(since = "2.0.0", note = "Use associated constants instead. This will no longer be generated in 2021.")]
#[allow(non_camel_case_types)]
pub const ENUM_VALUES_LSHPROJECTION_TYPE: [LSHProjectionType; 3] = [
  LSHProjectionType::UNKNOWN,
  LSHProjectionType::SPARSE,
  LSHProjectionType::DENSE,
];

#[derive(Clone, Copy, PartialEq, Eq, PartialOrd, Ord, Hash, Default)]
#[repr(transparent)]
pub struct LSHProjectionType(pub i8);
#[allow(non_upper_case_globals)]
impl LSHProjectionType {
  pub const UNKNOWN: Self = Self(0);
  pub const SPARSE: Self = Self(1);
  pub const DENSE: Self = Self(2);

  pub const ENUM_MIN: i8 = 0;
  pub const ENUM_MAX: i8 = 2;
  pub const ENUM_VALUES: &'static [Self] = &[
    Self::UNKNOWN,
    Self::SPARSE,
    Self::DENSE,
  ];
  /// Returns the variant's name or "" if unknown.
  pub fn variant_name(self) -> Option<&'static str> {
    match self {
      Self::UNKNOWN => Some("UNKNOWN"),
      Self::SPARSE => Some("SPARSE"),
      Self::DENSE => Some("DENSE"),
      _ => None,
    }
  }
}
impl core::fmt::Debug for LSHProjectionType {
  fn fmt(&self, f: &mut core::fmt::Formatter) -> core::fmt::Result {
    if let Some(name) = self.variant_name() {
      f.write_str(name)
    } else {
      f.write_fmt(format_args!("<UNKNOWN {:?}>", self.0))
    }
  }
}
impl<'a> flatbuffers::Follow<'a> for LSHProjectionType {
  type Inner = Self;
  #[inline]
  fn follow(buf: &'a [u8], loc: usize) -> Self::Inner {
    let b = unsafe {
      flatbuffers::read_scalar_at::<i8>(buf, loc)
    };
    Self(b)
  }
}

impl flatbuffers::Push for LSHProjectionType {
    type Output = LSHProjectionType;
    #[inline]
    fn push(&self, dst: &mut [u8], _rest: &[u8]) {
        unsafe { flatbuffers::emplace_scalar::<i8>(dst, self.0); }
    }
}

impl flatbuffers::EndianScalar for LSHProjectionType {
  #[inline]
  fn to_little_endian(self) -> Self {
    let b = i8::to_le(self.0);
    Self(b)
  }
  #[inline]
  #[allow(clippy::wrong_self_convention)]
  fn from_little_endian(self) -> Self {
    let b = i8::from_le(self.0);
    Self(b)
  }
}

impl<'a> flatbuffers::Verifiable for LSHProjectionType {
  #[inline]
  fn run_verifier(
    v: &mut flatbuffers::Verifier, pos: usize
  ) -> Result<(), flatbuffers::InvalidFlatbuffer> {
    use self::flatbuffers::Verifiable;
    i8::run_verifier(v, pos)
  }
}

impl flatbuffers::SimpleToVerifyInSlice for LSHProjectionType {}
#[deprecated(since = "2.0.0", note = "Use associated constants instead. This will no longer be generated in 2021.")]
pub const ENUM_MIN_FULLY_CONNECTED_OPTIONS_WEIGHTS_FORMAT: i8 = 0;
#[deprecated(since = "2.0.0", note = "Use associated constants instead. This will no longer be generated in 2021.")]
pub const ENUM_MAX_FULLY_CONNECTED_OPTIONS_WEIGHTS_FORMAT: i8 = 1;
#[deprecated(since = "2.0.0", note = "Use associated constants instead. This will no longer be generated in 2021.")]
#[allow(non_camel_case_types)]
pub const ENUM_VALUES_FULLY_CONNECTED_OPTIONS_WEIGHTS_FORMAT: [FullyConnectedOptionsWeightsFormat; 2] = [
  FullyConnectedOptionsWeightsFormat::DEFAULT,
  FullyConnectedOptionsWeightsFormat::SHUFFLED4x16INT8,
];

#[derive(Clone, Copy, PartialEq, Eq, PartialOrd, Ord, Hash, Default)]
#[repr(transparent)]
pub struct FullyConnectedOptionsWeightsFormat(pub i8);
#[allow(non_upper_case_globals)]
impl FullyConnectedOptionsWeightsFormat {
  pub const DEFAULT: Self = Self(0);
  pub const SHUFFLED4x16INT8: Self = Self(1);

  pub const ENUM_MIN: i8 = 0;
  pub const ENUM_MAX: i8 = 1;
  pub const ENUM_VALUES: &'static [Self] = &[
    Self::DEFAULT,
    Self::SHUFFLED4x16INT8,
  ];
  /// Returns the variant's name or "" if unknown.
  pub fn variant_name(self) -> Option<&'static str> {
    match self {
      Self::DEFAULT => Some("DEFAULT"),
      Self::SHUFFLED4x16INT8 => Some("SHUFFLED4x16INT8"),
      _ => None,
    }
  }
}
impl core::fmt::Debug for FullyConnectedOptionsWeightsFormat {
  fn fmt(&self, f: &mut core::fmt::Formatter) -> core::fmt::Result {
    if let Some(name) = self.variant_name() {
      f.write_str(name)
    } else {
      f.write_fmt(format_args!("<UNKNOWN {:?}>", self.0))
    }
  }
}
impl<'a> flatbuffers::Follow<'a> for FullyConnectedOptionsWeightsFormat {
  type Inner = Self;
  #[inline]
  fn follow(buf: &'a [u8], loc: usize) -> Self::Inner {
    let b = unsafe {
      flatbuffers::read_scalar_at::<i8>(buf, loc)
    };
    Self(b)
  }
}

impl flatbuffers::Push for FullyConnectedOptionsWeightsFormat {
    type Output = FullyConnectedOptionsWeightsFormat;
    #[inline]
    fn push(&self, dst: &mut [u8], _rest: &[u8]) {
        unsafe { flatbuffers::emplace_scalar::<i8>(dst, self.0); }
    }
}

impl flatbuffers::EndianScalar for FullyConnectedOptionsWeightsFormat {
  #[inline]
  fn to_little_endian(self) -> Self {
    let b = i8::to_le(self.0);
    Self(b)
  }
  #[inline]
  #[allow(clippy::wrong_self_convention)]
  fn from_little_endian(self) -> Self {
    let b = i8::from_le(self.0);
    Self(b)
  }
}

impl<'a> flatbuffers::Verifiable for FullyConnectedOptionsWeightsFormat {
  #[inline]
  fn run_verifier(
    v: &mut flatbuffers::Verifier, pos: usize
  ) -> Result<(), flatbuffers::InvalidFlatbuffer> {
    use self::flatbuffers::Verifiable;
    i8::run_verifier(v, pos)
  }
}

impl flatbuffers::SimpleToVerifyInSlice for FullyConnectedOptionsWeightsFormat {}
#[deprecated(since = "2.0.0", note = "Use associated constants instead. This will no longer be generated in 2021.")]
pub const ENUM_MIN_LSTMKERNEL_TYPE: i8 = 0;
#[deprecated(since = "2.0.0", note = "Use associated constants instead. This will no longer be generated in 2021.")]
pub const ENUM_MAX_LSTMKERNEL_TYPE: i8 = 1;
#[deprecated(since = "2.0.0", note = "Use associated constants instead. This will no longer be generated in 2021.")]
#[allow(non_camel_case_types)]
pub const ENUM_VALUES_LSTMKERNEL_TYPE: [LSTMKernelType; 2] = [
  LSTMKernelType::FULL,
  LSTMKernelType::BASIC,
];

#[derive(Clone, Copy, PartialEq, Eq, PartialOrd, Ord, Hash, Default)]
#[repr(transparent)]
pub struct LSTMKernelType(pub i8);
#[allow(non_upper_case_globals)]
impl LSTMKernelType {
  pub const FULL: Self = Self(0);
  pub const BASIC: Self = Self(1);

  pub const ENUM_MIN: i8 = 0;
  pub const ENUM_MAX: i8 = 1;
  pub const ENUM_VALUES: &'static [Self] = &[
    Self::FULL,
    Self::BASIC,
  ];
  /// Returns the variant's name or "" if unknown.
  pub fn variant_name(self) -> Option<&'static str> {
    match self {
      Self::FULL => Some("FULL"),
      Self::BASIC => Some("BASIC"),
      _ => None,
    }
  }
}
impl core::fmt::Debug for LSTMKernelType {
  fn fmt(&self, f: &mut core::fmt::Formatter) -> core::fmt::Result {
    if let Some(name) = self.variant_name() {
      f.write_str(name)
    } else {
      f.write_fmt(format_args!("<UNKNOWN {:?}>", self.0))
    }
  }
}
impl<'a> flatbuffers::Follow<'a> for LSTMKernelType {
  type Inner = Self;
  #[inline]
  fn follow(buf: &'a [u8], loc: usize) -> Self::Inner {
    let b = unsafe {
      flatbuffers::read_scalar_at::<i8>(buf, loc)
    };
    Self(b)
  }
}

impl flatbuffers::Push for LSTMKernelType {
    type Output = LSTMKernelType;
    #[inline]
    fn push(&self, dst: &mut [u8], _rest: &[u8]) {
        unsafe { flatbuffers::emplace_scalar::<i8>(dst, self.0); }
    }
}

impl flatbuffers::EndianScalar for LSTMKernelType {
  #[inline]
  fn to_little_endian(self) -> Self {
    let b = i8::to_le(self.0);
    Self(b)
  }
  #[inline]
  #[allow(clippy::wrong_self_convention)]
  fn from_little_endian(self) -> Self {
    let b = i8::from_le(self.0);
    Self(b)
  }
}

impl<'a> flatbuffers::Verifiable for LSTMKernelType {
  #[inline]
  fn run_verifier(
    v: &mut flatbuffers::Verifier, pos: usize
  ) -> Result<(), flatbuffers::InvalidFlatbuffer> {
    use self::flatbuffers::Verifiable;
    i8::run_verifier(v, pos)
  }
}

impl flatbuffers::SimpleToVerifyInSlice for LSTMKernelType {}
#[deprecated(since = "2.0.0", note = "Use associated constants instead. This will no longer be generated in 2021.")]
pub const ENUM_MIN_COMBINER_TYPE: i8 = 0;
#[deprecated(since = "2.0.0", note = "Use associated constants instead. This will no longer be generated in 2021.")]
pub const ENUM_MAX_COMBINER_TYPE: i8 = 2;
#[deprecated(since = "2.0.0", note = "Use associated constants instead. This will no longer be generated in 2021.")]
#[allow(non_camel_case_types)]
pub const ENUM_VALUES_COMBINER_TYPE: [CombinerType; 3] = [
  CombinerType::SUM,
  CombinerType::MEAN,
  CombinerType::SQRTN,
];

#[derive(Clone, Copy, PartialEq, Eq, PartialOrd, Ord, Hash, Default)]
#[repr(transparent)]
pub struct CombinerType(pub i8);
#[allow(non_upper_case_globals)]
impl CombinerType {
  pub const SUM: Self = Self(0);
  pub const MEAN: Self = Self(1);
  pub const SQRTN: Self = Self(2);

  pub const ENUM_MIN: i8 = 0;
  pub const ENUM_MAX: i8 = 2;
  pub const ENUM_VALUES: &'static [Self] = &[
    Self::SUM,
    Self::MEAN,
    Self::SQRTN,
  ];
  /// Returns the variant's name or "" if unknown.
  pub fn variant_name(self) -> Option<&'static str> {
    match self {
      Self::SUM => Some("SUM"),
      Self::MEAN => Some("MEAN"),
      Self::SQRTN => Some("SQRTN"),
      _ => None,
    }
  }
}
impl core::fmt::Debug for CombinerType {
  fn fmt(&self, f: &mut core::fmt::Formatter) -> core::fmt::Result {
    if let Some(name) = self.variant_name() {
      f.write_str(name)
    } else {
      f.write_fmt(format_args!("<UNKNOWN {:?}>", self.0))
    }
  }
}
impl<'a> flatbuffers::Follow<'a> for CombinerType {
  type Inner = Self;
  #[inline]
  fn follow(buf: &'a [u8], loc: usize) -> Self::Inner {
    let b = unsafe {
      flatbuffers::read_scalar_at::<i8>(buf, loc)
    };
    Self(b)
  }
}

impl flatbuffers::Push for CombinerType {
    type Output = CombinerType;
    #[inline]
    fn push(&self, dst: &mut [u8], _rest: &[u8]) {
        unsafe { flatbuffers::emplace_scalar::<i8>(dst, self.0); }
    }
}

impl flatbuffers::EndianScalar for CombinerType {
  #[inline]
  fn to_little_endian(self) -> Self {
    let b = i8::to_le(self.0);
    Self(b)
  }
  #[inline]
  #[allow(clippy::wrong_self_convention)]
  fn from_little_endian(self) -> Self {
    let b = i8::from_le(self.0);
    Self(b)
  }
}

impl<'a> flatbuffers::Verifiable for CombinerType {
  #[inline]
  fn run_verifier(
    v: &mut flatbuffers::Verifier, pos: usize
  ) -> Result<(), flatbuffers::InvalidFlatbuffer> {
    use self::flatbuffers::Verifiable;
    i8::run_verifier(v, pos)
  }
}

impl flatbuffers::SimpleToVerifyInSlice for CombinerType {}
#[deprecated(since = "2.0.0", note = "Use associated constants instead. This will no longer be generated in 2021.")]
pub const ENUM_MIN_MIRROR_PAD_MODE: i8 = 0;
#[deprecated(since = "2.0.0", note = "Use associated constants instead. This will no longer be generated in 2021.")]
pub const ENUM_MAX_MIRROR_PAD_MODE: i8 = 1;
#[deprecated(since = "2.0.0", note = "Use associated constants instead. This will no longer be generated in 2021.")]
#[allow(non_camel_case_types)]
pub const ENUM_VALUES_MIRROR_PAD_MODE: [MirrorPadMode; 2] = [
  MirrorPadMode::REFLECT,
  MirrorPadMode::SYMMETRIC,
];

#[derive(Clone, Copy, PartialEq, Eq, PartialOrd, Ord, Hash, Default)]
#[repr(transparent)]
pub struct MirrorPadMode(pub i8);
#[allow(non_upper_case_globals)]
impl MirrorPadMode {
  pub const REFLECT: Self = Self(0);
  pub const SYMMETRIC: Self = Self(1);

  pub const ENUM_MIN: i8 = 0;
  pub const ENUM_MAX: i8 = 1;
  pub const ENUM_VALUES: &'static [Self] = &[
    Self::REFLECT,
    Self::SYMMETRIC,
  ];
  /// Returns the variant's name or "" if unknown.
  pub fn variant_name(self) -> Option<&'static str> {
    match self {
      Self::REFLECT => Some("REFLECT"),
      Self::SYMMETRIC => Some("SYMMETRIC"),
      _ => None,
    }
  }
}
impl core::fmt::Debug for MirrorPadMode {
  fn fmt(&self, f: &mut core::fmt::Formatter) -> core::fmt::Result {
    if let Some(name) = self.variant_name() {
      f.write_str(name)
    } else {
      f.write_fmt(format_args!("<UNKNOWN {:?}>", self.0))
    }
  }
}
impl<'a> flatbuffers::Follow<'a> for MirrorPadMode {
  type Inner = Self;
  #[inline]
  fn follow(buf: &'a [u8], loc: usize) -> Self::Inner {
    let b = unsafe {
      flatbuffers::read_scalar_at::<i8>(buf, loc)
    };
    Self(b)
  }
}

impl flatbuffers::Push for MirrorPadMode {
    type Output = MirrorPadMode;
    #[inline]
    fn push(&self, dst: &mut [u8], _rest: &[u8]) {
        unsafe { flatbuffers::emplace_scalar::<i8>(dst, self.0); }
    }
}

impl flatbuffers::EndianScalar for MirrorPadMode {
  #[inline]
  fn to_little_endian(self) -> Self {
    let b = i8::to_le(self.0);
    Self(b)
  }
  #[inline]
  #[allow(clippy::wrong_self_convention)]
  fn from_little_endian(self) -> Self {
    let b = i8::from_le(self.0);
    Self(b)
  }
}

impl<'a> flatbuffers::Verifiable for MirrorPadMode {
  #[inline]
  fn run_verifier(
    v: &mut flatbuffers::Verifier, pos: usize
  ) -> Result<(), flatbuffers::InvalidFlatbuffer> {
    use self::flatbuffers::Verifiable;
    i8::run_verifier(v, pos)
  }
}

impl flatbuffers::SimpleToVerifyInSlice for MirrorPadMode {}
#[deprecated(since = "2.0.0", note = "Use associated constants instead. This will no longer be generated in 2021.")]
pub const ENUM_MIN_CUSTOM_OPTIONS_FORMAT: i8 = 0;
#[deprecated(since = "2.0.0", note = "Use associated constants instead. This will no longer be generated in 2021.")]
pub const ENUM_MAX_CUSTOM_OPTIONS_FORMAT: i8 = 0;
#[deprecated(since = "2.0.0", note = "Use associated constants instead. This will no longer be generated in 2021.")]
#[allow(non_camel_case_types)]
pub const ENUM_VALUES_CUSTOM_OPTIONS_FORMAT: [CustomOptionsFormat; 1] = [
  CustomOptionsFormat::FLEXBUFFERS,
];

#[derive(Clone, Copy, PartialEq, Eq, PartialOrd, Ord, Hash, Default)]
#[repr(transparent)]
pub struct CustomOptionsFormat(pub i8);
#[allow(non_upper_case_globals)]
impl CustomOptionsFormat {
  pub const FLEXBUFFERS: Self = Self(0);

  pub const ENUM_MIN: i8 = 0;
  pub const ENUM_MAX: i8 = 0;
  pub const ENUM_VALUES: &'static [Self] = &[
    Self::FLEXBUFFERS,
  ];
  /// Returns the variant's name or "" if unknown.
  pub fn variant_name(self) -> Option<&'static str> {
    match self {
      Self::FLEXBUFFERS => Some("FLEXBUFFERS"),
      _ => None,
    }
  }
}
impl core::fmt::Debug for CustomOptionsFormat {
  fn fmt(&self, f: &mut core::fmt::Formatter) -> core::fmt::Result {
    if let Some(name) = self.variant_name() {
      f.write_str(name)
    } else {
      f.write_fmt(format_args!("<UNKNOWN {:?}>", self.0))
    }
  }
}
impl<'a> flatbuffers::Follow<'a> for CustomOptionsFormat {
  type Inner = Self;
  #[inline]
  fn follow(buf: &'a [u8], loc: usize) -> Self::Inner {
    let b = unsafe {
      flatbuffers::read_scalar_at::<i8>(buf, loc)
    };
    Self(b)
  }
}

impl flatbuffers::Push for CustomOptionsFormat {
    type Output = CustomOptionsFormat;
    #[inline]
    fn push(&self, dst: &mut [u8], _rest: &[u8]) {
        unsafe { flatbuffers::emplace_scalar::<i8>(dst, self.0); }
    }
}

impl flatbuffers::EndianScalar for CustomOptionsFormat {
  #[inline]
  fn to_little_endian(self) -> Self {
    let b = i8::to_le(self.0);
    Self(b)
  }
  #[inline]
  #[allow(clippy::wrong_self_convention)]
  fn from_little_endian(self) -> Self {
    let b = i8::from_le(self.0);
    Self(b)
  }
}

impl<'a> flatbuffers::Verifiable for CustomOptionsFormat {
  #[inline]
  fn run_verifier(
    v: &mut flatbuffers::Verifier, pos: usize
  ) -> Result<(), flatbuffers::InvalidFlatbuffer> {
    use self::flatbuffers::Verifiable;
    i8::run_verifier(v, pos)
  }
}

impl flatbuffers::SimpleToVerifyInSlice for CustomOptionsFormat {}
pub enum CustomQuantizationOffset {}
#[derive(Copy, Clone, PartialEq)]

pub struct CustomQuantization<'a> {
  pub _tab: flatbuffers::Table<'a>,
}

impl<'a> flatbuffers::Follow<'a> for CustomQuantization<'a> {
  type Inner = CustomQuantization<'a>;
  #[inline]
  fn follow(buf: &'a [u8], loc: usize) -> Self::Inner {
    Self { _tab: flatbuffers::Table { buf, loc } }
  }
}

impl<'a> CustomQuantization<'a> {
  pub const VT_CUSTOM: flatbuffers::VOffsetT = 4;

  #[inline]
  pub fn init_from_table(table: flatbuffers::Table<'a>) -> Self {
    CustomQuantization { _tab: table }
  }
  #[allow(unused_mut)]
  pub fn create<'bldr: 'args, 'args: 'mut_bldr, 'mut_bldr>(
    _fbb: &'mut_bldr mut flatbuffers::FlatBufferBuilder<'bldr>,
    args: &'args CustomQuantizationArgs<'args>
  ) -> flatbuffers::WIPOffset<CustomQuantization<'bldr>> {
    let mut builder = CustomQuantizationBuilder::new(_fbb);
    if let Some(x) = args.custom { builder.add_custom(x); }
    builder.finish()
  }

  pub fn unpack(&self) -> CustomQuantizationT {
    let custom = self.custom().map(|x| {
      x.to_vec()
    });
    CustomQuantizationT {
      custom,
    }
  }

  #[inline]
  pub fn custom(&self) -> Option<&'a [u8]> {
    self._tab.get::<flatbuffers::ForwardsUOffset<flatbuffers::Vector<'a, u8>>>(CustomQuantization::VT_CUSTOM, None).map(|v| v.safe_slice())
  }
}

impl flatbuffers::Verifiable for CustomQuantization<'_> {
  #[inline]
  fn run_verifier(
    v: &mut flatbuffers::Verifier, pos: usize
  ) -> Result<(), flatbuffers::InvalidFlatbuffer> {
    use self::flatbuffers::Verifiable;
    v.visit_table(pos)?
     .visit_field::<flatbuffers::ForwardsUOffset<flatbuffers::Vector<'_, u8>>>("custom", Self::VT_CUSTOM, false)?
     .finish();
    Ok(())
  }
}
pub struct CustomQuantizationArgs<'a> {
    pub custom: Option<flatbuffers::WIPOffset<flatbuffers::Vector<'a, u8>>>,
}
impl<'a> Default for CustomQuantizationArgs<'a> {
  #[inline]
  fn default() -> Self {
    CustomQuantizationArgs {
      custom: None,
    }
  }
}

pub struct CustomQuantizationBuilder<'a: 'b, 'b> {
  fbb_: &'b mut flatbuffers::FlatBufferBuilder<'a>,
  start_: flatbuffers::WIPOffset<flatbuffers::TableUnfinishedWIPOffset>,
}
impl<'a: 'b, 'b> CustomQuantizationBuilder<'a, 'b> {
  #[inline]
  pub fn add_custom(&mut self, custom: flatbuffers::WIPOffset<flatbuffers::Vector<'b , u8>>) {
    self.fbb_.push_slot_always::<flatbuffers::WIPOffset<_>>(CustomQuantization::VT_CUSTOM, custom);
  }
  #[inline]
  pub fn new(_fbb: &'b mut flatbuffers::FlatBufferBuilder<'a>) -> CustomQuantizationBuilder<'a, 'b> {
    let start = _fbb.start_table();
    CustomQuantizationBuilder {
      fbb_: _fbb,
      start_: start,
    }
  }
  #[inline]
  pub fn finish(self) -> flatbuffers::WIPOffset<CustomQuantization<'a>> {
    let o = self.fbb_.end_table(self.start_);
    flatbuffers::WIPOffset::new(o.value())
  }
}

impl core::fmt::Debug for CustomQuantization<'_> {
  fn fmt(&self, f: &mut core::fmt::Formatter<'_>) -> core::fmt::Result {
    let mut ds = f.debug_struct("CustomQuantization");
      ds.field("custom", &self.custom());
      ds.finish()
  }
}
#[non_exhaustive]
#[derive(Debug, Clone, PartialEq)]
pub struct CustomQuantizationT {
  pub custom: Option<Vec<u8>>,
}
impl Default for CustomQuantizationT {
  fn default() -> Self {
    Self {
      custom: None,
    }
  }
}
impl CustomQuantizationT {
  pub fn pack<'b>(
    &self,
    _fbb: &mut flatbuffers::FlatBufferBuilder<'b>
  ) -> flatbuffers::WIPOffset<CustomQuantization<'b>> {
    let custom = self.custom.as_ref().map(|x|{
      _fbb.create_vector(x)
    });
    CustomQuantization::create(_fbb, &CustomQuantizationArgs{
      custom,
    })
  }
}
pub enum QuantizationParametersOffset {}
#[derive(Copy, Clone, PartialEq)]

pub struct QuantizationParameters<'a> {
  pub _tab: flatbuffers::Table<'a>,
}

impl<'a> flatbuffers::Follow<'a> for QuantizationParameters<'a> {
  type Inner = QuantizationParameters<'a>;
  #[inline]
  fn follow(buf: &'a [u8], loc: usize) -> Self::Inner {
    Self { _tab: flatbuffers::Table { buf, loc } }
  }
}

impl<'a> QuantizationParameters<'a> {
  pub const VT_MIN: flatbuffers::VOffsetT = 4;
  pub const VT_MAX: flatbuffers::VOffsetT = 6;
  pub const VT_SCALE: flatbuffers::VOffsetT = 8;
  pub const VT_ZERO_POINT: flatbuffers::VOffsetT = 10;
  pub const VT_DETAILS_TYPE: flatbuffers::VOffsetT = 12;
  pub const VT_DETAILS: flatbuffers::VOffsetT = 14;
  pub const VT_QUANTIZED_DIMENSION: flatbuffers::VOffsetT = 16;

  #[inline]
  pub fn init_from_table(table: flatbuffers::Table<'a>) -> Self {
    QuantizationParameters { _tab: table }
  }
  #[allow(unused_mut)]
  pub fn create<'bldr: 'args, 'args: 'mut_bldr, 'mut_bldr>(
    _fbb: &'mut_bldr mut flatbuffers::FlatBufferBuilder<'bldr>,
    args: &'args QuantizationParametersArgs<'args>
  ) -> flatbuffers::WIPOffset<QuantizationParameters<'bldr>> {
    let mut builder = QuantizationParametersBuilder::new(_fbb);
    builder.add_quantized_dimension(args.quantized_dimension);
    if let Some(x) = args.details { builder.add_details(x); }
    if let Some(x) = args.zero_point { builder.add_zero_point(x); }
    if let Some(x) = args.scale { builder.add_scale(x); }
    if let Some(x) = args.max { builder.add_max(x); }
    if let Some(x) = args.min { builder.add_min(x); }
    builder.add_details_type(args.details_type);
    builder.finish()
  }

  pub fn unpack(&self) -> QuantizationParametersT {
    let min = self.min().map(|x| {
      x.into_iter().collect()
    });
    let max = self.max().map(|x| {
      x.into_iter().collect()
    });
    let scale = self.scale().map(|x| {
      x.into_iter().collect()
    });
    let zero_point = self.zero_point().map(|x| {
      x.into_iter().collect()
    });
    let details = match self.details_type() {
      QuantizationDetails::NONE => QuantizationDetailsT::NONE,
      QuantizationDetails::CustomQuantization => QuantizationDetailsT::CustomQuantization(Box::new(
        self.details_as_custom_quantization()
            .expect("Invalid union table, expected `QuantizationDetails::CustomQuantization`.")
            .unpack()
      )),
      _ => QuantizationDetailsT::NONE,
    };
    let quantized_dimension = self.quantized_dimension();
    QuantizationParametersT {
      min,
      max,
      scale,
      zero_point,
      details,
      quantized_dimension,
    }
  }

  #[inline]
  pub fn min(&self) -> Option<flatbuffers::Vector<'a, f32>> {
    self._tab.get::<flatbuffers::ForwardsUOffset<flatbuffers::Vector<'a, f32>>>(QuantizationParameters::VT_MIN, None)
  }
  #[inline]
  pub fn max(&self) -> Option<flatbuffers::Vector<'a, f32>> {
    self._tab.get::<flatbuffers::ForwardsUOffset<flatbuffers::Vector<'a, f32>>>(QuantizationParameters::VT_MAX, None)
  }
  #[inline]
  pub fn scale(&self) -> Option<flatbuffers::Vector<'a, f32>> {
    self._tab.get::<flatbuffers::ForwardsUOffset<flatbuffers::Vector<'a, f32>>>(QuantizationParameters::VT_SCALE, None)
  }
  #[inline]
  pub fn zero_point(&self) -> Option<flatbuffers::Vector<'a, i64>> {
    self._tab.get::<flatbuffers::ForwardsUOffset<flatbuffers::Vector<'a, i64>>>(QuantizationParameters::VT_ZERO_POINT, None)
  }
  #[inline]
  pub fn details_type(&self) -> QuantizationDetails {
    self._tab.get::<QuantizationDetails>(QuantizationParameters::VT_DETAILS_TYPE, Some(QuantizationDetails::NONE)).unwrap()
  }
  #[inline]
  pub fn details(&self) -> Option<flatbuffers::Table<'a>> {
    self._tab.get::<flatbuffers::ForwardsUOffset<flatbuffers::Table<'a>>>(QuantizationParameters::VT_DETAILS, None)
  }
  #[inline]
  pub fn quantized_dimension(&self) -> i32 {
    self._tab.get::<i32>(QuantizationParameters::VT_QUANTIZED_DIMENSION, Some(0)).unwrap()
  }
  #[inline]
  #[allow(non_snake_case)]
  pub fn details_as_custom_quantization(&self) -> Option<CustomQuantization<'a>> {
    if self.details_type() == QuantizationDetails::CustomQuantization {
      self.details().map(CustomQuantization::init_from_table)
    } else {
      None
    }
  }

}

impl flatbuffers::Verifiable for QuantizationParameters<'_> {
  #[inline]
  fn run_verifier(
    v: &mut flatbuffers::Verifier, pos: usize
  ) -> Result<(), flatbuffers::InvalidFlatbuffer> {
    use self::flatbuffers::Verifiable;
    v.visit_table(pos)?
     .visit_field::<flatbuffers::ForwardsUOffset<flatbuffers::Vector<'_, f32>>>("min", Self::VT_MIN, false)?
     .visit_field::<flatbuffers::ForwardsUOffset<flatbuffers::Vector<'_, f32>>>("max", Self::VT_MAX, false)?
     .visit_field::<flatbuffers::ForwardsUOffset<flatbuffers::Vector<'_, f32>>>("scale", Self::VT_SCALE, false)?
     .visit_field::<flatbuffers::ForwardsUOffset<flatbuffers::Vector<'_, i64>>>("zero_point", Self::VT_ZERO_POINT, false)?
     .visit_union::<QuantizationDetails, _>("details_type", Self::VT_DETAILS_TYPE, "details", Self::VT_DETAILS, false, |key, v, pos| {
        match key {
          QuantizationDetails::CustomQuantization => v.verify_union_variant::<flatbuffers::ForwardsUOffset<CustomQuantization>>("QuantizationDetails::CustomQuantization", pos),
          _ => Ok(()),
        }
     })?
     .visit_field::<i32>("quantized_dimension", Self::VT_QUANTIZED_DIMENSION, false)?
     .finish();
    Ok(())
  }
}
pub struct QuantizationParametersArgs<'a> {
    pub min: Option<flatbuffers::WIPOffset<flatbuffers::Vector<'a, f32>>>,
    pub max: Option<flatbuffers::WIPOffset<flatbuffers::Vector<'a, f32>>>,
    pub scale: Option<flatbuffers::WIPOffset<flatbuffers::Vector<'a, f32>>>,
    pub zero_point: Option<flatbuffers::WIPOffset<flatbuffers::Vector<'a, i64>>>,
    pub details_type: QuantizationDetails,
    pub details: Option<flatbuffers::WIPOffset<flatbuffers::UnionWIPOffset>>,
    pub quantized_dimension: i32,
}
impl<'a> Default for QuantizationParametersArgs<'a> {
  #[inline]
  fn default() -> Self {
    QuantizationParametersArgs {
      min: None,
      max: None,
      scale: None,
      zero_point: None,
      details_type: QuantizationDetails::NONE,
      details: None,
      quantized_dimension: 0,
    }
  }
}

pub struct QuantizationParametersBuilder<'a: 'b, 'b> {
  fbb_: &'b mut flatbuffers::FlatBufferBuilder<'a>,
  start_: flatbuffers::WIPOffset<flatbuffers::TableUnfinishedWIPOffset>,
}
impl<'a: 'b, 'b> QuantizationParametersBuilder<'a, 'b> {
  #[inline]
  pub fn add_min(&mut self, min: flatbuffers::WIPOffset<flatbuffers::Vector<'b , f32>>) {
    self.fbb_.push_slot_always::<flatbuffers::WIPOffset<_>>(QuantizationParameters::VT_MIN, min);
  }
  #[inline]
  pub fn add_max(&mut self, max: flatbuffers::WIPOffset<flatbuffers::Vector<'b , f32>>) {
    self.fbb_.push_slot_always::<flatbuffers::WIPOffset<_>>(QuantizationParameters::VT_MAX, max);
  }
  #[inline]
  pub fn add_scale(&mut self, scale: flatbuffers::WIPOffset<flatbuffers::Vector<'b , f32>>) {
    self.fbb_.push_slot_always::<flatbuffers::WIPOffset<_>>(QuantizationParameters::VT_SCALE, scale);
  }
  #[inline]
  pub fn add_zero_point(&mut self, zero_point: flatbuffers::WIPOffset<flatbuffers::Vector<'b , i64>>) {
    self.fbb_.push_slot_always::<flatbuffers::WIPOffset<_>>(QuantizationParameters::VT_ZERO_POINT, zero_point);
  }
  #[inline]
  pub fn add_details_type(&mut self, details_type: QuantizationDetails) {
    self.fbb_.push_slot::<QuantizationDetails>(QuantizationParameters::VT_DETAILS_TYPE, details_type, QuantizationDetails::NONE);
  }
  #[inline]
  pub fn add_details(&mut self, details: flatbuffers::WIPOffset<flatbuffers::UnionWIPOffset>) {
    self.fbb_.push_slot_always::<flatbuffers::WIPOffset<_>>(QuantizationParameters::VT_DETAILS, details);
  }
  #[inline]
  pub fn add_quantized_dimension(&mut self, quantized_dimension: i32) {
    self.fbb_.push_slot::<i32>(QuantizationParameters::VT_QUANTIZED_DIMENSION, quantized_dimension, 0);
  }
  #[inline]
  pub fn new(_fbb: &'b mut flatbuffers::FlatBufferBuilder<'a>) -> QuantizationParametersBuilder<'a, 'b> {
    let start = _fbb.start_table();
    QuantizationParametersBuilder {
      fbb_: _fbb,
      start_: start,
    }
  }
  #[inline]
  pub fn finish(self) -> flatbuffers::WIPOffset<QuantizationParameters<'a>> {
    let o = self.fbb_.end_table(self.start_);
    flatbuffers::WIPOffset::new(o.value())
  }
}

impl core::fmt::Debug for QuantizationParameters<'_> {
  fn fmt(&self, f: &mut core::fmt::Formatter<'_>) -> core::fmt::Result {
    let mut ds = f.debug_struct("QuantizationParameters");
      ds.field("min", &self.min());
      ds.field("max", &self.max());
      ds.field("scale", &self.scale());
      ds.field("zero_point", &self.zero_point());
      ds.field("details_type", &self.details_type());
      match self.details_type() {
        QuantizationDetails::CustomQuantization => {
          if let Some(x) = self.details_as_custom_quantization() {
            ds.field("details", &x)
          } else {
            ds.field("details", &"InvalidFlatbuffer: Union discriminant does not match value.")
          }
        },
        _ => {
          let x: Option<()> = None;
          ds.field("details", &x)
        },
      };
      ds.field("quantized_dimension", &self.quantized_dimension());
      ds.finish()
  }
}
#[non_exhaustive]
#[derive(Debug, Clone, PartialEq)]
pub struct QuantizationParametersT {
  pub min: Option<Vec<f32>>,
  pub max: Option<Vec<f32>>,
  pub scale: Option<Vec<f32>>,
  pub zero_point: Option<Vec<i64>>,
  pub details: QuantizationDetailsT,
  pub quantized_dimension: i32,
}
impl Default for QuantizationParametersT {
  fn default() -> Self {
    Self {
      min: None,
      max: None,
      scale: None,
      zero_point: None,
      details: QuantizationDetailsT::NONE,
      quantized_dimension: 0,
    }
  }
}
impl QuantizationParametersT {
  pub fn pack<'b>(
    &self,
    _fbb: &mut flatbuffers::FlatBufferBuilder<'b>
  ) -> flatbuffers::WIPOffset<QuantizationParameters<'b>> {
    let min = self.min.as_ref().map(|x|{
      _fbb.create_vector(x)
    });
    let max = self.max.as_ref().map(|x|{
      _fbb.create_vector(x)
    });
    let scale = self.scale.as_ref().map(|x|{
      _fbb.create_vector(x)
    });
    let zero_point = self.zero_point.as_ref().map(|x|{
      _fbb.create_vector(x)
    });
    let details_type = self.details.quantization_details_type();
    let details = self.details.pack(_fbb);
    let quantized_dimension = self.quantized_dimension;
    QuantizationParameters::create(_fbb, &QuantizationParametersArgs{
      min,
      max,
      scale,
      zero_point,
      details_type,
      details,
      quantized_dimension,
    })
  }
}
pub enum TensorOffset {}
#[derive(Copy, Clone, PartialEq)]

pub struct Tensor<'a> {
  pub _tab: flatbuffers::Table<'a>,
}

impl<'a> flatbuffers::Follow<'a> for Tensor<'a> {
  type Inner = Tensor<'a>;
  #[inline]
  fn follow(buf: &'a [u8], loc: usize) -> Self::Inner {
    Self { _tab: flatbuffers::Table { buf, loc } }
  }
}

impl<'a> Tensor<'a> {
  pub const VT_SHAPE: flatbuffers::VOffsetT = 4;
  pub const VT_TYPE_: flatbuffers::VOffsetT = 6;
  pub const VT_BUFFER: flatbuffers::VOffsetT = 8;
  pub const VT_NAME: flatbuffers::VOffsetT = 10;
  pub const VT_QUANTIZATION: flatbuffers::VOffsetT = 12;
  pub const VT_IS_VARIABLE: flatbuffers::VOffsetT = 14;

  #[inline]
  pub fn init_from_table(table: flatbuffers::Table<'a>) -> Self {
    Tensor { _tab: table }
  }
  #[allow(unused_mut)]
  pub fn create<'bldr: 'args, 'args: 'mut_bldr, 'mut_bldr>(
    _fbb: &'mut_bldr mut flatbuffers::FlatBufferBuilder<'bldr>,
    args: &'args TensorArgs<'args>
  ) -> flatbuffers::WIPOffset<Tensor<'bldr>> {
    let mut builder = TensorBuilder::new(_fbb);
    if let Some(x) = args.quantization { builder.add_quantization(x); }
    if let Some(x) = args.name { builder.add_name(x); }
    builder.add_buffer(args.buffer);
    if let Some(x) = args.shape { builder.add_shape(x); }
    builder.add_is_variable(args.is_variable);
    builder.add_type_(args.type_);
    builder.finish()
  }

  pub fn unpack(&self) -> TensorT {
    let shape = self.shape().map(|x| {
      x.into_iter().collect()
    });
    let type_ = self.type_();
    let buffer = self.buffer();
    let name = self.name().map(|x| {
      x.to_string()
    });
    let quantization = self.quantization().map(|x| {
      Box::new(x.unpack())
    });
    let is_variable = self.is_variable();
    TensorT {
      shape,
      type_,
      buffer,
      name,
      quantization,
      is_variable,
    }
  }

  #[inline]
  pub fn shape(&self) -> Option<flatbuffers::Vector<'a, i32>> {
    self._tab.get::<flatbuffers::ForwardsUOffset<flatbuffers::Vector<'a, i32>>>(Tensor::VT_SHAPE, None)
  }
  #[inline]
  pub fn type_(&self) -> TensorType {
    self._tab.get::<TensorType>(Tensor::VT_TYPE_, Some(TensorType::FLOAT32)).unwrap()
  }
  #[inline]
  pub fn buffer(&self) -> u32 {
    self._tab.get::<u32>(Tensor::VT_BUFFER, Some(0)).unwrap()
  }
  #[inline]
  pub fn name(&self) -> Option<&'a str> {
    self._tab.get::<flatbuffers::ForwardsUOffset<&str>>(Tensor::VT_NAME, None)
  }
  #[inline]
  pub fn quantization(&self) -> Option<QuantizationParameters<'a>> {
    self._tab.get::<flatbuffers::ForwardsUOffset<QuantizationParameters>>(Tensor::VT_QUANTIZATION, None)
  }
  #[inline]
  pub fn is_variable(&self) -> bool {
    self._tab.get::<bool>(Tensor::VT_IS_VARIABLE, Some(false)).unwrap()
  }
}

impl flatbuffers::Verifiable for Tensor<'_> {
  #[inline]
  fn run_verifier(
    v: &mut flatbuffers::Verifier, pos: usize
  ) -> Result<(), flatbuffers::InvalidFlatbuffer> {
    use self::flatbuffers::Verifiable;
    v.visit_table(pos)?
     .visit_field::<flatbuffers::ForwardsUOffset<flatbuffers::Vector<'_, i32>>>("shape", Self::VT_SHAPE, false)?
     .visit_field::<TensorType>("type_", Self::VT_TYPE_, false)?
     .visit_field::<u32>("buffer", Self::VT_BUFFER, false)?
     .visit_field::<flatbuffers::ForwardsUOffset<&str>>("name", Self::VT_NAME, false)?
     .visit_field::<flatbuffers::ForwardsUOffset<QuantizationParameters>>("quantization", Self::VT_QUANTIZATION, false)?
     .visit_field::<bool>("is_variable", Self::VT_IS_VARIABLE, false)?
     .finish();
    Ok(())
  }
}
pub struct TensorArgs<'a> {
    pub shape: Option<flatbuffers::WIPOffset<flatbuffers::Vector<'a, i32>>>,
    pub type_: TensorType,
    pub buffer: u32,
    pub name: Option<flatbuffers::WIPOffset<&'a str>>,
    pub quantization: Option<flatbuffers::WIPOffset<QuantizationParameters<'a>>>,
    pub is_variable: bool,
}
impl<'a> Default for TensorArgs<'a> {
  #[inline]
  fn default() -> Self {
    TensorArgs {
      shape: None,
      type_: TensorType::FLOAT32,
      buffer: 0,
      name: None,
      quantization: None,
      is_variable: false,
    }
  }
}

pub struct TensorBuilder<'a: 'b, 'b> {
  fbb_: &'b mut flatbuffers::FlatBufferBuilder<'a>,
  start_: flatbuffers::WIPOffset<flatbuffers::TableUnfinishedWIPOffset>,
}
impl<'a: 'b, 'b> TensorBuilder<'a, 'b> {
  #[inline]
  pub fn add_shape(&mut self, shape: flatbuffers::WIPOffset<flatbuffers::Vector<'b , i32>>) {
    self.fbb_.push_slot_always::<flatbuffers::WIPOffset<_>>(Tensor::VT_SHAPE, shape);
  }
  #[inline]
  pub fn add_type_(&mut self, type_: TensorType) {
    self.fbb_.push_slot::<TensorType>(Tensor::VT_TYPE_, type_, TensorType::FLOAT32);
  }
  #[inline]
  pub fn add_buffer(&mut self, buffer: u32) {
    self.fbb_.push_slot::<u32>(Tensor::VT_BUFFER, buffer, 0);
  }
  #[inline]
  pub fn add_name(&mut self, name: flatbuffers::WIPOffset<&'b  str>) {
    self.fbb_.push_slot_always::<flatbuffers::WIPOffset<_>>(Tensor::VT_NAME, name);
  }
  #[inline]
  pub fn add_quantization(&mut self, quantization: flatbuffers::WIPOffset<QuantizationParameters<'b >>) {
    self.fbb_.push_slot_always::<flatbuffers::WIPOffset<QuantizationParameters>>(Tensor::VT_QUANTIZATION, quantization);
  }
  #[inline]
  pub fn add_is_variable(&mut self, is_variable: bool) {
    self.fbb_.push_slot::<bool>(Tensor::VT_IS_VARIABLE, is_variable, false);
  }
  #[inline]
  pub fn new(_fbb: &'b mut flatbuffers::FlatBufferBuilder<'a>) -> TensorBuilder<'a, 'b> {
    let start = _fbb.start_table();
    TensorBuilder {
      fbb_: _fbb,
      start_: start,
    }
  }
  #[inline]
  pub fn finish(self) -> flatbuffers::WIPOffset<Tensor<'a>> {
    let o = self.fbb_.end_table(self.start_);
    flatbuffers::WIPOffset::new(o.value())
  }
}

impl core::fmt::Debug for Tensor<'_> {
  fn fmt(&self, f: &mut core::fmt::Formatter<'_>) -> core::fmt::Result {
    let mut ds = f.debug_struct("Tensor");
      ds.field("shape", &self.shape());
      ds.field("type_", &self.type_());
      ds.field("buffer", &self.buffer());
      ds.field("name", &self.name());
      ds.field("quantization", &self.quantization());
      ds.field("is_variable", &self.is_variable());
      ds.finish()
  }
}
#[non_exhaustive]
#[derive(Debug, Clone, PartialEq)]
pub struct TensorT {
  pub shape: Option<Vec<i32>>,
  pub type_: TensorType,
  pub buffer: u32,
  pub name: Option<String>,
  pub quantization: Option<Box<QuantizationParametersT>>,
  pub is_variable: bool,
}
impl Default for TensorT {
  fn default() -> Self {
    Self {
      shape: None,
      type_: TensorType::FLOAT32,
      buffer: 0,
      name: None,
      quantization: None,
      is_variable: false,
    }
  }
}
impl TensorT {
  pub fn pack<'b>(
    &self,
    _fbb: &mut flatbuffers::FlatBufferBuilder<'b>
  ) -> flatbuffers::WIPOffset<Tensor<'b>> {
    let shape = self.shape.as_ref().map(|x|{
      _fbb.create_vector(x)
    });
    let type_ = self.type_;
    let buffer = self.buffer;
    let name = self.name.as_ref().map(|x|{
      _fbb.create_string(x)
    });
    let quantization = self.quantization.as_ref().map(|x|{
      x.pack(_fbb)
    });
    let is_variable = self.is_variable;
    Tensor::create(_fbb, &TensorArgs{
      shape,
      type_,
      buffer,
      name,
      quantization,
      is_variable,
    })
  }
}
pub enum Conv2DOptionsOffset {}
#[derive(Copy, Clone, PartialEq)]

pub struct Conv2DOptions<'a> {
  pub _tab: flatbuffers::Table<'a>,
}

impl<'a> flatbuffers::Follow<'a> for Conv2DOptions<'a> {
  type Inner = Conv2DOptions<'a>;
  #[inline]
  fn follow(buf: &'a [u8], loc: usize) -> Self::Inner {
    Self { _tab: flatbuffers::Table { buf, loc } }
  }
}

impl<'a> Conv2DOptions<'a> {
  pub const VT_PADDING: flatbuffers::VOffsetT = 4;
  pub const VT_STRIDE_W: flatbuffers::VOffsetT = 6;
  pub const VT_STRIDE_H: flatbuffers::VOffsetT = 8;
  pub const VT_FUSED_ACTIVATION_FUNCTION: flatbuffers::VOffsetT = 10;
  pub const VT_DILATION_W_FACTOR: flatbuffers::VOffsetT = 12;
  pub const VT_DILATION_H_FACTOR: flatbuffers::VOffsetT = 14;

  #[inline]
  pub fn init_from_table(table: flatbuffers::Table<'a>) -> Self {
    Conv2DOptions { _tab: table }
  }
  #[allow(unused_mut)]
  pub fn create<'bldr: 'args, 'args: 'mut_bldr, 'mut_bldr>(
    _fbb: &'mut_bldr mut flatbuffers::FlatBufferBuilder<'bldr>,
    args: &'args Conv2DOptionsArgs
  ) -> flatbuffers::WIPOffset<Conv2DOptions<'bldr>> {
    let mut builder = Conv2DOptionsBuilder::new(_fbb);
    builder.add_dilation_h_factor(args.dilation_h_factor);
    builder.add_dilation_w_factor(args.dilation_w_factor);
    builder.add_stride_h(args.stride_h);
    builder.add_stride_w(args.stride_w);
    builder.add_fused_activation_function(args.fused_activation_function);
    builder.add_padding(args.padding);
    builder.finish()
  }

  pub fn unpack(&self) -> Conv2DOptionsT {
    let padding = self.padding();
    let stride_w = self.stride_w();
    let stride_h = self.stride_h();
    let fused_activation_function = self.fused_activation_function();
    let dilation_w_factor = self.dilation_w_factor();
    let dilation_h_factor = self.dilation_h_factor();
    Conv2DOptionsT {
      padding,
      stride_w,
      stride_h,
      fused_activation_function,
      dilation_w_factor,
      dilation_h_factor,
    }
  }

  #[inline]
  pub fn padding(&self) -> Padding {
    self._tab.get::<Padding>(Conv2DOptions::VT_PADDING, Some(Padding::SAME)).unwrap()
  }
  #[inline]
  pub fn stride_w(&self) -> i32 {
    self._tab.get::<i32>(Conv2DOptions::VT_STRIDE_W, Some(0)).unwrap()
  }
  #[inline]
  pub fn stride_h(&self) -> i32 {
    self._tab.get::<i32>(Conv2DOptions::VT_STRIDE_H, Some(0)).unwrap()
  }
  #[inline]
  pub fn fused_activation_function(&self) -> ActivationFunctionType {
    self._tab.get::<ActivationFunctionType>(Conv2DOptions::VT_FUSED_ACTIVATION_FUNCTION, Some(ActivationFunctionType::NONE)).unwrap()
  }
  #[inline]
  pub fn dilation_w_factor(&self) -> i32 {
    self._tab.get::<i32>(Conv2DOptions::VT_DILATION_W_FACTOR, Some(1)).unwrap()
  }
  #[inline]
  pub fn dilation_h_factor(&self) -> i32 {
    self._tab.get::<i32>(Conv2DOptions::VT_DILATION_H_FACTOR, Some(1)).unwrap()
  }
}

impl flatbuffers::Verifiable for Conv2DOptions<'_> {
  #[inline]
  fn run_verifier(
    v: &mut flatbuffers::Verifier, pos: usize
  ) -> Result<(), flatbuffers::InvalidFlatbuffer> {
    use self::flatbuffers::Verifiable;
    v.visit_table(pos)?
     .visit_field::<Padding>("padding", Self::VT_PADDING, false)?
     .visit_field::<i32>("stride_w", Self::VT_STRIDE_W, false)?
     .visit_field::<i32>("stride_h", Self::VT_STRIDE_H, false)?
     .visit_field::<ActivationFunctionType>("fused_activation_function", Self::VT_FUSED_ACTIVATION_FUNCTION, false)?
     .visit_field::<i32>("dilation_w_factor", Self::VT_DILATION_W_FACTOR, false)?
     .visit_field::<i32>("dilation_h_factor", Self::VT_DILATION_H_FACTOR, false)?
     .finish();
    Ok(())
  }
}
pub struct Conv2DOptionsArgs {
    pub padding: Padding,
    pub stride_w: i32,
    pub stride_h: i32,
    pub fused_activation_function: ActivationFunctionType,
    pub dilation_w_factor: i32,
    pub dilation_h_factor: i32,
}
impl<'a> Default for Conv2DOptionsArgs {
  #[inline]
  fn default() -> Self {
    Conv2DOptionsArgs {
      padding: Padding::SAME,
      stride_w: 0,
      stride_h: 0,
      fused_activation_function: ActivationFunctionType::NONE,
      dilation_w_factor: 1,
      dilation_h_factor: 1,
    }
  }
}

pub struct Conv2DOptionsBuilder<'a: 'b, 'b> {
  fbb_: &'b mut flatbuffers::FlatBufferBuilder<'a>,
  start_: flatbuffers::WIPOffset<flatbuffers::TableUnfinishedWIPOffset>,
}
impl<'a: 'b, 'b> Conv2DOptionsBuilder<'a, 'b> {
  #[inline]
  pub fn add_padding(&mut self, padding: Padding) {
    self.fbb_.push_slot::<Padding>(Conv2DOptions::VT_PADDING, padding, Padding::SAME);
  }
  #[inline]
  pub fn add_stride_w(&mut self, stride_w: i32) {
    self.fbb_.push_slot::<i32>(Conv2DOptions::VT_STRIDE_W, stride_w, 0);
  }
  #[inline]
  pub fn add_stride_h(&mut self, stride_h: i32) {
    self.fbb_.push_slot::<i32>(Conv2DOptions::VT_STRIDE_H, stride_h, 0);
  }
  #[inline]
  pub fn add_fused_activation_function(&mut self, fused_activation_function: ActivationFunctionType) {
    self.fbb_.push_slot::<ActivationFunctionType>(Conv2DOptions::VT_FUSED_ACTIVATION_FUNCTION, fused_activation_function, ActivationFunctionType::NONE);
  }
  #[inline]
  pub fn add_dilation_w_factor(&mut self, dilation_w_factor: i32) {
    self.fbb_.push_slot::<i32>(Conv2DOptions::VT_DILATION_W_FACTOR, dilation_w_factor, 1);
  }
  #[inline]
  pub fn add_dilation_h_factor(&mut self, dilation_h_factor: i32) {
    self.fbb_.push_slot::<i32>(Conv2DOptions::VT_DILATION_H_FACTOR, dilation_h_factor, 1);
  }
  #[inline]
  pub fn new(_fbb: &'b mut flatbuffers::FlatBufferBuilder<'a>) -> Conv2DOptionsBuilder<'a, 'b> {
    let start = _fbb.start_table();
    Conv2DOptionsBuilder {
      fbb_: _fbb,
      start_: start,
    }
  }
  #[inline]
  pub fn finish(self) -> flatbuffers::WIPOffset<Conv2DOptions<'a>> {
    let o = self.fbb_.end_table(self.start_);
    flatbuffers::WIPOffset::new(o.value())
  }
}

impl core::fmt::Debug for Conv2DOptions<'_> {
  fn fmt(&self, f: &mut core::fmt::Formatter<'_>) -> core::fmt::Result {
    let mut ds = f.debug_struct("Conv2DOptions");
      ds.field("padding", &self.padding());
      ds.field("stride_w", &self.stride_w());
      ds.field("stride_h", &self.stride_h());
      ds.field("fused_activation_function", &self.fused_activation_function());
      ds.field("dilation_w_factor", &self.dilation_w_factor());
      ds.field("dilation_h_factor", &self.dilation_h_factor());
      ds.finish()
  }
}
#[non_exhaustive]
#[derive(Debug, Clone, PartialEq)]
pub struct Conv2DOptionsT {
  pub padding: Padding,
  pub stride_w: i32,
  pub stride_h: i32,
  pub fused_activation_function: ActivationFunctionType,
  pub dilation_w_factor: i32,
  pub dilation_h_factor: i32,
}
impl Default for Conv2DOptionsT {
  fn default() -> Self {
    Self {
      padding: Padding::SAME,
      stride_w: 0,
      stride_h: 0,
      fused_activation_function: ActivationFunctionType::NONE,
      dilation_w_factor: 1,
      dilation_h_factor: 1,
    }
  }
}
impl Conv2DOptionsT {
  pub fn pack<'b>(
    &self,
    _fbb: &mut flatbuffers::FlatBufferBuilder<'b>
  ) -> flatbuffers::WIPOffset<Conv2DOptions<'b>> {
    let padding = self.padding;
    let stride_w = self.stride_w;
    let stride_h = self.stride_h;
    let fused_activation_function = self.fused_activation_function;
    let dilation_w_factor = self.dilation_w_factor;
    let dilation_h_factor = self.dilation_h_factor;
    Conv2DOptions::create(_fbb, &Conv2DOptionsArgs{
      padding,
      stride_w,
      stride_h,
      fused_activation_function,
      dilation_w_factor,
      dilation_h_factor,
    })
  }
}
pub enum Pool2DOptionsOffset {}
#[derive(Copy, Clone, PartialEq)]

pub struct Pool2DOptions<'a> {
  pub _tab: flatbuffers::Table<'a>,
}

impl<'a> flatbuffers::Follow<'a> for Pool2DOptions<'a> {
  type Inner = Pool2DOptions<'a>;
  #[inline]
  fn follow(buf: &'a [u8], loc: usize) -> Self::Inner {
    Self { _tab: flatbuffers::Table { buf, loc } }
  }
}

impl<'a> Pool2DOptions<'a> {
  pub const VT_PADDING: flatbuffers::VOffsetT = 4;
  pub const VT_STRIDE_W: flatbuffers::VOffsetT = 6;
  pub const VT_STRIDE_H: flatbuffers::VOffsetT = 8;
  pub const VT_FILTER_WIDTH: flatbuffers::VOffsetT = 10;
  pub const VT_FILTER_HEIGHT: flatbuffers::VOffsetT = 12;
  pub const VT_FUSED_ACTIVATION_FUNCTION: flatbuffers::VOffsetT = 14;

  #[inline]
  pub fn init_from_table(table: flatbuffers::Table<'a>) -> Self {
    Pool2DOptions { _tab: table }
  }
  #[allow(unused_mut)]
  pub fn create<'bldr: 'args, 'args: 'mut_bldr, 'mut_bldr>(
    _fbb: &'mut_bldr mut flatbuffers::FlatBufferBuilder<'bldr>,
    args: &'args Pool2DOptionsArgs
  ) -> flatbuffers::WIPOffset<Pool2DOptions<'bldr>> {
    let mut builder = Pool2DOptionsBuilder::new(_fbb);
    builder.add_filter_height(args.filter_height);
    builder.add_filter_width(args.filter_width);
    builder.add_stride_h(args.stride_h);
    builder.add_stride_w(args.stride_w);
    builder.add_fused_activation_function(args.fused_activation_function);
    builder.add_padding(args.padding);
    builder.finish()
  }

  pub fn unpack(&self) -> Pool2DOptionsT {
    let padding = self.padding();
    let stride_w = self.stride_w();
    let stride_h = self.stride_h();
    let filter_width = self.filter_width();
    let filter_height = self.filter_height();
    let fused_activation_function = self.fused_activation_function();
    Pool2DOptionsT {
      padding,
      stride_w,
      stride_h,
      filter_width,
      filter_height,
      fused_activation_function,
    }
  }

  #[inline]
  pub fn padding(&self) -> Padding {
    self._tab.get::<Padding>(Pool2DOptions::VT_PADDING, Some(Padding::SAME)).unwrap()
  }
  #[inline]
  pub fn stride_w(&self) -> i32 {
    self._tab.get::<i32>(Pool2DOptions::VT_STRIDE_W, Some(0)).unwrap()
  }
  #[inline]
  pub fn stride_h(&self) -> i32 {
    self._tab.get::<i32>(Pool2DOptions::VT_STRIDE_H, Some(0)).unwrap()
  }
  #[inline]
  pub fn filter_width(&self) -> i32 {
    self._tab.get::<i32>(Pool2DOptions::VT_FILTER_WIDTH, Some(0)).unwrap()
  }
  #[inline]
  pub fn filter_height(&self) -> i32 {
    self._tab.get::<i32>(Pool2DOptions::VT_FILTER_HEIGHT, Some(0)).unwrap()
  }
  #[inline]
  pub fn fused_activation_function(&self) -> ActivationFunctionType {
    self._tab.get::<ActivationFunctionType>(Pool2DOptions::VT_FUSED_ACTIVATION_FUNCTION, Some(ActivationFunctionType::NONE)).unwrap()
  }
}

impl flatbuffers::Verifiable for Pool2DOptions<'_> {
  #[inline]
  fn run_verifier(
    v: &mut flatbuffers::Verifier, pos: usize
  ) -> Result<(), flatbuffers::InvalidFlatbuffer> {
    use self::flatbuffers::Verifiable;
    v.visit_table(pos)?
     .visit_field::<Padding>("padding", Self::VT_PADDING, false)?
     .visit_field::<i32>("stride_w", Self::VT_STRIDE_W, false)?
     .visit_field::<i32>("stride_h", Self::VT_STRIDE_H, false)?
     .visit_field::<i32>("filter_width", Self::VT_FILTER_WIDTH, false)?
     .visit_field::<i32>("filter_height", Self::VT_FILTER_HEIGHT, false)?
     .visit_field::<ActivationFunctionType>("fused_activation_function", Self::VT_FUSED_ACTIVATION_FUNCTION, false)?
     .finish();
    Ok(())
  }
}
pub struct Pool2DOptionsArgs {
    pub padding: Padding,
    pub stride_w: i32,
    pub stride_h: i32,
    pub filter_width: i32,
    pub filter_height: i32,
    pub fused_activation_function: ActivationFunctionType,
}
impl<'a> Default for Pool2DOptionsArgs {
  #[inline]
  fn default() -> Self {
    Pool2DOptionsArgs {
      padding: Padding::SAME,
      stride_w: 0,
      stride_h: 0,
      filter_width: 0,
      filter_height: 0,
      fused_activation_function: ActivationFunctionType::NONE,
    }
  }
}

pub struct Pool2DOptionsBuilder<'a: 'b, 'b> {
  fbb_: &'b mut flatbuffers::FlatBufferBuilder<'a>,
  start_: flatbuffers::WIPOffset<flatbuffers::TableUnfinishedWIPOffset>,
}
impl<'a: 'b, 'b> Pool2DOptionsBuilder<'a, 'b> {
  #[inline]
  pub fn add_padding(&mut self, padding: Padding) {
    self.fbb_.push_slot::<Padding>(Pool2DOptions::VT_PADDING, padding, Padding::SAME);
  }
  #[inline]
  pub fn add_stride_w(&mut self, stride_w: i32) {
    self.fbb_.push_slot::<i32>(Pool2DOptions::VT_STRIDE_W, stride_w, 0);
  }
  #[inline]
  pub fn add_stride_h(&mut self, stride_h: i32) {
    self.fbb_.push_slot::<i32>(Pool2DOptions::VT_STRIDE_H, stride_h, 0);
  }
  #[inline]
  pub fn add_filter_width(&mut self, filter_width: i32) {
    self.fbb_.push_slot::<i32>(Pool2DOptions::VT_FILTER_WIDTH, filter_width, 0);
  }
  #[inline]
  pub fn add_filter_height(&mut self, filter_height: i32) {
    self.fbb_.push_slot::<i32>(Pool2DOptions::VT_FILTER_HEIGHT, filter_height, 0);
  }
  #[inline]
  pub fn add_fused_activation_function(&mut self, fused_activation_function: ActivationFunctionType) {
    self.fbb_.push_slot::<ActivationFunctionType>(Pool2DOptions::VT_FUSED_ACTIVATION_FUNCTION, fused_activation_function, ActivationFunctionType::NONE);
  }
  #[inline]
  pub fn new(_fbb: &'b mut flatbuffers::FlatBufferBuilder<'a>) -> Pool2DOptionsBuilder<'a, 'b> {
    let start = _fbb.start_table();
    Pool2DOptionsBuilder {
      fbb_: _fbb,
      start_: start,
    }
  }
  #[inline]
  pub fn finish(self) -> flatbuffers::WIPOffset<Pool2DOptions<'a>> {
    let o = self.fbb_.end_table(self.start_);
    flatbuffers::WIPOffset::new(o.value())
  }
}

impl core::fmt::Debug for Pool2DOptions<'_> {
  fn fmt(&self, f: &mut core::fmt::Formatter<'_>) -> core::fmt::Result {
    let mut ds = f.debug_struct("Pool2DOptions");
      ds.field("padding", &self.padding());
      ds.field("stride_w", &self.stride_w());
      ds.field("stride_h", &self.stride_h());
      ds.field("filter_width", &self.filter_width());
      ds.field("filter_height", &self.filter_height());
      ds.field("fused_activation_function", &self.fused_activation_function());
      ds.finish()
  }
}
#[non_exhaustive]
#[derive(Debug, Clone, PartialEq)]
pub struct Pool2DOptionsT {
  pub padding: Padding,
  pub stride_w: i32,
  pub stride_h: i32,
  pub filter_width: i32,
  pub filter_height: i32,
  pub fused_activation_function: ActivationFunctionType,
}
impl Default for Pool2DOptionsT {
  fn default() -> Self {
    Self {
      padding: Padding::SAME,
      stride_w: 0,
      stride_h: 0,
      filter_width: 0,
      filter_height: 0,
      fused_activation_function: ActivationFunctionType::NONE,
    }
  }
}
impl Pool2DOptionsT {
  pub fn pack<'b>(
    &self,
    _fbb: &mut flatbuffers::FlatBufferBuilder<'b>
  ) -> flatbuffers::WIPOffset<Pool2DOptions<'b>> {
    let padding = self.padding;
    let stride_w = self.stride_w;
    let stride_h = self.stride_h;
    let filter_width = self.filter_width;
    let filter_height = self.filter_height;
    let fused_activation_function = self.fused_activation_function;
    Pool2DOptions::create(_fbb, &Pool2DOptionsArgs{
      padding,
      stride_w,
      stride_h,
      filter_width,
      filter_height,
      fused_activation_function,
    })
  }
}
pub enum DepthwiseConv2DOptionsOffset {}
#[derive(Copy, Clone, PartialEq)]

pub struct DepthwiseConv2DOptions<'a> {
  pub _tab: flatbuffers::Table<'a>,
}

impl<'a> flatbuffers::Follow<'a> for DepthwiseConv2DOptions<'a> {
  type Inner = DepthwiseConv2DOptions<'a>;
  #[inline]
  fn follow(buf: &'a [u8], loc: usize) -> Self::Inner {
    Self { _tab: flatbuffers::Table { buf, loc } }
  }
}

impl<'a> DepthwiseConv2DOptions<'a> {
  pub const VT_PADDING: flatbuffers::VOffsetT = 4;
  pub const VT_STRIDE_W: flatbuffers::VOffsetT = 6;
  pub const VT_STRIDE_H: flatbuffers::VOffsetT = 8;
  pub const VT_DEPTH_MULTIPLIER: flatbuffers::VOffsetT = 10;
  pub const VT_FUSED_ACTIVATION_FUNCTION: flatbuffers::VOffsetT = 12;
  pub const VT_DILATION_W_FACTOR: flatbuffers::VOffsetT = 14;
  pub const VT_DILATION_H_FACTOR: flatbuffers::VOffsetT = 16;

  #[inline]
  pub fn init_from_table(table: flatbuffers::Table<'a>) -> Self {
    DepthwiseConv2DOptions { _tab: table }
  }
  #[allow(unused_mut)]
  pub fn create<'bldr: 'args, 'args: 'mut_bldr, 'mut_bldr>(
    _fbb: &'mut_bldr mut flatbuffers::FlatBufferBuilder<'bldr>,
    args: &'args DepthwiseConv2DOptionsArgs
  ) -> flatbuffers::WIPOffset<DepthwiseConv2DOptions<'bldr>> {
    let mut builder = DepthwiseConv2DOptionsBuilder::new(_fbb);
    builder.add_dilation_h_factor(args.dilation_h_factor);
    builder.add_dilation_w_factor(args.dilation_w_factor);
    builder.add_depth_multiplier(args.depth_multiplier);
    builder.add_stride_h(args.stride_h);
    builder.add_stride_w(args.stride_w);
    builder.add_fused_activation_function(args.fused_activation_function);
    builder.add_padding(args.padding);
    builder.finish()
  }

  pub fn unpack(&self) -> DepthwiseConv2DOptionsT {
    let padding = self.padding();
    let stride_w = self.stride_w();
    let stride_h = self.stride_h();
    let depth_multiplier = self.depth_multiplier();
    let fused_activation_function = self.fused_activation_function();
    let dilation_w_factor = self.dilation_w_factor();
    let dilation_h_factor = self.dilation_h_factor();
    DepthwiseConv2DOptionsT {
      padding,
      stride_w,
      stride_h,
      depth_multiplier,
      fused_activation_function,
      dilation_w_factor,
      dilation_h_factor,
    }
  }

  #[inline]
  pub fn padding(&self) -> Padding {
    self._tab.get::<Padding>(DepthwiseConv2DOptions::VT_PADDING, Some(Padding::SAME)).unwrap()
  }
  #[inline]
  pub fn stride_w(&self) -> i32 {
    self._tab.get::<i32>(DepthwiseConv2DOptions::VT_STRIDE_W, Some(0)).unwrap()
  }
  #[inline]
  pub fn stride_h(&self) -> i32 {
    self._tab.get::<i32>(DepthwiseConv2DOptions::VT_STRIDE_H, Some(0)).unwrap()
  }
  #[inline]
  pub fn depth_multiplier(&self) -> i32 {
    self._tab.get::<i32>(DepthwiseConv2DOptions::VT_DEPTH_MULTIPLIER, Some(0)).unwrap()
  }
  #[inline]
  pub fn fused_activation_function(&self) -> ActivationFunctionType {
    self._tab.get::<ActivationFunctionType>(DepthwiseConv2DOptions::VT_FUSED_ACTIVATION_FUNCTION, Some(ActivationFunctionType::NONE)).unwrap()
  }
  #[inline]
  pub fn dilation_w_factor(&self) -> i32 {
    self._tab.get::<i32>(DepthwiseConv2DOptions::VT_DILATION_W_FACTOR, Some(1)).unwrap()
  }
  #[inline]
  pub fn dilation_h_factor(&self) -> i32 {
    self._tab.get::<i32>(DepthwiseConv2DOptions::VT_DILATION_H_FACTOR, Some(1)).unwrap()
  }
}

impl flatbuffers::Verifiable for DepthwiseConv2DOptions<'_> {
  #[inline]
  fn run_verifier(
    v: &mut flatbuffers::Verifier, pos: usize
  ) -> Result<(), flatbuffers::InvalidFlatbuffer> {
    use self::flatbuffers::Verifiable;
    v.visit_table(pos)?
     .visit_field::<Padding>("padding", Self::VT_PADDING, false)?
     .visit_field::<i32>("stride_w", Self::VT_STRIDE_W, false)?
     .visit_field::<i32>("stride_h", Self::VT_STRIDE_H, false)?
     .visit_field::<i32>("depth_multiplier", Self::VT_DEPTH_MULTIPLIER, false)?
     .visit_field::<ActivationFunctionType>("fused_activation_function", Self::VT_FUSED_ACTIVATION_FUNCTION, false)?
     .visit_field::<i32>("dilation_w_factor", Self::VT_DILATION_W_FACTOR, false)?
     .visit_field::<i32>("dilation_h_factor", Self::VT_DILATION_H_FACTOR, false)?
     .finish();
    Ok(())
  }
}
pub struct DepthwiseConv2DOptionsArgs {
    pub padding: Padding,
    pub stride_w: i32,
    pub stride_h: i32,
    pub depth_multiplier: i32,
    pub fused_activation_function: ActivationFunctionType,
    pub dilation_w_factor: i32,
    pub dilation_h_factor: i32,
}
impl<'a> Default for DepthwiseConv2DOptionsArgs {
  #[inline]
  fn default() -> Self {
    DepthwiseConv2DOptionsArgs {
      padding: Padding::SAME,
      stride_w: 0,
      stride_h: 0,
      depth_multiplier: 0,
      fused_activation_function: ActivationFunctionType::NONE,
      dilation_w_factor: 1,
      dilation_h_factor: 1,
    }
  }
}

pub struct DepthwiseConv2DOptionsBuilder<'a: 'b, 'b> {
  fbb_: &'b mut flatbuffers::FlatBufferBuilder<'a>,
  start_: flatbuffers::WIPOffset<flatbuffers::TableUnfinishedWIPOffset>,
}
impl<'a: 'b, 'b> DepthwiseConv2DOptionsBuilder<'a, 'b> {
  #[inline]
  pub fn add_padding(&mut self, padding: Padding) {
    self.fbb_.push_slot::<Padding>(DepthwiseConv2DOptions::VT_PADDING, padding, Padding::SAME);
  }
  #[inline]
  pub fn add_stride_w(&mut self, stride_w: i32) {
    self.fbb_.push_slot::<i32>(DepthwiseConv2DOptions::VT_STRIDE_W, stride_w, 0);
  }
  #[inline]
  pub fn add_stride_h(&mut self, stride_h: i32) {
    self.fbb_.push_slot::<i32>(DepthwiseConv2DOptions::VT_STRIDE_H, stride_h, 0);
  }
  #[inline]
  pub fn add_depth_multiplier(&mut self, depth_multiplier: i32) {
    self.fbb_.push_slot::<i32>(DepthwiseConv2DOptions::VT_DEPTH_MULTIPLIER, depth_multiplier, 0);
  }
  #[inline]
  pub fn add_fused_activation_function(&mut self, fused_activation_function: ActivationFunctionType) {
    self.fbb_.push_slot::<ActivationFunctionType>(DepthwiseConv2DOptions::VT_FUSED_ACTIVATION_FUNCTION, fused_activation_function, ActivationFunctionType::NONE);
  }
  #[inline]
  pub fn add_dilation_w_factor(&mut self, dilation_w_factor: i32) {
    self.fbb_.push_slot::<i32>(DepthwiseConv2DOptions::VT_DILATION_W_FACTOR, dilation_w_factor, 1);
  }
  #[inline]
  pub fn add_dilation_h_factor(&mut self, dilation_h_factor: i32) {
    self.fbb_.push_slot::<i32>(DepthwiseConv2DOptions::VT_DILATION_H_FACTOR, dilation_h_factor, 1);
  }
  #[inline]
  pub fn new(_fbb: &'b mut flatbuffers::FlatBufferBuilder<'a>) -> DepthwiseConv2DOptionsBuilder<'a, 'b> {
    let start = _fbb.start_table();
    DepthwiseConv2DOptionsBuilder {
      fbb_: _fbb,
      start_: start,
    }
  }
  #[inline]
  pub fn finish(self) -> flatbuffers::WIPOffset<DepthwiseConv2DOptions<'a>> {
    let o = self.fbb_.end_table(self.start_);
    flatbuffers::WIPOffset::new(o.value())
  }
}

impl core::fmt::Debug for DepthwiseConv2DOptions<'_> {
  fn fmt(&self, f: &mut core::fmt::Formatter<'_>) -> core::fmt::Result {
    let mut ds = f.debug_struct("DepthwiseConv2DOptions");
      ds.field("padding", &self.padding());
      ds.field("stride_w", &self.stride_w());
      ds.field("stride_h", &self.stride_h());
      ds.field("depth_multiplier", &self.depth_multiplier());
      ds.field("fused_activation_function", &self.fused_activation_function());
      ds.field("dilation_w_factor", &self.dilation_w_factor());
      ds.field("dilation_h_factor", &self.dilation_h_factor());
      ds.finish()
  }
}
#[non_exhaustive]
#[derive(Debug, Clone, PartialEq)]
pub struct DepthwiseConv2DOptionsT {
  pub padding: Padding,
  pub stride_w: i32,
  pub stride_h: i32,
  pub depth_multiplier: i32,
  pub fused_activation_function: ActivationFunctionType,
  pub dilation_w_factor: i32,
  pub dilation_h_factor: i32,
}
impl Default for DepthwiseConv2DOptionsT {
  fn default() -> Self {
    Self {
      padding: Padding::SAME,
      stride_w: 0,
      stride_h: 0,
      depth_multiplier: 0,
      fused_activation_function: ActivationFunctionType::NONE,
      dilation_w_factor: 1,
      dilation_h_factor: 1,
    }
  }
}
impl DepthwiseConv2DOptionsT {
  pub fn pack<'b>(
    &self,
    _fbb: &mut flatbuffers::FlatBufferBuilder<'b>
  ) -> flatbuffers::WIPOffset<DepthwiseConv2DOptions<'b>> {
    let padding = self.padding;
    let stride_w = self.stride_w;
    let stride_h = self.stride_h;
    let depth_multiplier = self.depth_multiplier;
    let fused_activation_function = self.fused_activation_function;
    let dilation_w_factor = self.dilation_w_factor;
    let dilation_h_factor = self.dilation_h_factor;
    DepthwiseConv2DOptions::create(_fbb, &DepthwiseConv2DOptionsArgs{
      padding,
      stride_w,
      stride_h,
      depth_multiplier,
      fused_activation_function,
      dilation_w_factor,
      dilation_h_factor,
    })
  }
}
pub enum ConcatEmbeddingsOptionsOffset {}
#[derive(Copy, Clone, PartialEq)]

pub struct ConcatEmbeddingsOptions<'a> {
  pub _tab: flatbuffers::Table<'a>,
}

impl<'a> flatbuffers::Follow<'a> for ConcatEmbeddingsOptions<'a> {
  type Inner = ConcatEmbeddingsOptions<'a>;
  #[inline]
  fn follow(buf: &'a [u8], loc: usize) -> Self::Inner {
    Self { _tab: flatbuffers::Table { buf, loc } }
  }
}

impl<'a> ConcatEmbeddingsOptions<'a> {
  pub const VT_NUM_CHANNELS: flatbuffers::VOffsetT = 4;
  pub const VT_NUM_COLUMNS_PER_CHANNEL: flatbuffers::VOffsetT = 6;
  pub const VT_EMBEDDING_DIM_PER_CHANNEL: flatbuffers::VOffsetT = 8;

  #[inline]
  pub fn init_from_table(table: flatbuffers::Table<'a>) -> Self {
    ConcatEmbeddingsOptions { _tab: table }
  }
  #[allow(unused_mut)]
  pub fn create<'bldr: 'args, 'args: 'mut_bldr, 'mut_bldr>(
    _fbb: &'mut_bldr mut flatbuffers::FlatBufferBuilder<'bldr>,
    args: &'args ConcatEmbeddingsOptionsArgs<'args>
  ) -> flatbuffers::WIPOffset<ConcatEmbeddingsOptions<'bldr>> {
    let mut builder = ConcatEmbeddingsOptionsBuilder::new(_fbb);
    if let Some(x) = args.embedding_dim_per_channel { builder.add_embedding_dim_per_channel(x); }
    if let Some(x) = args.num_columns_per_channel { builder.add_num_columns_per_channel(x); }
    builder.add_num_channels(args.num_channels);
    builder.finish()
  }

  pub fn unpack(&self) -> ConcatEmbeddingsOptionsT {
    let num_channels = self.num_channels();
    let num_columns_per_channel = self.num_columns_per_channel().map(|x| {
      x.into_iter().collect()
    });
    let embedding_dim_per_channel = self.embedding_dim_per_channel().map(|x| {
      x.into_iter().collect()
    });
    ConcatEmbeddingsOptionsT {
      num_channels,
      num_columns_per_channel,
      embedding_dim_per_channel,
    }
  }

  #[inline]
  pub fn num_channels(&self) -> i32 {
    self._tab.get::<i32>(ConcatEmbeddingsOptions::VT_NUM_CHANNELS, Some(0)).unwrap()
  }
  #[inline]
  pub fn num_columns_per_channel(&self) -> Option<flatbuffers::Vector<'a, i32>> {
    self._tab.get::<flatbuffers::ForwardsUOffset<flatbuffers::Vector<'a, i32>>>(ConcatEmbeddingsOptions::VT_NUM_COLUMNS_PER_CHANNEL, None)
  }
  #[inline]
  pub fn embedding_dim_per_channel(&self) -> Option<flatbuffers::Vector<'a, i32>> {
    self._tab.get::<flatbuffers::ForwardsUOffset<flatbuffers::Vector<'a, i32>>>(ConcatEmbeddingsOptions::VT_EMBEDDING_DIM_PER_CHANNEL, None)
  }
}

impl flatbuffers::Verifiable for ConcatEmbeddingsOptions<'_> {
  #[inline]
  fn run_verifier(
    v: &mut flatbuffers::Verifier, pos: usize
  ) -> Result<(), flatbuffers::InvalidFlatbuffer> {
    use self::flatbuffers::Verifiable;
    v.visit_table(pos)?
     .visit_field::<i32>("num_channels", Self::VT_NUM_CHANNELS, false)?
     .visit_field::<flatbuffers::ForwardsUOffset<flatbuffers::Vector<'_, i32>>>("num_columns_per_channel", Self::VT_NUM_COLUMNS_PER_CHANNEL, false)?
     .visit_field::<flatbuffers::ForwardsUOffset<flatbuffers::Vector<'_, i32>>>("embedding_dim_per_channel", Self::VT_EMBEDDING_DIM_PER_CHANNEL, false)?
     .finish();
    Ok(())
  }
}
pub struct ConcatEmbeddingsOptionsArgs<'a> {
    pub num_channels: i32,
    pub num_columns_per_channel: Option<flatbuffers::WIPOffset<flatbuffers::Vector<'a, i32>>>,
    pub embedding_dim_per_channel: Option<flatbuffers::WIPOffset<flatbuffers::Vector<'a, i32>>>,
}
impl<'a> Default for ConcatEmbeddingsOptionsArgs<'a> {
  #[inline]
  fn default() -> Self {
    ConcatEmbeddingsOptionsArgs {
      num_channels: 0,
      num_columns_per_channel: None,
      embedding_dim_per_channel: None,
    }
  }
}

pub struct ConcatEmbeddingsOptionsBuilder<'a: 'b, 'b> {
  fbb_: &'b mut flatbuffers::FlatBufferBuilder<'a>,
  start_: flatbuffers::WIPOffset<flatbuffers::TableUnfinishedWIPOffset>,
}
impl<'a: 'b, 'b> ConcatEmbeddingsOptionsBuilder<'a, 'b> {
  #[inline]
  pub fn add_num_channels(&mut self, num_channels: i32) {
    self.fbb_.push_slot::<i32>(ConcatEmbeddingsOptions::VT_NUM_CHANNELS, num_channels, 0);
  }
  #[inline]
  pub fn add_num_columns_per_channel(&mut self, num_columns_per_channel: flatbuffers::WIPOffset<flatbuffers::Vector<'b , i32>>) {
    self.fbb_.push_slot_always::<flatbuffers::WIPOffset<_>>(ConcatEmbeddingsOptions::VT_NUM_COLUMNS_PER_CHANNEL, num_columns_per_channel);
  }
  #[inline]
  pub fn add_embedding_dim_per_channel(&mut self, embedding_dim_per_channel: flatbuffers::WIPOffset<flatbuffers::Vector<'b , i32>>) {
    self.fbb_.push_slot_always::<flatbuffers::WIPOffset<_>>(ConcatEmbeddingsOptions::VT_EMBEDDING_DIM_PER_CHANNEL, embedding_dim_per_channel);
  }
  #[inline]
  pub fn new(_fbb: &'b mut flatbuffers::FlatBufferBuilder<'a>) -> ConcatEmbeddingsOptionsBuilder<'a, 'b> {
    let start = _fbb.start_table();
    ConcatEmbeddingsOptionsBuilder {
      fbb_: _fbb,
      start_: start,
    }
  }
  #[inline]
  pub fn finish(self) -> flatbuffers::WIPOffset<ConcatEmbeddingsOptions<'a>> {
    let o = self.fbb_.end_table(self.start_);
    flatbuffers::WIPOffset::new(o.value())
  }
}

impl core::fmt::Debug for ConcatEmbeddingsOptions<'_> {
  fn fmt(&self, f: &mut core::fmt::Formatter<'_>) -> core::fmt::Result {
    let mut ds = f.debug_struct("ConcatEmbeddingsOptions");
      ds.field("num_channels", &self.num_channels());
      ds.field("num_columns_per_channel", &self.num_columns_per_channel());
      ds.field("embedding_dim_per_channel", &self.embedding_dim_per_channel());
      ds.finish()
  }
}
#[non_exhaustive]
#[derive(Debug, Clone, PartialEq)]
pub struct ConcatEmbeddingsOptionsT {
  pub num_channels: i32,
  pub num_columns_per_channel: Option<Vec<i32>>,
  pub embedding_dim_per_channel: Option<Vec<i32>>,
}
impl Default for ConcatEmbeddingsOptionsT {
  fn default() -> Self {
    Self {
      num_channels: 0,
      num_columns_per_channel: None,
      embedding_dim_per_channel: None,
    }
  }
}
impl ConcatEmbeddingsOptionsT {
  pub fn pack<'b>(
    &self,
    _fbb: &mut flatbuffers::FlatBufferBuilder<'b>
  ) -> flatbuffers::WIPOffset<ConcatEmbeddingsOptions<'b>> {
    let num_channels = self.num_channels;
    let num_columns_per_channel = self.num_columns_per_channel.as_ref().map(|x|{
      _fbb.create_vector(x)
    });
    let embedding_dim_per_channel = self.embedding_dim_per_channel.as_ref().map(|x|{
      _fbb.create_vector(x)
    });
    ConcatEmbeddingsOptions::create(_fbb, &ConcatEmbeddingsOptionsArgs{
      num_channels,
      num_columns_per_channel,
      embedding_dim_per_channel,
    })
  }
}
pub enum LSHProjectionOptionsOffset {}
#[derive(Copy, Clone, PartialEq)]

pub struct LSHProjectionOptions<'a> {
  pub _tab: flatbuffers::Table<'a>,
}

impl<'a> flatbuffers::Follow<'a> for LSHProjectionOptions<'a> {
  type Inner = LSHProjectionOptions<'a>;
  #[inline]
  fn follow(buf: &'a [u8], loc: usize) -> Self::Inner {
    Self { _tab: flatbuffers::Table { buf, loc } }
  }
}

impl<'a> LSHProjectionOptions<'a> {
  pub const VT_TYPE_: flatbuffers::VOffsetT = 4;

  #[inline]
  pub fn init_from_table(table: flatbuffers::Table<'a>) -> Self {
    LSHProjectionOptions { _tab: table }
  }
  #[allow(unused_mut)]
  pub fn create<'bldr: 'args, 'args: 'mut_bldr, 'mut_bldr>(
    _fbb: &'mut_bldr mut flatbuffers::FlatBufferBuilder<'bldr>,
    args: &'args LSHProjectionOptionsArgs
  ) -> flatbuffers::WIPOffset<LSHProjectionOptions<'bldr>> {
    let mut builder = LSHProjectionOptionsBuilder::new(_fbb);
    builder.add_type_(args.type_);
    builder.finish()
  }

  pub fn unpack(&self) -> LSHProjectionOptionsT {
    let type_ = self.type_();
    LSHProjectionOptionsT {
      type_,
    }
  }

  #[inline]
  pub fn type_(&self) -> LSHProjectionType {
    self._tab.get::<LSHProjectionType>(LSHProjectionOptions::VT_TYPE_, Some(LSHProjectionType::UNKNOWN)).unwrap()
  }
}

impl flatbuffers::Verifiable for LSHProjectionOptions<'_> {
  #[inline]
  fn run_verifier(
    v: &mut flatbuffers::Verifier, pos: usize
  ) -> Result<(), flatbuffers::InvalidFlatbuffer> {
    use self::flatbuffers::Verifiable;
    v.visit_table(pos)?
     .visit_field::<LSHProjectionType>("type_", Self::VT_TYPE_, false)?
     .finish();
    Ok(())
  }
}
pub struct LSHProjectionOptionsArgs {
    pub type_: LSHProjectionType,
}
impl<'a> Default for LSHProjectionOptionsArgs {
  #[inline]
  fn default() -> Self {
    LSHProjectionOptionsArgs {
      type_: LSHProjectionType::UNKNOWN,
    }
  }
}

pub struct LSHProjectionOptionsBuilder<'a: 'b, 'b> {
  fbb_: &'b mut flatbuffers::FlatBufferBuilder<'a>,
  start_: flatbuffers::WIPOffset<flatbuffers::TableUnfinishedWIPOffset>,
}
impl<'a: 'b, 'b> LSHProjectionOptionsBuilder<'a, 'b> {
  #[inline]
  pub fn add_type_(&mut self, type_: LSHProjectionType) {
    self.fbb_.push_slot::<LSHProjectionType>(LSHProjectionOptions::VT_TYPE_, type_, LSHProjectionType::UNKNOWN);
  }
  #[inline]
  pub fn new(_fbb: &'b mut flatbuffers::FlatBufferBuilder<'a>) -> LSHProjectionOptionsBuilder<'a, 'b> {
    let start = _fbb.start_table();
    LSHProjectionOptionsBuilder {
      fbb_: _fbb,
      start_: start,
    }
  }
  #[inline]
  pub fn finish(self) -> flatbuffers::WIPOffset<LSHProjectionOptions<'a>> {
    let o = self.fbb_.end_table(self.start_);
    flatbuffers::WIPOffset::new(o.value())
  }
}

impl core::fmt::Debug for LSHProjectionOptions<'_> {
  fn fmt(&self, f: &mut core::fmt::Formatter<'_>) -> core::fmt::Result {
    let mut ds = f.debug_struct("LSHProjectionOptions");
      ds.field("type_", &self.type_());
      ds.finish()
  }
}
#[non_exhaustive]
#[derive(Debug, Clone, PartialEq)]
pub struct LSHProjectionOptionsT {
  pub type_: LSHProjectionType,
}
impl Default for LSHProjectionOptionsT {
  fn default() -> Self {
    Self {
      type_: LSHProjectionType::UNKNOWN,
    }
  }
}
impl LSHProjectionOptionsT {
  pub fn pack<'b>(
    &self,
    _fbb: &mut flatbuffers::FlatBufferBuilder<'b>
  ) -> flatbuffers::WIPOffset<LSHProjectionOptions<'b>> {
    let type_ = self.type_;
    LSHProjectionOptions::create(_fbb, &LSHProjectionOptionsArgs{
      type_,
    })
  }
}
pub enum SVDFOptionsOffset {}
#[derive(Copy, Clone, PartialEq)]

pub struct SVDFOptions<'a> {
  pub _tab: flatbuffers::Table<'a>,
}

impl<'a> flatbuffers::Follow<'a> for SVDFOptions<'a> {
  type Inner = SVDFOptions<'a>;
  #[inline]
  fn follow(buf: &'a [u8], loc: usize) -> Self::Inner {
    Self { _tab: flatbuffers::Table { buf, loc } }
  }
}

impl<'a> SVDFOptions<'a> {
  pub const VT_RANK: flatbuffers::VOffsetT = 4;
  pub const VT_FUSED_ACTIVATION_FUNCTION: flatbuffers::VOffsetT = 6;

  #[inline]
  pub fn init_from_table(table: flatbuffers::Table<'a>) -> Self {
    SVDFOptions { _tab: table }
  }
  #[allow(unused_mut)]
  pub fn create<'bldr: 'args, 'args: 'mut_bldr, 'mut_bldr>(
    _fbb: &'mut_bldr mut flatbuffers::FlatBufferBuilder<'bldr>,
    args: &'args SVDFOptionsArgs
  ) -> flatbuffers::WIPOffset<SVDFOptions<'bldr>> {
    let mut builder = SVDFOptionsBuilder::new(_fbb);
    builder.add_rank(args.rank);
    builder.add_fused_activation_function(args.fused_activation_function);
    builder.finish()
  }

  pub fn unpack(&self) -> SVDFOptionsT {
    let rank = self.rank();
    let fused_activation_function = self.fused_activation_function();
    SVDFOptionsT {
      rank,
      fused_activation_function,
    }
  }

  #[inline]
  pub fn rank(&self) -> i32 {
    self._tab.get::<i32>(SVDFOptions::VT_RANK, Some(0)).unwrap()
  }
  #[inline]
  pub fn fused_activation_function(&self) -> ActivationFunctionType {
    self._tab.get::<ActivationFunctionType>(SVDFOptions::VT_FUSED_ACTIVATION_FUNCTION, Some(ActivationFunctionType::NONE)).unwrap()
  }
}

impl flatbuffers::Verifiable for SVDFOptions<'_> {
  #[inline]
  fn run_verifier(
    v: &mut flatbuffers::Verifier, pos: usize
  ) -> Result<(), flatbuffers::InvalidFlatbuffer> {
    use self::flatbuffers::Verifiable;
    v.visit_table(pos)?
     .visit_field::<i32>("rank", Self::VT_RANK, false)?
     .visit_field::<ActivationFunctionType>("fused_activation_function", Self::VT_FUSED_ACTIVATION_FUNCTION, false)?
     .finish();
    Ok(())
  }
}
pub struct SVDFOptionsArgs {
    pub rank: i32,
    pub fused_activation_function: ActivationFunctionType,
}
impl<'a> Default for SVDFOptionsArgs {
  #[inline]
  fn default() -> Self {
    SVDFOptionsArgs {
      rank: 0,
      fused_activation_function: ActivationFunctionType::NONE,
    }
  }
}

pub struct SVDFOptionsBuilder<'a: 'b, 'b> {
  fbb_: &'b mut flatbuffers::FlatBufferBuilder<'a>,
  start_: flatbuffers::WIPOffset<flatbuffers::TableUnfinishedWIPOffset>,
}
impl<'a: 'b, 'b> SVDFOptionsBuilder<'a, 'b> {
  #[inline]
  pub fn add_rank(&mut self, rank: i32) {
    self.fbb_.push_slot::<i32>(SVDFOptions::VT_RANK, rank, 0);
  }
  #[inline]
  pub fn add_fused_activation_function(&mut self, fused_activation_function: ActivationFunctionType) {
    self.fbb_.push_slot::<ActivationFunctionType>(SVDFOptions::VT_FUSED_ACTIVATION_FUNCTION, fused_activation_function, ActivationFunctionType::NONE);
  }
  #[inline]
  pub fn new(_fbb: &'b mut flatbuffers::FlatBufferBuilder<'a>) -> SVDFOptionsBuilder<'a, 'b> {
    let start = _fbb.start_table();
    SVDFOptionsBuilder {
      fbb_: _fbb,
      start_: start,
    }
  }
  #[inline]
  pub fn finish(self) -> flatbuffers::WIPOffset<SVDFOptions<'a>> {
    let o = self.fbb_.end_table(self.start_);
    flatbuffers::WIPOffset::new(o.value())
  }
}

impl core::fmt::Debug for SVDFOptions<'_> {
  fn fmt(&self, f: &mut core::fmt::Formatter<'_>) -> core::fmt::Result {
    let mut ds = f.debug_struct("SVDFOptions");
      ds.field("rank", &self.rank());
      ds.field("fused_activation_function", &self.fused_activation_function());
      ds.finish()
  }
}
#[non_exhaustive]
#[derive(Debug, Clone, PartialEq)]
pub struct SVDFOptionsT {
  pub rank: i32,
  pub fused_activation_function: ActivationFunctionType,
}
impl Default for SVDFOptionsT {
  fn default() -> Self {
    Self {
      rank: 0,
      fused_activation_function: ActivationFunctionType::NONE,
    }
  }
}
impl SVDFOptionsT {
  pub fn pack<'b>(
    &self,
    _fbb: &mut flatbuffers::FlatBufferBuilder<'b>
  ) -> flatbuffers::WIPOffset<SVDFOptions<'b>> {
    let rank = self.rank;
    let fused_activation_function = self.fused_activation_function;
    SVDFOptions::create(_fbb, &SVDFOptionsArgs{
      rank,
      fused_activation_function,
    })
  }
}
pub enum RNNOptionsOffset {}
#[derive(Copy, Clone, PartialEq)]

pub struct RNNOptions<'a> {
  pub _tab: flatbuffers::Table<'a>,
}

impl<'a> flatbuffers::Follow<'a> for RNNOptions<'a> {
  type Inner = RNNOptions<'a>;
  #[inline]
  fn follow(buf: &'a [u8], loc: usize) -> Self::Inner {
    Self { _tab: flatbuffers::Table { buf, loc } }
  }
}

impl<'a> RNNOptions<'a> {
  pub const VT_FUSED_ACTIVATION_FUNCTION: flatbuffers::VOffsetT = 4;

  #[inline]
  pub fn init_from_table(table: flatbuffers::Table<'a>) -> Self {
    RNNOptions { _tab: table }
  }
  #[allow(unused_mut)]
  pub fn create<'bldr: 'args, 'args: 'mut_bldr, 'mut_bldr>(
    _fbb: &'mut_bldr mut flatbuffers::FlatBufferBuilder<'bldr>,
    args: &'args RNNOptionsArgs
  ) -> flatbuffers::WIPOffset<RNNOptions<'bldr>> {
    let mut builder = RNNOptionsBuilder::new(_fbb);
    builder.add_fused_activation_function(args.fused_activation_function);
    builder.finish()
  }

  pub fn unpack(&self) -> RNNOptionsT {
    let fused_activation_function = self.fused_activation_function();
    RNNOptionsT {
      fused_activation_function,
    }
  }

  #[inline]
  pub fn fused_activation_function(&self) -> ActivationFunctionType {
    self._tab.get::<ActivationFunctionType>(RNNOptions::VT_FUSED_ACTIVATION_FUNCTION, Some(ActivationFunctionType::NONE)).unwrap()
  }
}

impl flatbuffers::Verifiable for RNNOptions<'_> {
  #[inline]
  fn run_verifier(
    v: &mut flatbuffers::Verifier, pos: usize
  ) -> Result<(), flatbuffers::InvalidFlatbuffer> {
    use self::flatbuffers::Verifiable;
    v.visit_table(pos)?
     .visit_field::<ActivationFunctionType>("fused_activation_function", Self::VT_FUSED_ACTIVATION_FUNCTION, false)?
     .finish();
    Ok(())
  }
}
pub struct RNNOptionsArgs {
    pub fused_activation_function: ActivationFunctionType,
}
impl<'a> Default for RNNOptionsArgs {
  #[inline]
  fn default() -> Self {
    RNNOptionsArgs {
      fused_activation_function: ActivationFunctionType::NONE,
    }
  }
}

pub struct RNNOptionsBuilder<'a: 'b, 'b> {
  fbb_: &'b mut flatbuffers::FlatBufferBuilder<'a>,
  start_: flatbuffers::WIPOffset<flatbuffers::TableUnfinishedWIPOffset>,
}
impl<'a: 'b, 'b> RNNOptionsBuilder<'a, 'b> {
  #[inline]
  pub fn add_fused_activation_function(&mut self, fused_activation_function: ActivationFunctionType) {
    self.fbb_.push_slot::<ActivationFunctionType>(RNNOptions::VT_FUSED_ACTIVATION_FUNCTION, fused_activation_function, ActivationFunctionType::NONE);
  }
  #[inline]
  pub fn new(_fbb: &'b mut flatbuffers::FlatBufferBuilder<'a>) -> RNNOptionsBuilder<'a, 'b> {
    let start = _fbb.start_table();
    RNNOptionsBuilder {
      fbb_: _fbb,
      start_: start,
    }
  }
  #[inline]
  pub fn finish(self) -> flatbuffers::WIPOffset<RNNOptions<'a>> {
    let o = self.fbb_.end_table(self.start_);
    flatbuffers::WIPOffset::new(o.value())
  }
}

impl core::fmt::Debug for RNNOptions<'_> {
  fn fmt(&self, f: &mut core::fmt::Formatter<'_>) -> core::fmt::Result {
    let mut ds = f.debug_struct("RNNOptions");
      ds.field("fused_activation_function", &self.fused_activation_function());
      ds.finish()
  }
}
#[non_exhaustive]
#[derive(Debug, Clone, PartialEq)]
pub struct RNNOptionsT {
  pub fused_activation_function: ActivationFunctionType,
}
impl Default for RNNOptionsT {
  fn default() -> Self {
    Self {
      fused_activation_function: ActivationFunctionType::NONE,
    }
  }
}
impl RNNOptionsT {
  pub fn pack<'b>(
    &self,
    _fbb: &mut flatbuffers::FlatBufferBuilder<'b>
  ) -> flatbuffers::WIPOffset<RNNOptions<'b>> {
    let fused_activation_function = self.fused_activation_function;
    RNNOptions::create(_fbb, &RNNOptionsArgs{
      fused_activation_function,
    })
  }
}
pub enum SequenceRNNOptionsOffset {}
#[derive(Copy, Clone, PartialEq)]

pub struct SequenceRNNOptions<'a> {
  pub _tab: flatbuffers::Table<'a>,
}

impl<'a> flatbuffers::Follow<'a> for SequenceRNNOptions<'a> {
  type Inner = SequenceRNNOptions<'a>;
  #[inline]
  fn follow(buf: &'a [u8], loc: usize) -> Self::Inner {
    Self { _tab: flatbuffers::Table { buf, loc } }
  }
}

impl<'a> SequenceRNNOptions<'a> {
  pub const VT_TIME_MAJOR: flatbuffers::VOffsetT = 4;
  pub const VT_FUSED_ACTIVATION_FUNCTION: flatbuffers::VOffsetT = 6;

  #[inline]
  pub fn init_from_table(table: flatbuffers::Table<'a>) -> Self {
    SequenceRNNOptions { _tab: table }
  }
  #[allow(unused_mut)]
  pub fn create<'bldr: 'args, 'args: 'mut_bldr, 'mut_bldr>(
    _fbb: &'mut_bldr mut flatbuffers::FlatBufferBuilder<'bldr>,
    args: &'args SequenceRNNOptionsArgs
  ) -> flatbuffers::WIPOffset<SequenceRNNOptions<'bldr>> {
    let mut builder = SequenceRNNOptionsBuilder::new(_fbb);
    builder.add_fused_activation_function(args.fused_activation_function);
    builder.add_time_major(args.time_major);
    builder.finish()
  }

  pub fn unpack(&self) -> SequenceRNNOptionsT {
    let time_major = self.time_major();
    let fused_activation_function = self.fused_activation_function();
    SequenceRNNOptionsT {
      time_major,
      fused_activation_function,
    }
  }

  #[inline]
  pub fn time_major(&self) -> bool {
    self._tab.get::<bool>(SequenceRNNOptions::VT_TIME_MAJOR, Some(false)).unwrap()
  }
  #[inline]
  pub fn fused_activation_function(&self) -> ActivationFunctionType {
    self._tab.get::<ActivationFunctionType>(SequenceRNNOptions::VT_FUSED_ACTIVATION_FUNCTION, Some(ActivationFunctionType::NONE)).unwrap()
  }
}

impl flatbuffers::Verifiable for SequenceRNNOptions<'_> {
  #[inline]
  fn run_verifier(
    v: &mut flatbuffers::Verifier, pos: usize
  ) -> Result<(), flatbuffers::InvalidFlatbuffer> {
    use self::flatbuffers::Verifiable;
    v.visit_table(pos)?
     .visit_field::<bool>("time_major", Self::VT_TIME_MAJOR, false)?
     .visit_field::<ActivationFunctionType>("fused_activation_function", Self::VT_FUSED_ACTIVATION_FUNCTION, false)?
     .finish();
    Ok(())
  }
}
pub struct SequenceRNNOptionsArgs {
    pub time_major: bool,
    pub fused_activation_function: ActivationFunctionType,
}
impl<'a> Default for SequenceRNNOptionsArgs {
  #[inline]
  fn default() -> Self {
    SequenceRNNOptionsArgs {
      time_major: false,
      fused_activation_function: ActivationFunctionType::NONE,
    }
  }
}

pub struct SequenceRNNOptionsBuilder<'a: 'b, 'b> {
  fbb_: &'b mut flatbuffers::FlatBufferBuilder<'a>,
  start_: flatbuffers::WIPOffset<flatbuffers::TableUnfinishedWIPOffset>,
}
impl<'a: 'b, 'b> SequenceRNNOptionsBuilder<'a, 'b> {
  #[inline]
  pub fn add_time_major(&mut self, time_major: bool) {
    self.fbb_.push_slot::<bool>(SequenceRNNOptions::VT_TIME_MAJOR, time_major, false);
  }
  #[inline]
  pub fn add_fused_activation_function(&mut self, fused_activation_function: ActivationFunctionType) {
    self.fbb_.push_slot::<ActivationFunctionType>(SequenceRNNOptions::VT_FUSED_ACTIVATION_FUNCTION, fused_activation_function, ActivationFunctionType::NONE);
  }
  #[inline]
  pub fn new(_fbb: &'b mut flatbuffers::FlatBufferBuilder<'a>) -> SequenceRNNOptionsBuilder<'a, 'b> {
    let start = _fbb.start_table();
    SequenceRNNOptionsBuilder {
      fbb_: _fbb,
      start_: start,
    }
  }
  #[inline]
  pub fn finish(self) -> flatbuffers::WIPOffset<SequenceRNNOptions<'a>> {
    let o = self.fbb_.end_table(self.start_);
    flatbuffers::WIPOffset::new(o.value())
  }
}

impl core::fmt::Debug for SequenceRNNOptions<'_> {
  fn fmt(&self, f: &mut core::fmt::Formatter<'_>) -> core::fmt::Result {
    let mut ds = f.debug_struct("SequenceRNNOptions");
      ds.field("time_major", &self.time_major());
      ds.field("fused_activation_function", &self.fused_activation_function());
      ds.finish()
  }
}
#[non_exhaustive]
#[derive(Debug, Clone, PartialEq)]
pub struct SequenceRNNOptionsT {
  pub time_major: bool,
  pub fused_activation_function: ActivationFunctionType,
}
impl Default for SequenceRNNOptionsT {
  fn default() -> Self {
    Self {
      time_major: false,
      fused_activation_function: ActivationFunctionType::NONE,
    }
  }
}
impl SequenceRNNOptionsT {
  pub fn pack<'b>(
    &self,
    _fbb: &mut flatbuffers::FlatBufferBuilder<'b>
  ) -> flatbuffers::WIPOffset<SequenceRNNOptions<'b>> {
    let time_major = self.time_major;
    let fused_activation_function = self.fused_activation_function;
    SequenceRNNOptions::create(_fbb, &SequenceRNNOptionsArgs{
      time_major,
      fused_activation_function,
    })
  }
}
pub enum BidirectionalSequenceRNNOptionsOffset {}
#[derive(Copy, Clone, PartialEq)]

pub struct BidirectionalSequenceRNNOptions<'a> {
  pub _tab: flatbuffers::Table<'a>,
}

impl<'a> flatbuffers::Follow<'a> for BidirectionalSequenceRNNOptions<'a> {
  type Inner = BidirectionalSequenceRNNOptions<'a>;
  #[inline]
  fn follow(buf: &'a [u8], loc: usize) -> Self::Inner {
    Self { _tab: flatbuffers::Table { buf, loc } }
  }
}

impl<'a> BidirectionalSequenceRNNOptions<'a> {
  pub const VT_TIME_MAJOR: flatbuffers::VOffsetT = 4;
  pub const VT_FUSED_ACTIVATION_FUNCTION: flatbuffers::VOffsetT = 6;
  pub const VT_MERGE_OUTPUTS: flatbuffers::VOffsetT = 8;

  #[inline]
  pub fn init_from_table(table: flatbuffers::Table<'a>) -> Self {
    BidirectionalSequenceRNNOptions { _tab: table }
  }
  #[allow(unused_mut)]
  pub fn create<'bldr: 'args, 'args: 'mut_bldr, 'mut_bldr>(
    _fbb: &'mut_bldr mut flatbuffers::FlatBufferBuilder<'bldr>,
    args: &'args BidirectionalSequenceRNNOptionsArgs
  ) -> flatbuffers::WIPOffset<BidirectionalSequenceRNNOptions<'bldr>> {
    let mut builder = BidirectionalSequenceRNNOptionsBuilder::new(_fbb);
    builder.add_merge_outputs(args.merge_outputs);
    builder.add_fused_activation_function(args.fused_activation_function);
    builder.add_time_major(args.time_major);
    builder.finish()
  }

  pub fn unpack(&self) -> BidirectionalSequenceRNNOptionsT {
    let time_major = self.time_major();
    let fused_activation_function = self.fused_activation_function();
    let merge_outputs = self.merge_outputs();
    BidirectionalSequenceRNNOptionsT {
      time_major,
      fused_activation_function,
      merge_outputs,
    }
  }

  #[inline]
  pub fn time_major(&self) -> bool {
    self._tab.get::<bool>(BidirectionalSequenceRNNOptions::VT_TIME_MAJOR, Some(false)).unwrap()
  }
  #[inline]
  pub fn fused_activation_function(&self) -> ActivationFunctionType {
    self._tab.get::<ActivationFunctionType>(BidirectionalSequenceRNNOptions::VT_FUSED_ACTIVATION_FUNCTION, Some(ActivationFunctionType::NONE)).unwrap()
  }
  #[inline]
  pub fn merge_outputs(&self) -> bool {
    self._tab.get::<bool>(BidirectionalSequenceRNNOptions::VT_MERGE_OUTPUTS, Some(false)).unwrap()
  }
}

impl flatbuffers::Verifiable for BidirectionalSequenceRNNOptions<'_> {
  #[inline]
  fn run_verifier(
    v: &mut flatbuffers::Verifier, pos: usize
  ) -> Result<(), flatbuffers::InvalidFlatbuffer> {
    use self::flatbuffers::Verifiable;
    v.visit_table(pos)?
     .visit_field::<bool>("time_major", Self::VT_TIME_MAJOR, false)?
     .visit_field::<ActivationFunctionType>("fused_activation_function", Self::VT_FUSED_ACTIVATION_FUNCTION, false)?
     .visit_field::<bool>("merge_outputs", Self::VT_MERGE_OUTPUTS, false)?
     .finish();
    Ok(())
  }
}
pub struct BidirectionalSequenceRNNOptionsArgs {
    pub time_major: bool,
    pub fused_activation_function: ActivationFunctionType,
    pub merge_outputs: bool,
}
impl<'a> Default for BidirectionalSequenceRNNOptionsArgs {
  #[inline]
  fn default() -> Self {
    BidirectionalSequenceRNNOptionsArgs {
      time_major: false,
      fused_activation_function: ActivationFunctionType::NONE,
      merge_outputs: false,
    }
  }
}

pub struct BidirectionalSequenceRNNOptionsBuilder<'a: 'b, 'b> {
  fbb_: &'b mut flatbuffers::FlatBufferBuilder<'a>,
  start_: flatbuffers::WIPOffset<flatbuffers::TableUnfinishedWIPOffset>,
}
impl<'a: 'b, 'b> BidirectionalSequenceRNNOptionsBuilder<'a, 'b> {
  #[inline]
  pub fn add_time_major(&mut self, time_major: bool) {
    self.fbb_.push_slot::<bool>(BidirectionalSequenceRNNOptions::VT_TIME_MAJOR, time_major, false);
  }
  #[inline]
  pub fn add_fused_activation_function(&mut self, fused_activation_function: ActivationFunctionType) {
    self.fbb_.push_slot::<ActivationFunctionType>(BidirectionalSequenceRNNOptions::VT_FUSED_ACTIVATION_FUNCTION, fused_activation_function, ActivationFunctionType::NONE);
  }
  #[inline]
  pub fn add_merge_outputs(&mut self, merge_outputs: bool) {
    self.fbb_.push_slot::<bool>(BidirectionalSequenceRNNOptions::VT_MERGE_OUTPUTS, merge_outputs, false);
  }
  #[inline]
  pub fn new(_fbb: &'b mut flatbuffers::FlatBufferBuilder<'a>) -> BidirectionalSequenceRNNOptionsBuilder<'a, 'b> {
    let start = _fbb.start_table();
    BidirectionalSequenceRNNOptionsBuilder {
      fbb_: _fbb,
      start_: start,
    }
  }
  #[inline]
  pub fn finish(self) -> flatbuffers::WIPOffset<BidirectionalSequenceRNNOptions<'a>> {
    let o = self.fbb_.end_table(self.start_);
    flatbuffers::WIPOffset::new(o.value())
  }
}

impl core::fmt::Debug for BidirectionalSequenceRNNOptions<'_> {
  fn fmt(&self, f: &mut core::fmt::Formatter<'_>) -> core::fmt::Result {
    let mut ds = f.debug_struct("BidirectionalSequenceRNNOptions");
      ds.field("time_major", &self.time_major());
      ds.field("fused_activation_function", &self.fused_activation_function());
      ds.field("merge_outputs", &self.merge_outputs());
      ds.finish()
  }
}
#[non_exhaustive]
#[derive(Debug, Clone, PartialEq)]
pub struct BidirectionalSequenceRNNOptionsT {
  pub time_major: bool,
  pub fused_activation_function: ActivationFunctionType,
  pub merge_outputs: bool,
}
impl Default for BidirectionalSequenceRNNOptionsT {
  fn default() -> Self {
    Self {
      time_major: false,
      fused_activation_function: ActivationFunctionType::NONE,
      merge_outputs: false,
    }
  }
}
impl BidirectionalSequenceRNNOptionsT {
  pub fn pack<'b>(
    &self,
    _fbb: &mut flatbuffers::FlatBufferBuilder<'b>
  ) -> flatbuffers::WIPOffset<BidirectionalSequenceRNNOptions<'b>> {
    let time_major = self.time_major;
    let fused_activation_function = self.fused_activation_function;
    let merge_outputs = self.merge_outputs;
    BidirectionalSequenceRNNOptions::create(_fbb, &BidirectionalSequenceRNNOptionsArgs{
      time_major,
      fused_activation_function,
      merge_outputs,
    })
  }
}
pub enum FullyConnectedOptionsOffset {}
#[derive(Copy, Clone, PartialEq)]

pub struct FullyConnectedOptions<'a> {
  pub _tab: flatbuffers::Table<'a>,
}

impl<'a> flatbuffers::Follow<'a> for FullyConnectedOptions<'a> {
  type Inner = FullyConnectedOptions<'a>;
  #[inline]
  fn follow(buf: &'a [u8], loc: usize) -> Self::Inner {
    Self { _tab: flatbuffers::Table { buf, loc } }
  }
}

impl<'a> FullyConnectedOptions<'a> {
  pub const VT_FUSED_ACTIVATION_FUNCTION: flatbuffers::VOffsetT = 4;
  pub const VT_WEIGHTS_FORMAT: flatbuffers::VOffsetT = 6;
  pub const VT_KEEP_NUM_DIMS: flatbuffers::VOffsetT = 8;

  #[inline]
  pub fn init_from_table(table: flatbuffers::Table<'a>) -> Self {
    FullyConnectedOptions { _tab: table }
  }
  #[allow(unused_mut)]
  pub fn create<'bldr: 'args, 'args: 'mut_bldr, 'mut_bldr>(
    _fbb: &'mut_bldr mut flatbuffers::FlatBufferBuilder<'bldr>,
    args: &'args FullyConnectedOptionsArgs
  ) -> flatbuffers::WIPOffset<FullyConnectedOptions<'bldr>> {
    let mut builder = FullyConnectedOptionsBuilder::new(_fbb);
    builder.add_keep_num_dims(args.keep_num_dims);
    builder.add_weights_format(args.weights_format);
    builder.add_fused_activation_function(args.fused_activation_function);
    builder.finish()
  }

  pub fn unpack(&self) -> FullyConnectedOptionsT {
    let fused_activation_function = self.fused_activation_function();
    let weights_format = self.weights_format();
    let keep_num_dims = self.keep_num_dims();
    FullyConnectedOptionsT {
      fused_activation_function,
      weights_format,
      keep_num_dims,
    }
  }

  #[inline]
  pub fn fused_activation_function(&self) -> ActivationFunctionType {
    self._tab.get::<ActivationFunctionType>(FullyConnectedOptions::VT_FUSED_ACTIVATION_FUNCTION, Some(ActivationFunctionType::NONE)).unwrap()
  }
  #[inline]
  pub fn weights_format(&self) -> FullyConnectedOptionsWeightsFormat {
    self._tab.get::<FullyConnectedOptionsWeightsFormat>(FullyConnectedOptions::VT_WEIGHTS_FORMAT, Some(FullyConnectedOptionsWeightsFormat::DEFAULT)).unwrap()
  }
  #[inline]
  pub fn keep_num_dims(&self) -> bool {
    self._tab.get::<bool>(FullyConnectedOptions::VT_KEEP_NUM_DIMS, Some(false)).unwrap()
  }
}

impl flatbuffers::Verifiable for FullyConnectedOptions<'_> {
  #[inline]
  fn run_verifier(
    v: &mut flatbuffers::Verifier, pos: usize
  ) -> Result<(), flatbuffers::InvalidFlatbuffer> {
    use self::flatbuffers::Verifiable;
    v.visit_table(pos)?
     .visit_field::<ActivationFunctionType>("fused_activation_function", Self::VT_FUSED_ACTIVATION_FUNCTION, false)?
     .visit_field::<FullyConnectedOptionsWeightsFormat>("weights_format", Self::VT_WEIGHTS_FORMAT, false)?
     .visit_field::<bool>("keep_num_dims", Self::VT_KEEP_NUM_DIMS, false)?
     .finish();
    Ok(())
  }
}
pub struct FullyConnectedOptionsArgs {
    pub fused_activation_function: ActivationFunctionType,
    pub weights_format: FullyConnectedOptionsWeightsFormat,
    pub keep_num_dims: bool,
}
impl<'a> Default for FullyConnectedOptionsArgs {
  #[inline]
  fn default() -> Self {
    FullyConnectedOptionsArgs {
      fused_activation_function: ActivationFunctionType::NONE,
      weights_format: FullyConnectedOptionsWeightsFormat::DEFAULT,
      keep_num_dims: false,
    }
  }
}

pub struct FullyConnectedOptionsBuilder<'a: 'b, 'b> {
  fbb_: &'b mut flatbuffers::FlatBufferBuilder<'a>,
  start_: flatbuffers::WIPOffset<flatbuffers::TableUnfinishedWIPOffset>,
}
impl<'a: 'b, 'b> FullyConnectedOptionsBuilder<'a, 'b> {
  #[inline]
  pub fn add_fused_activation_function(&mut self, fused_activation_function: ActivationFunctionType) {
    self.fbb_.push_slot::<ActivationFunctionType>(FullyConnectedOptions::VT_FUSED_ACTIVATION_FUNCTION, fused_activation_function, ActivationFunctionType::NONE);
  }
  #[inline]
  pub fn add_weights_format(&mut self, weights_format: FullyConnectedOptionsWeightsFormat) {
    self.fbb_.push_slot::<FullyConnectedOptionsWeightsFormat>(FullyConnectedOptions::VT_WEIGHTS_FORMAT, weights_format, FullyConnectedOptionsWeightsFormat::DEFAULT);
  }
  #[inline]
  pub fn add_keep_num_dims(&mut self, keep_num_dims: bool) {
    self.fbb_.push_slot::<bool>(FullyConnectedOptions::VT_KEEP_NUM_DIMS, keep_num_dims, false);
  }
  #[inline]
  pub fn new(_fbb: &'b mut flatbuffers::FlatBufferBuilder<'a>) -> FullyConnectedOptionsBuilder<'a, 'b> {
    let start = _fbb.start_table();
    FullyConnectedOptionsBuilder {
      fbb_: _fbb,
      start_: start,
    }
  }
  #[inline]
  pub fn finish(self) -> flatbuffers::WIPOffset<FullyConnectedOptions<'a>> {
    let o = self.fbb_.end_table(self.start_);
    flatbuffers::WIPOffset::new(o.value())
  }
}

impl core::fmt::Debug for FullyConnectedOptions<'_> {
  fn fmt(&self, f: &mut core::fmt::Formatter<'_>) -> core::fmt::Result {
    let mut ds = f.debug_struct("FullyConnectedOptions");
      ds.field("fused_activation_function", &self.fused_activation_function());
      ds.field("weights_format", &self.weights_format());
      ds.field("keep_num_dims", &self.keep_num_dims());
      ds.finish()
  }
}
#[non_exhaustive]
#[derive(Debug, Clone, PartialEq)]
pub struct FullyConnectedOptionsT {
  pub fused_activation_function: ActivationFunctionType,
  pub weights_format: FullyConnectedOptionsWeightsFormat,
  pub keep_num_dims: bool,
}
impl Default for FullyConnectedOptionsT {
  fn default() -> Self {
    Self {
      fused_activation_function: ActivationFunctionType::NONE,
      weights_format: FullyConnectedOptionsWeightsFormat::DEFAULT,
      keep_num_dims: false,
    }
  }
}
impl FullyConnectedOptionsT {
  pub fn pack<'b>(
    &self,
    _fbb: &mut flatbuffers::FlatBufferBuilder<'b>
  ) -> flatbuffers::WIPOffset<FullyConnectedOptions<'b>> {
    let fused_activation_function = self.fused_activation_function;
    let weights_format = self.weights_format;
    let keep_num_dims = self.keep_num_dims;
    FullyConnectedOptions::create(_fbb, &FullyConnectedOptionsArgs{
      fused_activation_function,
      weights_format,
      keep_num_dims,
    })
  }
}
pub enum SoftmaxOptionsOffset {}
#[derive(Copy, Clone, PartialEq)]

pub struct SoftmaxOptions<'a> {
  pub _tab: flatbuffers::Table<'a>,
}

impl<'a> flatbuffers::Follow<'a> for SoftmaxOptions<'a> {
  type Inner = SoftmaxOptions<'a>;
  #[inline]
  fn follow(buf: &'a [u8], loc: usize) -> Self::Inner {
    Self { _tab: flatbuffers::Table { buf, loc } }
  }
}

impl<'a> SoftmaxOptions<'a> {
  pub const VT_BETA: flatbuffers::VOffsetT = 4;

  #[inline]
  pub fn init_from_table(table: flatbuffers::Table<'a>) -> Self {
    SoftmaxOptions { _tab: table }
  }
  #[allow(unused_mut)]
  pub fn create<'bldr: 'args, 'args: 'mut_bldr, 'mut_bldr>(
    _fbb: &'mut_bldr mut flatbuffers::FlatBufferBuilder<'bldr>,
    args: &'args SoftmaxOptionsArgs
  ) -> flatbuffers::WIPOffset<SoftmaxOptions<'bldr>> {
    let mut builder = SoftmaxOptionsBuilder::new(_fbb);
    builder.add_beta(args.beta);
    builder.finish()
  }

  pub fn unpack(&self) -> SoftmaxOptionsT {
    let beta = self.beta();
    SoftmaxOptionsT {
      beta,
    }
  }

  #[inline]
  pub fn beta(&self) -> f32 {
    self._tab.get::<f32>(SoftmaxOptions::VT_BETA, Some(0.0)).unwrap()
  }
}

impl flatbuffers::Verifiable for SoftmaxOptions<'_> {
  #[inline]
  fn run_verifier(
    v: &mut flatbuffers::Verifier, pos: usize
  ) -> Result<(), flatbuffers::InvalidFlatbuffer> {
    use self::flatbuffers::Verifiable;
    v.visit_table(pos)?
     .visit_field::<f32>("beta", Self::VT_BETA, false)?
     .finish();
    Ok(())
  }
}
pub struct SoftmaxOptionsArgs {
    pub beta: f32,
}
impl<'a> Default for SoftmaxOptionsArgs {
  #[inline]
  fn default() -> Self {
    SoftmaxOptionsArgs {
      beta: 0.0,
    }
  }
}

pub struct SoftmaxOptionsBuilder<'a: 'b, 'b> {
  fbb_: &'b mut flatbuffers::FlatBufferBuilder<'a>,
  start_: flatbuffers::WIPOffset<flatbuffers::TableUnfinishedWIPOffset>,
}
impl<'a: 'b, 'b> SoftmaxOptionsBuilder<'a, 'b> {
  #[inline]
  pub fn add_beta(&mut self, beta: f32) {
    self.fbb_.push_slot::<f32>(SoftmaxOptions::VT_BETA, beta, 0.0);
  }
  #[inline]
  pub fn new(_fbb: &'b mut flatbuffers::FlatBufferBuilder<'a>) -> SoftmaxOptionsBuilder<'a, 'b> {
    let start = _fbb.start_table();
    SoftmaxOptionsBuilder {
      fbb_: _fbb,
      start_: start,
    }
  }
  #[inline]
  pub fn finish(self) -> flatbuffers::WIPOffset<SoftmaxOptions<'a>> {
    let o = self.fbb_.end_table(self.start_);
    flatbuffers::WIPOffset::new(o.value())
  }
}

impl core::fmt::Debug for SoftmaxOptions<'_> {
  fn fmt(&self, f: &mut core::fmt::Formatter<'_>) -> core::fmt::Result {
    let mut ds = f.debug_struct("SoftmaxOptions");
      ds.field("beta", &self.beta());
      ds.finish()
  }
}
#[non_exhaustive]
#[derive(Debug, Clone, PartialEq)]
pub struct SoftmaxOptionsT {
  pub beta: f32,
}
impl Default for SoftmaxOptionsT {
  fn default() -> Self {
    Self {
      beta: 0.0,
    }
  }
}
impl SoftmaxOptionsT {
  pub fn pack<'b>(
    &self,
    _fbb: &mut flatbuffers::FlatBufferBuilder<'b>
  ) -> flatbuffers::WIPOffset<SoftmaxOptions<'b>> {
    let beta = self.beta;
    SoftmaxOptions::create(_fbb, &SoftmaxOptionsArgs{
      beta,
    })
  }
}
pub enum ConcatenationOptionsOffset {}
#[derive(Copy, Clone, PartialEq)]

pub struct ConcatenationOptions<'a> {
  pub _tab: flatbuffers::Table<'a>,
}

impl<'a> flatbuffers::Follow<'a> for ConcatenationOptions<'a> {
  type Inner = ConcatenationOptions<'a>;
  #[inline]
  fn follow(buf: &'a [u8], loc: usize) -> Self::Inner {
    Self { _tab: flatbuffers::Table { buf, loc } }
  }
}

impl<'a> ConcatenationOptions<'a> {
  pub const VT_AXIS: flatbuffers::VOffsetT = 4;
  pub const VT_FUSED_ACTIVATION_FUNCTION: flatbuffers::VOffsetT = 6;

  #[inline]
  pub fn init_from_table(table: flatbuffers::Table<'a>) -> Self {
    ConcatenationOptions { _tab: table }
  }
  #[allow(unused_mut)]
  pub fn create<'bldr: 'args, 'args: 'mut_bldr, 'mut_bldr>(
    _fbb: &'mut_bldr mut flatbuffers::FlatBufferBuilder<'bldr>,
    args: &'args ConcatenationOptionsArgs
  ) -> flatbuffers::WIPOffset<ConcatenationOptions<'bldr>> {
    let mut builder = ConcatenationOptionsBuilder::new(_fbb);
    builder.add_axis(args.axis);
    builder.add_fused_activation_function(args.fused_activation_function);
    builder.finish()
  }

  pub fn unpack(&self) -> ConcatenationOptionsT {
    let axis = self.axis();
    let fused_activation_function = self.fused_activation_function();
    ConcatenationOptionsT {
      axis,
      fused_activation_function,
    }
  }

  #[inline]
  pub fn axis(&self) -> i32 {
    self._tab.get::<i32>(ConcatenationOptions::VT_AXIS, Some(0)).unwrap()
  }
  #[inline]
  pub fn fused_activation_function(&self) -> ActivationFunctionType {
    self._tab.get::<ActivationFunctionType>(ConcatenationOptions::VT_FUSED_ACTIVATION_FUNCTION, Some(ActivationFunctionType::NONE)).unwrap()
  }
}

impl flatbuffers::Verifiable for ConcatenationOptions<'_> {
  #[inline]
  fn run_verifier(
    v: &mut flatbuffers::Verifier, pos: usize
  ) -> Result<(), flatbuffers::InvalidFlatbuffer> {
    use self::flatbuffers::Verifiable;
    v.visit_table(pos)?
     .visit_field::<i32>("axis", Self::VT_AXIS, false)?
     .visit_field::<ActivationFunctionType>("fused_activation_function", Self::VT_FUSED_ACTIVATION_FUNCTION, false)?
     .finish();
    Ok(())
  }
}
pub struct ConcatenationOptionsArgs {
    pub axis: i32,
    pub fused_activation_function: ActivationFunctionType,
}
impl<'a> Default for ConcatenationOptionsArgs {
  #[inline]
  fn default() -> Self {
    ConcatenationOptionsArgs {
      axis: 0,
      fused_activation_function: ActivationFunctionType::NONE,
    }
  }
}

pub struct ConcatenationOptionsBuilder<'a: 'b, 'b> {
  fbb_: &'b mut flatbuffers::FlatBufferBuilder<'a>,
  start_: flatbuffers::WIPOffset<flatbuffers::TableUnfinishedWIPOffset>,
}
impl<'a: 'b, 'b> ConcatenationOptionsBuilder<'a, 'b> {
  #[inline]
  pub fn add_axis(&mut self, axis: i32) {
    self.fbb_.push_slot::<i32>(ConcatenationOptions::VT_AXIS, axis, 0);
  }
  #[inline]
  pub fn add_fused_activation_function(&mut self, fused_activation_function: ActivationFunctionType) {
    self.fbb_.push_slot::<ActivationFunctionType>(ConcatenationOptions::VT_FUSED_ACTIVATION_FUNCTION, fused_activation_function, ActivationFunctionType::NONE);
  }
  #[inline]
  pub fn new(_fbb: &'b mut flatbuffers::FlatBufferBuilder<'a>) -> ConcatenationOptionsBuilder<'a, 'b> {
    let start = _fbb.start_table();
    ConcatenationOptionsBuilder {
      fbb_: _fbb,
      start_: start,
    }
  }
  #[inline]
  pub fn finish(self) -> flatbuffers::WIPOffset<ConcatenationOptions<'a>> {
    let o = self.fbb_.end_table(self.start_);
    flatbuffers::WIPOffset::new(o.value())
  }
}

impl core::fmt::Debug for ConcatenationOptions<'_> {
  fn fmt(&self, f: &mut core::fmt::Formatter<'_>) -> core::fmt::Result {
    let mut ds = f.debug_struct("ConcatenationOptions");
      ds.field("axis", &self.axis());
      ds.field("fused_activation_function", &self.fused_activation_function());
      ds.finish()
  }
}
#[non_exhaustive]
#[derive(Debug, Clone, PartialEq)]
pub struct ConcatenationOptionsT {
  pub axis: i32,
  pub fused_activation_function: ActivationFunctionType,
}
impl Default for ConcatenationOptionsT {
  fn default() -> Self {
    Self {
      axis: 0,
      fused_activation_function: ActivationFunctionType::NONE,
    }
  }
}
impl ConcatenationOptionsT {
  pub fn pack<'b>(
    &self,
    _fbb: &mut flatbuffers::FlatBufferBuilder<'b>
  ) -> flatbuffers::WIPOffset<ConcatenationOptions<'b>> {
    let axis = self.axis;
    let fused_activation_function = self.fused_activation_function;
    ConcatenationOptions::create(_fbb, &ConcatenationOptionsArgs{
      axis,
      fused_activation_function,
    })
  }
}
pub enum AddOptionsOffset {}
#[derive(Copy, Clone, PartialEq)]

pub struct AddOptions<'a> {
  pub _tab: flatbuffers::Table<'a>,
}

impl<'a> flatbuffers::Follow<'a> for AddOptions<'a> {
  type Inner = AddOptions<'a>;
  #[inline]
  fn follow(buf: &'a [u8], loc: usize) -> Self::Inner {
    Self { _tab: flatbuffers::Table { buf, loc } }
  }
}

impl<'a> AddOptions<'a> {
  pub const VT_FUSED_ACTIVATION_FUNCTION: flatbuffers::VOffsetT = 4;

  #[inline]
  pub fn init_from_table(table: flatbuffers::Table<'a>) -> Self {
    AddOptions { _tab: table }
  }
  #[allow(unused_mut)]
  pub fn create<'bldr: 'args, 'args: 'mut_bldr, 'mut_bldr>(
    _fbb: &'mut_bldr mut flatbuffers::FlatBufferBuilder<'bldr>,
    args: &'args AddOptionsArgs
  ) -> flatbuffers::WIPOffset<AddOptions<'bldr>> {
    let mut builder = AddOptionsBuilder::new(_fbb);
    builder.add_fused_activation_function(args.fused_activation_function);
    builder.finish()
  }

  pub fn unpack(&self) -> AddOptionsT {
    let fused_activation_function = self.fused_activation_function();
    AddOptionsT {
      fused_activation_function,
    }
  }

  #[inline]
  pub fn fused_activation_function(&self) -> ActivationFunctionType {
    self._tab.get::<ActivationFunctionType>(AddOptions::VT_FUSED_ACTIVATION_FUNCTION, Some(ActivationFunctionType::NONE)).unwrap()
  }
}

impl flatbuffers::Verifiable for AddOptions<'_> {
  #[inline]
  fn run_verifier(
    v: &mut flatbuffers::Verifier, pos: usize
  ) -> Result<(), flatbuffers::InvalidFlatbuffer> {
    use self::flatbuffers::Verifiable;
    v.visit_table(pos)?
     .visit_field::<ActivationFunctionType>("fused_activation_function", Self::VT_FUSED_ACTIVATION_FUNCTION, false)?
     .finish();
    Ok(())
  }
}
pub struct AddOptionsArgs {
    pub fused_activation_function: ActivationFunctionType,
}
impl<'a> Default for AddOptionsArgs {
  #[inline]
  fn default() -> Self {
    AddOptionsArgs {
      fused_activation_function: ActivationFunctionType::NONE,
    }
  }
}

pub struct AddOptionsBuilder<'a: 'b, 'b> {
  fbb_: &'b mut flatbuffers::FlatBufferBuilder<'a>,
  start_: flatbuffers::WIPOffset<flatbuffers::TableUnfinishedWIPOffset>,
}
impl<'a: 'b, 'b> AddOptionsBuilder<'a, 'b> {
  #[inline]
  pub fn add_fused_activation_function(&mut self, fused_activation_function: ActivationFunctionType) {
    self.fbb_.push_slot::<ActivationFunctionType>(AddOptions::VT_FUSED_ACTIVATION_FUNCTION, fused_activation_function, ActivationFunctionType::NONE);
  }
  #[inline]
  pub fn new(_fbb: &'b mut flatbuffers::FlatBufferBuilder<'a>) -> AddOptionsBuilder<'a, 'b> {
    let start = _fbb.start_table();
    AddOptionsBuilder {
      fbb_: _fbb,
      start_: start,
    }
  }
  #[inline]
  pub fn finish(self) -> flatbuffers::WIPOffset<AddOptions<'a>> {
    let o = self.fbb_.end_table(self.start_);
    flatbuffers::WIPOffset::new(o.value())
  }
}

impl core::fmt::Debug for AddOptions<'_> {
  fn fmt(&self, f: &mut core::fmt::Formatter<'_>) -> core::fmt::Result {
    let mut ds = f.debug_struct("AddOptions");
      ds.field("fused_activation_function", &self.fused_activation_function());
      ds.finish()
  }
}
#[non_exhaustive]
#[derive(Debug, Clone, PartialEq)]
pub struct AddOptionsT {
  pub fused_activation_function: ActivationFunctionType,
}
impl Default for AddOptionsT {
  fn default() -> Self {
    Self {
      fused_activation_function: ActivationFunctionType::NONE,
    }
  }
}
impl AddOptionsT {
  pub fn pack<'b>(
    &self,
    _fbb: &mut flatbuffers::FlatBufferBuilder<'b>
  ) -> flatbuffers::WIPOffset<AddOptions<'b>> {
    let fused_activation_function = self.fused_activation_function;
    AddOptions::create(_fbb, &AddOptionsArgs{
      fused_activation_function,
    })
  }
}
pub enum MulOptionsOffset {}
#[derive(Copy, Clone, PartialEq)]

pub struct MulOptions<'a> {
  pub _tab: flatbuffers::Table<'a>,
}

impl<'a> flatbuffers::Follow<'a> for MulOptions<'a> {
  type Inner = MulOptions<'a>;
  #[inline]
  fn follow(buf: &'a [u8], loc: usize) -> Self::Inner {
    Self { _tab: flatbuffers::Table { buf, loc } }
  }
}

impl<'a> MulOptions<'a> {
  pub const VT_FUSED_ACTIVATION_FUNCTION: flatbuffers::VOffsetT = 4;

  #[inline]
  pub fn init_from_table(table: flatbuffers::Table<'a>) -> Self {
    MulOptions { _tab: table }
  }
  #[allow(unused_mut)]
  pub fn create<'bldr: 'args, 'args: 'mut_bldr, 'mut_bldr>(
    _fbb: &'mut_bldr mut flatbuffers::FlatBufferBuilder<'bldr>,
    args: &'args MulOptionsArgs
  ) -> flatbuffers::WIPOffset<MulOptions<'bldr>> {
    let mut builder = MulOptionsBuilder::new(_fbb);
    builder.add_fused_activation_function(args.fused_activation_function);
    builder.finish()
  }

  pub fn unpack(&self) -> MulOptionsT {
    let fused_activation_function = self.fused_activation_function();
    MulOptionsT {
      fused_activation_function,
    }
  }

  #[inline]
  pub fn fused_activation_function(&self) -> ActivationFunctionType {
    self._tab.get::<ActivationFunctionType>(MulOptions::VT_FUSED_ACTIVATION_FUNCTION, Some(ActivationFunctionType::NONE)).unwrap()
  }
}

impl flatbuffers::Verifiable for MulOptions<'_> {
  #[inline]
  fn run_verifier(
    v: &mut flatbuffers::Verifier, pos: usize
  ) -> Result<(), flatbuffers::InvalidFlatbuffer> {
    use self::flatbuffers::Verifiable;
    v.visit_table(pos)?
     .visit_field::<ActivationFunctionType>("fused_activation_function", Self::VT_FUSED_ACTIVATION_FUNCTION, false)?
     .finish();
    Ok(())
  }
}
pub struct MulOptionsArgs {
    pub fused_activation_function: ActivationFunctionType,
}
impl<'a> Default for MulOptionsArgs {
  #[inline]
  fn default() -> Self {
    MulOptionsArgs {
      fused_activation_function: ActivationFunctionType::NONE,
    }
  }
}

pub struct MulOptionsBuilder<'a: 'b, 'b> {
  fbb_: &'b mut flatbuffers::FlatBufferBuilder<'a>,
  start_: flatbuffers::WIPOffset<flatbuffers::TableUnfinishedWIPOffset>,
}
impl<'a: 'b, 'b> MulOptionsBuilder<'a, 'b> {
  #[inline]
  pub fn add_fused_activation_function(&mut self, fused_activation_function: ActivationFunctionType) {
    self.fbb_.push_slot::<ActivationFunctionType>(MulOptions::VT_FUSED_ACTIVATION_FUNCTION, fused_activation_function, ActivationFunctionType::NONE);
  }
  #[inline]
  pub fn new(_fbb: &'b mut flatbuffers::FlatBufferBuilder<'a>) -> MulOptionsBuilder<'a, 'b> {
    let start = _fbb.start_table();
    MulOptionsBuilder {
      fbb_: _fbb,
      start_: start,
    }
  }
  #[inline]
  pub fn finish(self) -> flatbuffers::WIPOffset<MulOptions<'a>> {
    let o = self.fbb_.end_table(self.start_);
    flatbuffers::WIPOffset::new(o.value())
  }
}

impl core::fmt::Debug for MulOptions<'_> {
  fn fmt(&self, f: &mut core::fmt::Formatter<'_>) -> core::fmt::Result {
    let mut ds = f.debug_struct("MulOptions");
      ds.field("fused_activation_function", &self.fused_activation_function());
      ds.finish()
  }
}
#[non_exhaustive]
#[derive(Debug, Clone, PartialEq)]
pub struct MulOptionsT {
  pub fused_activation_function: ActivationFunctionType,
}
impl Default for MulOptionsT {
  fn default() -> Self {
    Self {
      fused_activation_function: ActivationFunctionType::NONE,
    }
  }
}
impl MulOptionsT {
  pub fn pack<'b>(
    &self,
    _fbb: &mut flatbuffers::FlatBufferBuilder<'b>
  ) -> flatbuffers::WIPOffset<MulOptions<'b>> {
    let fused_activation_function = self.fused_activation_function;
    MulOptions::create(_fbb, &MulOptionsArgs{
      fused_activation_function,
    })
  }
}
pub enum L2NormOptionsOffset {}
#[derive(Copy, Clone, PartialEq)]

pub struct L2NormOptions<'a> {
  pub _tab: flatbuffers::Table<'a>,
}

impl<'a> flatbuffers::Follow<'a> for L2NormOptions<'a> {
  type Inner = L2NormOptions<'a>;
  #[inline]
  fn follow(buf: &'a [u8], loc: usize) -> Self::Inner {
    Self { _tab: flatbuffers::Table { buf, loc } }
  }
}

impl<'a> L2NormOptions<'a> {
  pub const VT_FUSED_ACTIVATION_FUNCTION: flatbuffers::VOffsetT = 4;

  #[inline]
  pub fn init_from_table(table: flatbuffers::Table<'a>) -> Self {
    L2NormOptions { _tab: table }
  }
  #[allow(unused_mut)]
  pub fn create<'bldr: 'args, 'args: 'mut_bldr, 'mut_bldr>(
    _fbb: &'mut_bldr mut flatbuffers::FlatBufferBuilder<'bldr>,
    args: &'args L2NormOptionsArgs
  ) -> flatbuffers::WIPOffset<L2NormOptions<'bldr>> {
    let mut builder = L2NormOptionsBuilder::new(_fbb);
    builder.add_fused_activation_function(args.fused_activation_function);
    builder.finish()
  }

  pub fn unpack(&self) -> L2NormOptionsT {
    let fused_activation_function = self.fused_activation_function();
    L2NormOptionsT {
      fused_activation_function,
    }
  }

  #[inline]
  pub fn fused_activation_function(&self) -> ActivationFunctionType {
    self._tab.get::<ActivationFunctionType>(L2NormOptions::VT_FUSED_ACTIVATION_FUNCTION, Some(ActivationFunctionType::NONE)).unwrap()
  }
}

impl flatbuffers::Verifiable for L2NormOptions<'_> {
  #[inline]
  fn run_verifier(
    v: &mut flatbuffers::Verifier, pos: usize
  ) -> Result<(), flatbuffers::InvalidFlatbuffer> {
    use self::flatbuffers::Verifiable;
    v.visit_table(pos)?
     .visit_field::<ActivationFunctionType>("fused_activation_function", Self::VT_FUSED_ACTIVATION_FUNCTION, false)?
     .finish();
    Ok(())
  }
}
pub struct L2NormOptionsArgs {
    pub fused_activation_function: ActivationFunctionType,
}
impl<'a> Default for L2NormOptionsArgs {
  #[inline]
  fn default() -> Self {
    L2NormOptionsArgs {
      fused_activation_function: ActivationFunctionType::NONE,
    }
  }
}

pub struct L2NormOptionsBuilder<'a: 'b, 'b> {
  fbb_: &'b mut flatbuffers::FlatBufferBuilder<'a>,
  start_: flatbuffers::WIPOffset<flatbuffers::TableUnfinishedWIPOffset>,
}
impl<'a: 'b, 'b> L2NormOptionsBuilder<'a, 'b> {
  #[inline]
  pub fn add_fused_activation_function(&mut self, fused_activation_function: ActivationFunctionType) {
    self.fbb_.push_slot::<ActivationFunctionType>(L2NormOptions::VT_FUSED_ACTIVATION_FUNCTION, fused_activation_function, ActivationFunctionType::NONE);
  }
  #[inline]
  pub fn new(_fbb: &'b mut flatbuffers::FlatBufferBuilder<'a>) -> L2NormOptionsBuilder<'a, 'b> {
    let start = _fbb.start_table();
    L2NormOptionsBuilder {
      fbb_: _fbb,
      start_: start,
    }
  }
  #[inline]
  pub fn finish(self) -> flatbuffers::WIPOffset<L2NormOptions<'a>> {
    let o = self.fbb_.end_table(self.start_);
    flatbuffers::WIPOffset::new(o.value())
  }
}

impl core::fmt::Debug for L2NormOptions<'_> {
  fn fmt(&self, f: &mut core::fmt::Formatter<'_>) -> core::fmt::Result {
    let mut ds = f.debug_struct("L2NormOptions");
      ds.field("fused_activation_function", &self.fused_activation_function());
      ds.finish()
  }
}
#[non_exhaustive]
#[derive(Debug, Clone, PartialEq)]
pub struct L2NormOptionsT {
  pub fused_activation_function: ActivationFunctionType,
}
impl Default for L2NormOptionsT {
  fn default() -> Self {
    Self {
      fused_activation_function: ActivationFunctionType::NONE,
    }
  }
}
impl L2NormOptionsT {
  pub fn pack<'b>(
    &self,
    _fbb: &mut flatbuffers::FlatBufferBuilder<'b>
  ) -> flatbuffers::WIPOffset<L2NormOptions<'b>> {
    let fused_activation_function = self.fused_activation_function;
    L2NormOptions::create(_fbb, &L2NormOptionsArgs{
      fused_activation_function,
    })
  }
}
pub enum LocalResponseNormalizationOptionsOffset {}
#[derive(Copy, Clone, PartialEq)]

pub struct LocalResponseNormalizationOptions<'a> {
  pub _tab: flatbuffers::Table<'a>,
}

impl<'a> flatbuffers::Follow<'a> for LocalResponseNormalizationOptions<'a> {
  type Inner = LocalResponseNormalizationOptions<'a>;
  #[inline]
  fn follow(buf: &'a [u8], loc: usize) -> Self::Inner {
    Self { _tab: flatbuffers::Table { buf, loc } }
  }
}

impl<'a> LocalResponseNormalizationOptions<'a> {
  pub const VT_RADIUS: flatbuffers::VOffsetT = 4;
  pub const VT_BIAS: flatbuffers::VOffsetT = 6;
  pub const VT_ALPHA: flatbuffers::VOffsetT = 8;
  pub const VT_BETA: flatbuffers::VOffsetT = 10;

  #[inline]
  pub fn init_from_table(table: flatbuffers::Table<'a>) -> Self {
    LocalResponseNormalizationOptions { _tab: table }
  }
  #[allow(unused_mut)]
  pub fn create<'bldr: 'args, 'args: 'mut_bldr, 'mut_bldr>(
    _fbb: &'mut_bldr mut flatbuffers::FlatBufferBuilder<'bldr>,
    args: &'args LocalResponseNormalizationOptionsArgs
  ) -> flatbuffers::WIPOffset<LocalResponseNormalizationOptions<'bldr>> {
    let mut builder = LocalResponseNormalizationOptionsBuilder::new(_fbb);
    builder.add_beta(args.beta);
    builder.add_alpha(args.alpha);
    builder.add_bias(args.bias);
    builder.add_radius(args.radius);
    builder.finish()
  }

  pub fn unpack(&self) -> LocalResponseNormalizationOptionsT {
    let radius = self.radius();
    let bias = self.bias();
    let alpha = self.alpha();
    let beta = self.beta();
    LocalResponseNormalizationOptionsT {
      radius,
      bias,
      alpha,
      beta,
    }
  }

  #[inline]
  pub fn radius(&self) -> i32 {
    self._tab.get::<i32>(LocalResponseNormalizationOptions::VT_RADIUS, Some(0)).unwrap()
  }
  #[inline]
  pub fn bias(&self) -> f32 {
    self._tab.get::<f32>(LocalResponseNormalizationOptions::VT_BIAS, Some(0.0)).unwrap()
  }
  #[inline]
  pub fn alpha(&self) -> f32 {
    self._tab.get::<f32>(LocalResponseNormalizationOptions::VT_ALPHA, Some(0.0)).unwrap()
  }
  #[inline]
  pub fn beta(&self) -> f32 {
    self._tab.get::<f32>(LocalResponseNormalizationOptions::VT_BETA, Some(0.0)).unwrap()
  }
}

impl flatbuffers::Verifiable for LocalResponseNormalizationOptions<'_> {
  #[inline]
  fn run_verifier(
    v: &mut flatbuffers::Verifier, pos: usize
  ) -> Result<(), flatbuffers::InvalidFlatbuffer> {
    use self::flatbuffers::Verifiable;
    v.visit_table(pos)?
     .visit_field::<i32>("radius", Self::VT_RADIUS, false)?
     .visit_field::<f32>("bias", Self::VT_BIAS, false)?
     .visit_field::<f32>("alpha", Self::VT_ALPHA, false)?
     .visit_field::<f32>("beta", Self::VT_BETA, false)?
     .finish();
    Ok(())
  }
}
pub struct LocalResponseNormalizationOptionsArgs {
    pub radius: i32,
    pub bias: f32,
    pub alpha: f32,
    pub beta: f32,
}
impl<'a> Default for LocalResponseNormalizationOptionsArgs {
  #[inline]
  fn default() -> Self {
    LocalResponseNormalizationOptionsArgs {
      radius: 0,
      bias: 0.0,
      alpha: 0.0,
      beta: 0.0,
    }
  }
}

pub struct LocalResponseNormalizationOptionsBuilder<'a: 'b, 'b> {
  fbb_: &'b mut flatbuffers::FlatBufferBuilder<'a>,
  start_: flatbuffers::WIPOffset<flatbuffers::TableUnfinishedWIPOffset>,
}
impl<'a: 'b, 'b> LocalResponseNormalizationOptionsBuilder<'a, 'b> {
  #[inline]
  pub fn add_radius(&mut self, radius: i32) {
    self.fbb_.push_slot::<i32>(LocalResponseNormalizationOptions::VT_RADIUS, radius, 0);
  }
  #[inline]
  pub fn add_bias(&mut self, bias: f32) {
    self.fbb_.push_slot::<f32>(LocalResponseNormalizationOptions::VT_BIAS, bias, 0.0);
  }
  #[inline]
  pub fn add_alpha(&mut self, alpha: f32) {
    self.fbb_.push_slot::<f32>(LocalResponseNormalizationOptions::VT_ALPHA, alpha, 0.0);
  }
  #[inline]
  pub fn add_beta(&mut self, beta: f32) {
    self.fbb_.push_slot::<f32>(LocalResponseNormalizationOptions::VT_BETA, beta, 0.0);
  }
  #[inline]
  pub fn new(_fbb: &'b mut flatbuffers::FlatBufferBuilder<'a>) -> LocalResponseNormalizationOptionsBuilder<'a, 'b> {
    let start = _fbb.start_table();
    LocalResponseNormalizationOptionsBuilder {
      fbb_: _fbb,
      start_: start,
    }
  }
  #[inline]
  pub fn finish(self) -> flatbuffers::WIPOffset<LocalResponseNormalizationOptions<'a>> {
    let o = self.fbb_.end_table(self.start_);
    flatbuffers::WIPOffset::new(o.value())
  }
}

impl core::fmt::Debug for LocalResponseNormalizationOptions<'_> {
  fn fmt(&self, f: &mut core::fmt::Formatter<'_>) -> core::fmt::Result {
    let mut ds = f.debug_struct("LocalResponseNormalizationOptions");
      ds.field("radius", &self.radius());
      ds.field("bias", &self.bias());
      ds.field("alpha", &self.alpha());
      ds.field("beta", &self.beta());
      ds.finish()
  }
}
#[non_exhaustive]
#[derive(Debug, Clone, PartialEq)]
pub struct LocalResponseNormalizationOptionsT {
  pub radius: i32,
  pub bias: f32,
  pub alpha: f32,
  pub beta: f32,
}
impl Default for LocalResponseNormalizationOptionsT {
  fn default() -> Self {
    Self {
      radius: 0,
      bias: 0.0,
      alpha: 0.0,
      beta: 0.0,
    }
  }
}
impl LocalResponseNormalizationOptionsT {
  pub fn pack<'b>(
    &self,
    _fbb: &mut flatbuffers::FlatBufferBuilder<'b>
  ) -> flatbuffers::WIPOffset<LocalResponseNormalizationOptions<'b>> {
    let radius = self.radius;
    let bias = self.bias;
    let alpha = self.alpha;
    let beta = self.beta;
    LocalResponseNormalizationOptions::create(_fbb, &LocalResponseNormalizationOptionsArgs{
      radius,
      bias,
      alpha,
      beta,
    })
  }
}
pub enum LSTMOptionsOffset {}
#[derive(Copy, Clone, PartialEq)]

pub struct LSTMOptions<'a> {
  pub _tab: flatbuffers::Table<'a>,
}

impl<'a> flatbuffers::Follow<'a> for LSTMOptions<'a> {
  type Inner = LSTMOptions<'a>;
  #[inline]
  fn follow(buf: &'a [u8], loc: usize) -> Self::Inner {
    Self { _tab: flatbuffers::Table { buf, loc } }
  }
}

impl<'a> LSTMOptions<'a> {
  pub const VT_FUSED_ACTIVATION_FUNCTION: flatbuffers::VOffsetT = 4;
  pub const VT_CELL_CLIP: flatbuffers::VOffsetT = 6;
  pub const VT_PROJ_CLIP: flatbuffers::VOffsetT = 8;
  pub const VT_KERNEL_TYPE: flatbuffers::VOffsetT = 10;

  #[inline]
  pub fn init_from_table(table: flatbuffers::Table<'a>) -> Self {
    LSTMOptions { _tab: table }
  }
  #[allow(unused_mut)]
  pub fn create<'bldr: 'args, 'args: 'mut_bldr, 'mut_bldr>(
    _fbb: &'mut_bldr mut flatbuffers::FlatBufferBuilder<'bldr>,
    args: &'args LSTMOptionsArgs
  ) -> flatbuffers::WIPOffset<LSTMOptions<'bldr>> {
    let mut builder = LSTMOptionsBuilder::new(_fbb);
    builder.add_proj_clip(args.proj_clip);
    builder.add_cell_clip(args.cell_clip);
    builder.add_kernel_type(args.kernel_type);
    builder.add_fused_activation_function(args.fused_activation_function);
    builder.finish()
  }

  pub fn unpack(&self) -> LSTMOptionsT {
    let fused_activation_function = self.fused_activation_function();
    let cell_clip = self.cell_clip();
    let proj_clip = self.proj_clip();
    let kernel_type = self.kernel_type();
    LSTMOptionsT {
      fused_activation_function,
      cell_clip,
      proj_clip,
      kernel_type,
    }
  }

  #[inline]
  pub fn fused_activation_function(&self) -> ActivationFunctionType {
    self._tab.get::<ActivationFunctionType>(LSTMOptions::VT_FUSED_ACTIVATION_FUNCTION, Some(ActivationFunctionType::NONE)).unwrap()
  }
  #[inline]
  pub fn cell_clip(&self) -> f32 {
    self._tab.get::<f32>(LSTMOptions::VT_CELL_CLIP, Some(0.0)).unwrap()
  }
  #[inline]
  pub fn proj_clip(&self) -> f32 {
    self._tab.get::<f32>(LSTMOptions::VT_PROJ_CLIP, Some(0.0)).unwrap()
  }
  #[inline]
  pub fn kernel_type(&self) -> LSTMKernelType {
    self._tab.get::<LSTMKernelType>(LSTMOptions::VT_KERNEL_TYPE, Some(LSTMKernelType::FULL)).unwrap()
  }
}

impl flatbuffers::Verifiable for LSTMOptions<'_> {
  #[inline]
  fn run_verifier(
    v: &mut flatbuffers::Verifier, pos: usize
  ) -> Result<(), flatbuffers::InvalidFlatbuffer> {
    use self::flatbuffers::Verifiable;
    v.visit_table(pos)?
     .visit_field::<ActivationFunctionType>("fused_activation_function", Self::VT_FUSED_ACTIVATION_FUNCTION, false)?
     .visit_field::<f32>("cell_clip", Self::VT_CELL_CLIP, false)?
     .visit_field::<f32>("proj_clip", Self::VT_PROJ_CLIP, false)?
     .visit_field::<LSTMKernelType>("kernel_type", Self::VT_KERNEL_TYPE, false)?
     .finish();
    Ok(())
  }
}
pub struct LSTMOptionsArgs {
    pub fused_activation_function: ActivationFunctionType,
    pub cell_clip: f32,
    pub proj_clip: f32,
    pub kernel_type: LSTMKernelType,
}
impl<'a> Default for LSTMOptionsArgs {
  #[inline]
  fn default() -> Self {
    LSTMOptionsArgs {
      fused_activation_function: ActivationFunctionType::NONE,
      cell_clip: 0.0,
      proj_clip: 0.0,
      kernel_type: LSTMKernelType::FULL,
    }
  }
}

pub struct LSTMOptionsBuilder<'a: 'b, 'b> {
  fbb_: &'b mut flatbuffers::FlatBufferBuilder<'a>,
  start_: flatbuffers::WIPOffset<flatbuffers::TableUnfinishedWIPOffset>,
}
impl<'a: 'b, 'b> LSTMOptionsBuilder<'a, 'b> {
  #[inline]
  pub fn add_fused_activation_function(&mut self, fused_activation_function: ActivationFunctionType) {
    self.fbb_.push_slot::<ActivationFunctionType>(LSTMOptions::VT_FUSED_ACTIVATION_FUNCTION, fused_activation_function, ActivationFunctionType::NONE);
  }
  #[inline]
  pub fn add_cell_clip(&mut self, cell_clip: f32) {
    self.fbb_.push_slot::<f32>(LSTMOptions::VT_CELL_CLIP, cell_clip, 0.0);
  }
  #[inline]
  pub fn add_proj_clip(&mut self, proj_clip: f32) {
    self.fbb_.push_slot::<f32>(LSTMOptions::VT_PROJ_CLIP, proj_clip, 0.0);
  }
  #[inline]
  pub fn add_kernel_type(&mut self, kernel_type: LSTMKernelType) {
    self.fbb_.push_slot::<LSTMKernelType>(LSTMOptions::VT_KERNEL_TYPE, kernel_type, LSTMKernelType::FULL);
  }
  #[inline]
  pub fn new(_fbb: &'b mut flatbuffers::FlatBufferBuilder<'a>) -> LSTMOptionsBuilder<'a, 'b> {
    let start = _fbb.start_table();
    LSTMOptionsBuilder {
      fbb_: _fbb,
      start_: start,
    }
  }
  #[inline]
  pub fn finish(self) -> flatbuffers::WIPOffset<LSTMOptions<'a>> {
    let o = self.fbb_.end_table(self.start_);
    flatbuffers::WIPOffset::new(o.value())
  }
}

impl core::fmt::Debug for LSTMOptions<'_> {
  fn fmt(&self, f: &mut core::fmt::Formatter<'_>) -> core::fmt::Result {
    let mut ds = f.debug_struct("LSTMOptions");
      ds.field("fused_activation_function", &self.fused_activation_function());
      ds.field("cell_clip", &self.cell_clip());
      ds.field("proj_clip", &self.proj_clip());
      ds.field("kernel_type", &self.kernel_type());
      ds.finish()
  }
}
#[non_exhaustive]
#[derive(Debug, Clone, PartialEq)]
pub struct LSTMOptionsT {
  pub fused_activation_function: ActivationFunctionType,
  pub cell_clip: f32,
  pub proj_clip: f32,
  pub kernel_type: LSTMKernelType,
}
impl Default for LSTMOptionsT {
  fn default() -> Self {
    Self {
      fused_activation_function: ActivationFunctionType::NONE,
      cell_clip: 0.0,
      proj_clip: 0.0,
      kernel_type: LSTMKernelType::FULL,
    }
  }
}
impl LSTMOptionsT {
  pub fn pack<'b>(
    &self,
    _fbb: &mut flatbuffers::FlatBufferBuilder<'b>
  ) -> flatbuffers::WIPOffset<LSTMOptions<'b>> {
    let fused_activation_function = self.fused_activation_function;
    let cell_clip = self.cell_clip;
    let proj_clip = self.proj_clip;
    let kernel_type = self.kernel_type;
    LSTMOptions::create(_fbb, &LSTMOptionsArgs{
      fused_activation_function,
      cell_clip,
      proj_clip,
      kernel_type,
    })
  }
}
pub enum UnidirectionalSequenceLSTMOptionsOffset {}
#[derive(Copy, Clone, PartialEq)]

pub struct UnidirectionalSequenceLSTMOptions<'a> {
  pub _tab: flatbuffers::Table<'a>,
}

impl<'a> flatbuffers::Follow<'a> for UnidirectionalSequenceLSTMOptions<'a> {
  type Inner = UnidirectionalSequenceLSTMOptions<'a>;
  #[inline]
  fn follow(buf: &'a [u8], loc: usize) -> Self::Inner {
    Self { _tab: flatbuffers::Table { buf, loc } }
  }
}

impl<'a> UnidirectionalSequenceLSTMOptions<'a> {
  pub const VT_FUSED_ACTIVATION_FUNCTION: flatbuffers::VOffsetT = 4;
  pub const VT_CELL_CLIP: flatbuffers::VOffsetT = 6;
  pub const VT_PROJ_CLIP: flatbuffers::VOffsetT = 8;
  pub const VT_TIME_MAJOR: flatbuffers::VOffsetT = 10;

  #[inline]
  pub fn init_from_table(table: flatbuffers::Table<'a>) -> Self {
    UnidirectionalSequenceLSTMOptions { _tab: table }
  }
  #[allow(unused_mut)]
  pub fn create<'bldr: 'args, 'args: 'mut_bldr, 'mut_bldr>(
    _fbb: &'mut_bldr mut flatbuffers::FlatBufferBuilder<'bldr>,
    args: &'args UnidirectionalSequenceLSTMOptionsArgs
  ) -> flatbuffers::WIPOffset<UnidirectionalSequenceLSTMOptions<'bldr>> {
    let mut builder = UnidirectionalSequenceLSTMOptionsBuilder::new(_fbb);
    builder.add_proj_clip(args.proj_clip);
    builder.add_cell_clip(args.cell_clip);
    builder.add_time_major(args.time_major);
    builder.add_fused_activation_function(args.fused_activation_function);
    builder.finish()
  }

  pub fn unpack(&self) -> UnidirectionalSequenceLSTMOptionsT {
    let fused_activation_function = self.fused_activation_function();
    let cell_clip = self.cell_clip();
    let proj_clip = self.proj_clip();
    let time_major = self.time_major();
    UnidirectionalSequenceLSTMOptionsT {
      fused_activation_function,
      cell_clip,
      proj_clip,
      time_major,
    }
  }

  #[inline]
  pub fn fused_activation_function(&self) -> ActivationFunctionType {
    self._tab.get::<ActivationFunctionType>(UnidirectionalSequenceLSTMOptions::VT_FUSED_ACTIVATION_FUNCTION, Some(ActivationFunctionType::NONE)).unwrap()
  }
  #[inline]
  pub fn cell_clip(&self) -> f32 {
    self._tab.get::<f32>(UnidirectionalSequenceLSTMOptions::VT_CELL_CLIP, Some(0.0)).unwrap()
  }
  #[inline]
  pub fn proj_clip(&self) -> f32 {
    self._tab.get::<f32>(UnidirectionalSequenceLSTMOptions::VT_PROJ_CLIP, Some(0.0)).unwrap()
  }
  #[inline]
  pub fn time_major(&self) -> bool {
    self._tab.get::<bool>(UnidirectionalSequenceLSTMOptions::VT_TIME_MAJOR, Some(false)).unwrap()
  }
}

impl flatbuffers::Verifiable for UnidirectionalSequenceLSTMOptions<'_> {
  #[inline]
  fn run_verifier(
    v: &mut flatbuffers::Verifier, pos: usize
  ) -> Result<(), flatbuffers::InvalidFlatbuffer> {
    use self::flatbuffers::Verifiable;
    v.visit_table(pos)?
     .visit_field::<ActivationFunctionType>("fused_activation_function", Self::VT_FUSED_ACTIVATION_FUNCTION, false)?
     .visit_field::<f32>("cell_clip", Self::VT_CELL_CLIP, false)?
     .visit_field::<f32>("proj_clip", Self::VT_PROJ_CLIP, false)?
     .visit_field::<bool>("time_major", Self::VT_TIME_MAJOR, false)?
     .finish();
    Ok(())
  }
}
pub struct UnidirectionalSequenceLSTMOptionsArgs {
    pub fused_activation_function: ActivationFunctionType,
    pub cell_clip: f32,
    pub proj_clip: f32,
    pub time_major: bool,
}
impl<'a> Default for UnidirectionalSequenceLSTMOptionsArgs {
  #[inline]
  fn default() -> Self {
    UnidirectionalSequenceLSTMOptionsArgs {
      fused_activation_function: ActivationFunctionType::NONE,
      cell_clip: 0.0,
      proj_clip: 0.0,
      time_major: false,
    }
  }
}

pub struct UnidirectionalSequenceLSTMOptionsBuilder<'a: 'b, 'b> {
  fbb_: &'b mut flatbuffers::FlatBufferBuilder<'a>,
  start_: flatbuffers::WIPOffset<flatbuffers::TableUnfinishedWIPOffset>,
}
impl<'a: 'b, 'b> UnidirectionalSequenceLSTMOptionsBuilder<'a, 'b> {
  #[inline]
  pub fn add_fused_activation_function(&mut self, fused_activation_function: ActivationFunctionType) {
    self.fbb_.push_slot::<ActivationFunctionType>(UnidirectionalSequenceLSTMOptions::VT_FUSED_ACTIVATION_FUNCTION, fused_activation_function, ActivationFunctionType::NONE);
  }
  #[inline]
  pub fn add_cell_clip(&mut self, cell_clip: f32) {
    self.fbb_.push_slot::<f32>(UnidirectionalSequenceLSTMOptions::VT_CELL_CLIP, cell_clip, 0.0);
  }
  #[inline]
  pub fn add_proj_clip(&mut self, proj_clip: f32) {
    self.fbb_.push_slot::<f32>(UnidirectionalSequenceLSTMOptions::VT_PROJ_CLIP, proj_clip, 0.0);
  }
  #[inline]
  pub fn add_time_major(&mut self, time_major: bool) {
    self.fbb_.push_slot::<bool>(UnidirectionalSequenceLSTMOptions::VT_TIME_MAJOR, time_major, false);
  }
  #[inline]
  pub fn new(_fbb: &'b mut flatbuffers::FlatBufferBuilder<'a>) -> UnidirectionalSequenceLSTMOptionsBuilder<'a, 'b> {
    let start = _fbb.start_table();
    UnidirectionalSequenceLSTMOptionsBuilder {
      fbb_: _fbb,
      start_: start,
    }
  }
  #[inline]
  pub fn finish(self) -> flatbuffers::WIPOffset<UnidirectionalSequenceLSTMOptions<'a>> {
    let o = self.fbb_.end_table(self.start_);
    flatbuffers::WIPOffset::new(o.value())
  }
}

impl core::fmt::Debug for UnidirectionalSequenceLSTMOptions<'_> {
  fn fmt(&self, f: &mut core::fmt::Formatter<'_>) -> core::fmt::Result {
    let mut ds = f.debug_struct("UnidirectionalSequenceLSTMOptions");
      ds.field("fused_activation_function", &self.fused_activation_function());
      ds.field("cell_clip", &self.cell_clip());
      ds.field("proj_clip", &self.proj_clip());
      ds.field("time_major", &self.time_major());
      ds.finish()
  }
}
#[non_exhaustive]
#[derive(Debug, Clone, PartialEq)]
pub struct UnidirectionalSequenceLSTMOptionsT {
  pub fused_activation_function: ActivationFunctionType,
  pub cell_clip: f32,
  pub proj_clip: f32,
  pub time_major: bool,
}
impl Default for UnidirectionalSequenceLSTMOptionsT {
  fn default() -> Self {
    Self {
      fused_activation_function: ActivationFunctionType::NONE,
      cell_clip: 0.0,
      proj_clip: 0.0,
      time_major: false,
    }
  }
}
impl UnidirectionalSequenceLSTMOptionsT {
  pub fn pack<'b>(
    &self,
    _fbb: &mut flatbuffers::FlatBufferBuilder<'b>
  ) -> flatbuffers::WIPOffset<UnidirectionalSequenceLSTMOptions<'b>> {
    let fused_activation_function = self.fused_activation_function;
    let cell_clip = self.cell_clip;
    let proj_clip = self.proj_clip;
    let time_major = self.time_major;
    UnidirectionalSequenceLSTMOptions::create(_fbb, &UnidirectionalSequenceLSTMOptionsArgs{
      fused_activation_function,
      cell_clip,
      proj_clip,
      time_major,
    })
  }
}
pub enum BidirectionalSequenceLSTMOptionsOffset {}
#[derive(Copy, Clone, PartialEq)]

pub struct BidirectionalSequenceLSTMOptions<'a> {
  pub _tab: flatbuffers::Table<'a>,
}

impl<'a> flatbuffers::Follow<'a> for BidirectionalSequenceLSTMOptions<'a> {
  type Inner = BidirectionalSequenceLSTMOptions<'a>;
  #[inline]
  fn follow(buf: &'a [u8], loc: usize) -> Self::Inner {
    Self { _tab: flatbuffers::Table { buf, loc } }
  }
}

impl<'a> BidirectionalSequenceLSTMOptions<'a> {
  pub const VT_FUSED_ACTIVATION_FUNCTION: flatbuffers::VOffsetT = 4;
  pub const VT_CELL_CLIP: flatbuffers::VOffsetT = 6;
  pub const VT_PROJ_CLIP: flatbuffers::VOffsetT = 8;
  pub const VT_MERGE_OUTPUTS: flatbuffers::VOffsetT = 10;
  pub const VT_TIME_MAJOR: flatbuffers::VOffsetT = 12;

  #[inline]
  pub fn init_from_table(table: flatbuffers::Table<'a>) -> Self {
    BidirectionalSequenceLSTMOptions { _tab: table }
  }
  #[allow(unused_mut)]
  pub fn create<'bldr: 'args, 'args: 'mut_bldr, 'mut_bldr>(
    _fbb: &'mut_bldr mut flatbuffers::FlatBufferBuilder<'bldr>,
    args: &'args BidirectionalSequenceLSTMOptionsArgs
  ) -> flatbuffers::WIPOffset<BidirectionalSequenceLSTMOptions<'bldr>> {
    let mut builder = BidirectionalSequenceLSTMOptionsBuilder::new(_fbb);
    builder.add_proj_clip(args.proj_clip);
    builder.add_cell_clip(args.cell_clip);
    builder.add_time_major(args.time_major);
    builder.add_merge_outputs(args.merge_outputs);
    builder.add_fused_activation_function(args.fused_activation_function);
    builder.finish()
  }

  pub fn unpack(&self) -> BidirectionalSequenceLSTMOptionsT {
    let fused_activation_function = self.fused_activation_function();
    let cell_clip = self.cell_clip();
    let proj_clip = self.proj_clip();
    let merge_outputs = self.merge_outputs();
    let time_major = self.time_major();
    BidirectionalSequenceLSTMOptionsT {
      fused_activation_function,
      cell_clip,
      proj_clip,
      merge_outputs,
      time_major,
    }
  }

  #[inline]
  pub fn fused_activation_function(&self) -> ActivationFunctionType {
    self._tab.get::<ActivationFunctionType>(BidirectionalSequenceLSTMOptions::VT_FUSED_ACTIVATION_FUNCTION, Some(ActivationFunctionType::NONE)).unwrap()
  }
  #[inline]
  pub fn cell_clip(&self) -> f32 {
    self._tab.get::<f32>(BidirectionalSequenceLSTMOptions::VT_CELL_CLIP, Some(0.0)).unwrap()
  }
  #[inline]
  pub fn proj_clip(&self) -> f32 {
    self._tab.get::<f32>(BidirectionalSequenceLSTMOptions::VT_PROJ_CLIP, Some(0.0)).unwrap()
  }
  #[inline]
  pub fn merge_outputs(&self) -> bool {
    self._tab.get::<bool>(BidirectionalSequenceLSTMOptions::VT_MERGE_OUTPUTS, Some(false)).unwrap()
  }
  #[inline]
  pub fn time_major(&self) -> bool {
    self._tab.get::<bool>(BidirectionalSequenceLSTMOptions::VT_TIME_MAJOR, Some(true)).unwrap()
  }
}

impl flatbuffers::Verifiable for BidirectionalSequenceLSTMOptions<'_> {
  #[inline]
  fn run_verifier(
    v: &mut flatbuffers::Verifier, pos: usize
  ) -> Result<(), flatbuffers::InvalidFlatbuffer> {
    use self::flatbuffers::Verifiable;
    v.visit_table(pos)?
     .visit_field::<ActivationFunctionType>("fused_activation_function", Self::VT_FUSED_ACTIVATION_FUNCTION, false)?
     .visit_field::<f32>("cell_clip", Self::VT_CELL_CLIP, false)?
     .visit_field::<f32>("proj_clip", Self::VT_PROJ_CLIP, false)?
     .visit_field::<bool>("merge_outputs", Self::VT_MERGE_OUTPUTS, false)?
     .visit_field::<bool>("time_major", Self::VT_TIME_MAJOR, false)?
     .finish();
    Ok(())
  }
}
pub struct BidirectionalSequenceLSTMOptionsArgs {
    pub fused_activation_function: ActivationFunctionType,
    pub cell_clip: f32,
    pub proj_clip: f32,
    pub merge_outputs: bool,
    pub time_major: bool,
}
impl<'a> Default for BidirectionalSequenceLSTMOptionsArgs {
  #[inline]
  fn default() -> Self {
    BidirectionalSequenceLSTMOptionsArgs {
      fused_activation_function: ActivationFunctionType::NONE,
      cell_clip: 0.0,
      proj_clip: 0.0,
      merge_outputs: false,
      time_major: true,
    }
  }
}

pub struct BidirectionalSequenceLSTMOptionsBuilder<'a: 'b, 'b> {
  fbb_: &'b mut flatbuffers::FlatBufferBuilder<'a>,
  start_: flatbuffers::WIPOffset<flatbuffers::TableUnfinishedWIPOffset>,
}
impl<'a: 'b, 'b> BidirectionalSequenceLSTMOptionsBuilder<'a, 'b> {
  #[inline]
  pub fn add_fused_activation_function(&mut self, fused_activation_function: ActivationFunctionType) {
    self.fbb_.push_slot::<ActivationFunctionType>(BidirectionalSequenceLSTMOptions::VT_FUSED_ACTIVATION_FUNCTION, fused_activation_function, ActivationFunctionType::NONE);
  }
  #[inline]
  pub fn add_cell_clip(&mut self, cell_clip: f32) {
    self.fbb_.push_slot::<f32>(BidirectionalSequenceLSTMOptions::VT_CELL_CLIP, cell_clip, 0.0);
  }
  #[inline]
  pub fn add_proj_clip(&mut self, proj_clip: f32) {
    self.fbb_.push_slot::<f32>(BidirectionalSequenceLSTMOptions::VT_PROJ_CLIP, proj_clip, 0.0);
  }
  #[inline]
  pub fn add_merge_outputs(&mut self, merge_outputs: bool) {
    self.fbb_.push_slot::<bool>(BidirectionalSequenceLSTMOptions::VT_MERGE_OUTPUTS, merge_outputs, false);
  }
  #[inline]
  pub fn add_time_major(&mut self, time_major: bool) {
    self.fbb_.push_slot::<bool>(BidirectionalSequenceLSTMOptions::VT_TIME_MAJOR, time_major, true);
  }
  #[inline]
  pub fn new(_fbb: &'b mut flatbuffers::FlatBufferBuilder<'a>) -> BidirectionalSequenceLSTMOptionsBuilder<'a, 'b> {
    let start = _fbb.start_table();
    BidirectionalSequenceLSTMOptionsBuilder {
      fbb_: _fbb,
      start_: start,
    }
  }
  #[inline]
  pub fn finish(self) -> flatbuffers::WIPOffset<BidirectionalSequenceLSTMOptions<'a>> {
    let o = self.fbb_.end_table(self.start_);
    flatbuffers::WIPOffset::new(o.value())
  }
}

impl core::fmt::Debug for BidirectionalSequenceLSTMOptions<'_> {
  fn fmt(&self, f: &mut core::fmt::Formatter<'_>) -> core::fmt::Result {
    let mut ds = f.debug_struct("BidirectionalSequenceLSTMOptions");
      ds.field("fused_activation_function", &self.fused_activation_function());
      ds.field("cell_clip", &self.cell_clip());
      ds.field("proj_clip", &self.proj_clip());
      ds.field("merge_outputs", &self.merge_outputs());
      ds.field("time_major", &self.time_major());
      ds.finish()
  }
}
#[non_exhaustive]
#[derive(Debug, Clone, PartialEq)]
pub struct BidirectionalSequenceLSTMOptionsT {
  pub fused_activation_function: ActivationFunctionType,
  pub cell_clip: f32,
  pub proj_clip: f32,
  pub merge_outputs: bool,
  pub time_major: bool,
}
impl Default for BidirectionalSequenceLSTMOptionsT {
  fn default() -> Self {
    Self {
      fused_activation_function: ActivationFunctionType::NONE,
      cell_clip: 0.0,
      proj_clip: 0.0,
      merge_outputs: false,
      time_major: true,
    }
  }
}
impl BidirectionalSequenceLSTMOptionsT {
  pub fn pack<'b>(
    &self,
    _fbb: &mut flatbuffers::FlatBufferBuilder<'b>
  ) -> flatbuffers::WIPOffset<BidirectionalSequenceLSTMOptions<'b>> {
    let fused_activation_function = self.fused_activation_function;
    let cell_clip = self.cell_clip;
    let proj_clip = self.proj_clip;
    let merge_outputs = self.merge_outputs;
    let time_major = self.time_major;
    BidirectionalSequenceLSTMOptions::create(_fbb, &BidirectionalSequenceLSTMOptionsArgs{
      fused_activation_function,
      cell_clip,
      proj_clip,
      merge_outputs,
      time_major,
    })
  }
}
pub enum ResizeBilinearOptionsOffset {}
#[derive(Copy, Clone, PartialEq)]

pub struct ResizeBilinearOptions<'a> {
  pub _tab: flatbuffers::Table<'a>,
}

impl<'a> flatbuffers::Follow<'a> for ResizeBilinearOptions<'a> {
  type Inner = ResizeBilinearOptions<'a>;
  #[inline]
  fn follow(buf: &'a [u8], loc: usize) -> Self::Inner {
    Self { _tab: flatbuffers::Table { buf, loc } }
  }
}

impl<'a> ResizeBilinearOptions<'a> {
  pub const VT_ALIGN_CORNERS: flatbuffers::VOffsetT = 8;

  #[inline]
  pub fn init_from_table(table: flatbuffers::Table<'a>) -> Self {
    ResizeBilinearOptions { _tab: table }
  }
  #[allow(unused_mut)]
  pub fn create<'bldr: 'args, 'args: 'mut_bldr, 'mut_bldr>(
    _fbb: &'mut_bldr mut flatbuffers::FlatBufferBuilder<'bldr>,
    args: &'args ResizeBilinearOptionsArgs
  ) -> flatbuffers::WIPOffset<ResizeBilinearOptions<'bldr>> {
    let mut builder = ResizeBilinearOptionsBuilder::new(_fbb);
    builder.add_align_corners(args.align_corners);
    builder.finish()
  }

  pub fn unpack(&self) -> ResizeBilinearOptionsT {
    let align_corners = self.align_corners();
    ResizeBilinearOptionsT {
      align_corners,
    }
  }

  #[inline]
  pub fn align_corners(&self) -> bool {
    self._tab.get::<bool>(ResizeBilinearOptions::VT_ALIGN_CORNERS, Some(false)).unwrap()
  }
}

impl flatbuffers::Verifiable for ResizeBilinearOptions<'_> {
  #[inline]
  fn run_verifier(
    v: &mut flatbuffers::Verifier, pos: usize
  ) -> Result<(), flatbuffers::InvalidFlatbuffer> {
    use self::flatbuffers::Verifiable;
    v.visit_table(pos)?
     .visit_field::<bool>("align_corners", Self::VT_ALIGN_CORNERS, false)?
     .finish();
    Ok(())
  }
}
pub struct ResizeBilinearOptionsArgs {
    pub align_corners: bool,
}
impl<'a> Default for ResizeBilinearOptionsArgs {
  #[inline]
  fn default() -> Self {
    ResizeBilinearOptionsArgs {
      align_corners: false,
    }
  }
}

pub struct ResizeBilinearOptionsBuilder<'a: 'b, 'b> {
  fbb_: &'b mut flatbuffers::FlatBufferBuilder<'a>,
  start_: flatbuffers::WIPOffset<flatbuffers::TableUnfinishedWIPOffset>,
}
impl<'a: 'b, 'b> ResizeBilinearOptionsBuilder<'a, 'b> {
  #[inline]
  pub fn add_align_corners(&mut self, align_corners: bool) {
    self.fbb_.push_slot::<bool>(ResizeBilinearOptions::VT_ALIGN_CORNERS, align_corners, false);
  }
  #[inline]
  pub fn new(_fbb: &'b mut flatbuffers::FlatBufferBuilder<'a>) -> ResizeBilinearOptionsBuilder<'a, 'b> {
    let start = _fbb.start_table();
    ResizeBilinearOptionsBuilder {
      fbb_: _fbb,
      start_: start,
    }
  }
  #[inline]
  pub fn finish(self) -> flatbuffers::WIPOffset<ResizeBilinearOptions<'a>> {
    let o = self.fbb_.end_table(self.start_);
    flatbuffers::WIPOffset::new(o.value())
  }
}

impl core::fmt::Debug for ResizeBilinearOptions<'_> {
  fn fmt(&self, f: &mut core::fmt::Formatter<'_>) -> core::fmt::Result {
    let mut ds = f.debug_struct("ResizeBilinearOptions");
      ds.field("align_corners", &self.align_corners());
      ds.finish()
  }
}
#[non_exhaustive]
#[derive(Debug, Clone, PartialEq)]
pub struct ResizeBilinearOptionsT {
  pub align_corners: bool,
}
impl Default for ResizeBilinearOptionsT {
  fn default() -> Self {
    Self {
      align_corners: false,
    }
  }
}
impl ResizeBilinearOptionsT {
  pub fn pack<'b>(
    &self,
    _fbb: &mut flatbuffers::FlatBufferBuilder<'b>
  ) -> flatbuffers::WIPOffset<ResizeBilinearOptions<'b>> {
    let align_corners = self.align_corners;
    ResizeBilinearOptions::create(_fbb, &ResizeBilinearOptionsArgs{
      align_corners,
    })
  }
}
pub enum ResizeNearestNeighborOptionsOffset {}
#[derive(Copy, Clone, PartialEq)]

pub struct ResizeNearestNeighborOptions<'a> {
  pub _tab: flatbuffers::Table<'a>,
}

impl<'a> flatbuffers::Follow<'a> for ResizeNearestNeighborOptions<'a> {
  type Inner = ResizeNearestNeighborOptions<'a>;
  #[inline]
  fn follow(buf: &'a [u8], loc: usize) -> Self::Inner {
    Self { _tab: flatbuffers::Table { buf, loc } }
  }
}

impl<'a> ResizeNearestNeighborOptions<'a> {
  pub const VT_ALIGN_CORNERS: flatbuffers::VOffsetT = 4;

  #[inline]
  pub fn init_from_table(table: flatbuffers::Table<'a>) -> Self {
    ResizeNearestNeighborOptions { _tab: table }
  }
  #[allow(unused_mut)]
  pub fn create<'bldr: 'args, 'args: 'mut_bldr, 'mut_bldr>(
    _fbb: &'mut_bldr mut flatbuffers::FlatBufferBuilder<'bldr>,
    args: &'args ResizeNearestNeighborOptionsArgs
  ) -> flatbuffers::WIPOffset<ResizeNearestNeighborOptions<'bldr>> {
    let mut builder = ResizeNearestNeighborOptionsBuilder::new(_fbb);
    builder.add_align_corners(args.align_corners);
    builder.finish()
  }

  pub fn unpack(&self) -> ResizeNearestNeighborOptionsT {
    let align_corners = self.align_corners();
    ResizeNearestNeighborOptionsT {
      align_corners,
    }
  }

  #[inline]
  pub fn align_corners(&self) -> bool {
    self._tab.get::<bool>(ResizeNearestNeighborOptions::VT_ALIGN_CORNERS, Some(false)).unwrap()
  }
}

impl flatbuffers::Verifiable for ResizeNearestNeighborOptions<'_> {
  #[inline]
  fn run_verifier(
    v: &mut flatbuffers::Verifier, pos: usize
  ) -> Result<(), flatbuffers::InvalidFlatbuffer> {
    use self::flatbuffers::Verifiable;
    v.visit_table(pos)?
     .visit_field::<bool>("align_corners", Self::VT_ALIGN_CORNERS, false)?
     .finish();
    Ok(())
  }
}
pub struct ResizeNearestNeighborOptionsArgs {
    pub align_corners: bool,
}
impl<'a> Default for ResizeNearestNeighborOptionsArgs {
  #[inline]
  fn default() -> Self {
    ResizeNearestNeighborOptionsArgs {
      align_corners: false,
    }
  }
}

pub struct ResizeNearestNeighborOptionsBuilder<'a: 'b, 'b> {
  fbb_: &'b mut flatbuffers::FlatBufferBuilder<'a>,
  start_: flatbuffers::WIPOffset<flatbuffers::TableUnfinishedWIPOffset>,
}
impl<'a: 'b, 'b> ResizeNearestNeighborOptionsBuilder<'a, 'b> {
  #[inline]
  pub fn add_align_corners(&mut self, align_corners: bool) {
    self.fbb_.push_slot::<bool>(ResizeNearestNeighborOptions::VT_ALIGN_CORNERS, align_corners, false);
  }
  #[inline]
  pub fn new(_fbb: &'b mut flatbuffers::FlatBufferBuilder<'a>) -> ResizeNearestNeighborOptionsBuilder<'a, 'b> {
    let start = _fbb.start_table();
    ResizeNearestNeighborOptionsBuilder {
      fbb_: _fbb,
      start_: start,
    }
  }
  #[inline]
  pub fn finish(self) -> flatbuffers::WIPOffset<ResizeNearestNeighborOptions<'a>> {
    let o = self.fbb_.end_table(self.start_);
    flatbuffers::WIPOffset::new(o.value())
  }
}

impl core::fmt::Debug for ResizeNearestNeighborOptions<'_> {
  fn fmt(&self, f: &mut core::fmt::Formatter<'_>) -> core::fmt::Result {
    let mut ds = f.debug_struct("ResizeNearestNeighborOptions");
      ds.field("align_corners", &self.align_corners());
      ds.finish()
  }
}
#[non_exhaustive]
#[derive(Debug, Clone, PartialEq)]
pub struct ResizeNearestNeighborOptionsT {
  pub align_corners: bool,
}
impl Default for ResizeNearestNeighborOptionsT {
  fn default() -> Self {
    Self {
      align_corners: false,
    }
  }
}
impl ResizeNearestNeighborOptionsT {
  pub fn pack<'b>(
    &self,
    _fbb: &mut flatbuffers::FlatBufferBuilder<'b>
  ) -> flatbuffers::WIPOffset<ResizeNearestNeighborOptions<'b>> {
    let align_corners = self.align_corners;
    ResizeNearestNeighborOptions::create(_fbb, &ResizeNearestNeighborOptionsArgs{
      align_corners,
    })
  }
}
pub enum CallOptionsOffset {}
#[derive(Copy, Clone, PartialEq)]

pub struct CallOptions<'a> {
  pub _tab: flatbuffers::Table<'a>,
}

impl<'a> flatbuffers::Follow<'a> for CallOptions<'a> {
  type Inner = CallOptions<'a>;
  #[inline]
  fn follow(buf: &'a [u8], loc: usize) -> Self::Inner {
    Self { _tab: flatbuffers::Table { buf, loc } }
  }
}

impl<'a> CallOptions<'a> {
  pub const VT_SUBGRAPH: flatbuffers::VOffsetT = 4;

  #[inline]
  pub fn init_from_table(table: flatbuffers::Table<'a>) -> Self {
    CallOptions { _tab: table }
  }
  #[allow(unused_mut)]
  pub fn create<'bldr: 'args, 'args: 'mut_bldr, 'mut_bldr>(
    _fbb: &'mut_bldr mut flatbuffers::FlatBufferBuilder<'bldr>,
    args: &'args CallOptionsArgs
  ) -> flatbuffers::WIPOffset<CallOptions<'bldr>> {
    let mut builder = CallOptionsBuilder::new(_fbb);
    builder.add_subgraph(args.subgraph);
    builder.finish()
  }

  pub fn unpack(&self) -> CallOptionsT {
    let subgraph = self.subgraph();
    CallOptionsT {
      subgraph,
    }
  }

  #[inline]
  pub fn subgraph(&self) -> u32 {
    self._tab.get::<u32>(CallOptions::VT_SUBGRAPH, Some(0)).unwrap()
  }
}

impl flatbuffers::Verifiable for CallOptions<'_> {
  #[inline]
  fn run_verifier(
    v: &mut flatbuffers::Verifier, pos: usize
  ) -> Result<(), flatbuffers::InvalidFlatbuffer> {
    use self::flatbuffers::Verifiable;
    v.visit_table(pos)?
     .visit_field::<u32>("subgraph", Self::VT_SUBGRAPH, false)?
     .finish();
    Ok(())
  }
}
pub struct CallOptionsArgs {
    pub subgraph: u32,
}
impl<'a> Default for CallOptionsArgs {
  #[inline]
  fn default() -> Self {
    CallOptionsArgs {
      subgraph: 0,
    }
  }
}

pub struct CallOptionsBuilder<'a: 'b, 'b> {
  fbb_: &'b mut flatbuffers::FlatBufferBuilder<'a>,
  start_: flatbuffers::WIPOffset<flatbuffers::TableUnfinishedWIPOffset>,
}
impl<'a: 'b, 'b> CallOptionsBuilder<'a, 'b> {
  #[inline]
  pub fn add_subgraph(&mut self, subgraph: u32) {
    self.fbb_.push_slot::<u32>(CallOptions::VT_SUBGRAPH, subgraph, 0);
  }
  #[inline]
  pub fn new(_fbb: &'b mut flatbuffers::FlatBufferBuilder<'a>) -> CallOptionsBuilder<'a, 'b> {
    let start = _fbb.start_table();
    CallOptionsBuilder {
      fbb_: _fbb,
      start_: start,
    }
  }
  #[inline]
  pub fn finish(self) -> flatbuffers::WIPOffset<CallOptions<'a>> {
    let o = self.fbb_.end_table(self.start_);
    flatbuffers::WIPOffset::new(o.value())
  }
}

impl core::fmt::Debug for CallOptions<'_> {
  fn fmt(&self, f: &mut core::fmt::Formatter<'_>) -> core::fmt::Result {
    let mut ds = f.debug_struct("CallOptions");
      ds.field("subgraph", &self.subgraph());
      ds.finish()
  }
}
#[non_exhaustive]
#[derive(Debug, Clone, PartialEq)]
pub struct CallOptionsT {
  pub subgraph: u32,
}
impl Default for CallOptionsT {
  fn default() -> Self {
    Self {
      subgraph: 0,
    }
  }
}
impl CallOptionsT {
  pub fn pack<'b>(
    &self,
    _fbb: &mut flatbuffers::FlatBufferBuilder<'b>
  ) -> flatbuffers::WIPOffset<CallOptions<'b>> {
    let subgraph = self.subgraph;
    CallOptions::create(_fbb, &CallOptionsArgs{
      subgraph,
    })
  }
}
pub enum PadOptionsOffset {}
#[derive(Copy, Clone, PartialEq)]

pub struct PadOptions<'a> {
  pub _tab: flatbuffers::Table<'a>,
}

impl<'a> flatbuffers::Follow<'a> for PadOptions<'a> {
  type Inner = PadOptions<'a>;
  #[inline]
  fn follow(buf: &'a [u8], loc: usize) -> Self::Inner {
    Self { _tab: flatbuffers::Table { buf, loc } }
  }
}

impl<'a> PadOptions<'a> {

  #[inline]
  pub fn init_from_table(table: flatbuffers::Table<'a>) -> Self {
    PadOptions { _tab: table }
  }
  #[allow(unused_mut)]
  pub fn create<'bldr: 'args, 'args: 'mut_bldr, 'mut_bldr>(
    _fbb: &'mut_bldr mut flatbuffers::FlatBufferBuilder<'bldr>,
    _args: &'args PadOptionsArgs
  ) -> flatbuffers::WIPOffset<PadOptions<'bldr>> {
    let mut builder = PadOptionsBuilder::new(_fbb);
    builder.finish()
  }

  pub fn unpack(&self) -> PadOptionsT {
    PadOptionsT {
    }
  }
}

impl flatbuffers::Verifiable for PadOptions<'_> {
  #[inline]
  fn run_verifier(
    v: &mut flatbuffers::Verifier, pos: usize
  ) -> Result<(), flatbuffers::InvalidFlatbuffer> {
    use self::flatbuffers::Verifiable;
    v.visit_table(pos)?
     .finish();
    Ok(())
  }
}
pub struct PadOptionsArgs {
}
impl<'a> Default for PadOptionsArgs {
  #[inline]
  fn default() -> Self {
    PadOptionsArgs {
    }
  }
}

pub struct PadOptionsBuilder<'a: 'b, 'b> {
  fbb_: &'b mut flatbuffers::FlatBufferBuilder<'a>,
  start_: flatbuffers::WIPOffset<flatbuffers::TableUnfinishedWIPOffset>,
}
impl<'a: 'b, 'b> PadOptionsBuilder<'a, 'b> {
  #[inline]
  pub fn new(_fbb: &'b mut flatbuffers::FlatBufferBuilder<'a>) -> PadOptionsBuilder<'a, 'b> {
    let start = _fbb.start_table();
    PadOptionsBuilder {
      fbb_: _fbb,
      start_: start,
    }
  }
  #[inline]
  pub fn finish(self) -> flatbuffers::WIPOffset<PadOptions<'a>> {
    let o = self.fbb_.end_table(self.start_);
    flatbuffers::WIPOffset::new(o.value())
  }
}

impl core::fmt::Debug for PadOptions<'_> {
  fn fmt(&self, f: &mut core::fmt::Formatter<'_>) -> core::fmt::Result {
    let mut ds = f.debug_struct("PadOptions");
      ds.finish()
  }
}
#[non_exhaustive]
#[derive(Debug, Clone, PartialEq)]
pub struct PadOptionsT {
}
impl Default for PadOptionsT {
  fn default() -> Self {
    Self {
    }
  }
}
impl PadOptionsT {
  pub fn pack<'b>(
    &self,
    _fbb: &mut flatbuffers::FlatBufferBuilder<'b>
  ) -> flatbuffers::WIPOffset<PadOptions<'b>> {
    PadOptions::create(_fbb, &PadOptionsArgs{
    })
  }
}
pub enum PadV2OptionsOffset {}
#[derive(Copy, Clone, PartialEq)]

pub struct PadV2Options<'a> {
  pub _tab: flatbuffers::Table<'a>,
}

impl<'a> flatbuffers::Follow<'a> for PadV2Options<'a> {
  type Inner = PadV2Options<'a>;
  #[inline]
  fn follow(buf: &'a [u8], loc: usize) -> Self::Inner {
    Self { _tab: flatbuffers::Table { buf, loc } }
  }
}

impl<'a> PadV2Options<'a> {

  #[inline]
  pub fn init_from_table(table: flatbuffers::Table<'a>) -> Self {
    PadV2Options { _tab: table }
  }
  #[allow(unused_mut)]
  pub fn create<'bldr: 'args, 'args: 'mut_bldr, 'mut_bldr>(
    _fbb: &'mut_bldr mut flatbuffers::FlatBufferBuilder<'bldr>,
    _args: &'args PadV2OptionsArgs
  ) -> flatbuffers::WIPOffset<PadV2Options<'bldr>> {
    let mut builder = PadV2OptionsBuilder::new(_fbb);
    builder.finish()
  }

  pub fn unpack(&self) -> PadV2OptionsT {
    PadV2OptionsT {
    }
  }
}

impl flatbuffers::Verifiable for PadV2Options<'_> {
  #[inline]
  fn run_verifier(
    v: &mut flatbuffers::Verifier, pos: usize
  ) -> Result<(), flatbuffers::InvalidFlatbuffer> {
    use self::flatbuffers::Verifiable;
    v.visit_table(pos)?
     .finish();
    Ok(())
  }
}
pub struct PadV2OptionsArgs {
}
impl<'a> Default for PadV2OptionsArgs {
  #[inline]
  fn default() -> Self {
    PadV2OptionsArgs {
    }
  }
}

pub struct PadV2OptionsBuilder<'a: 'b, 'b> {
  fbb_: &'b mut flatbuffers::FlatBufferBuilder<'a>,
  start_: flatbuffers::WIPOffset<flatbuffers::TableUnfinishedWIPOffset>,
}
impl<'a: 'b, 'b> PadV2OptionsBuilder<'a, 'b> {
  #[inline]
  pub fn new(_fbb: &'b mut flatbuffers::FlatBufferBuilder<'a>) -> PadV2OptionsBuilder<'a, 'b> {
    let start = _fbb.start_table();
    PadV2OptionsBuilder {
      fbb_: _fbb,
      start_: start,
    }
  }
  #[inline]
  pub fn finish(self) -> flatbuffers::WIPOffset<PadV2Options<'a>> {
    let o = self.fbb_.end_table(self.start_);
    flatbuffers::WIPOffset::new(o.value())
  }
}

impl core::fmt::Debug for PadV2Options<'_> {
  fn fmt(&self, f: &mut core::fmt::Formatter<'_>) -> core::fmt::Result {
    let mut ds = f.debug_struct("PadV2Options");
      ds.finish()
  }
}
#[non_exhaustive]
#[derive(Debug, Clone, PartialEq)]
pub struct PadV2OptionsT {
}
impl Default for PadV2OptionsT {
  fn default() -> Self {
    Self {
    }
  }
}
impl PadV2OptionsT {
  pub fn pack<'b>(
    &self,
    _fbb: &mut flatbuffers::FlatBufferBuilder<'b>
  ) -> flatbuffers::WIPOffset<PadV2Options<'b>> {
    PadV2Options::create(_fbb, &PadV2OptionsArgs{
    })
  }
}
pub enum ReshapeOptionsOffset {}
#[derive(Copy, Clone, PartialEq)]

pub struct ReshapeOptions<'a> {
  pub _tab: flatbuffers::Table<'a>,
}

impl<'a> flatbuffers::Follow<'a> for ReshapeOptions<'a> {
  type Inner = ReshapeOptions<'a>;
  #[inline]
  fn follow(buf: &'a [u8], loc: usize) -> Self::Inner {
    Self { _tab: flatbuffers::Table { buf, loc } }
  }
}

impl<'a> ReshapeOptions<'a> {
  pub const VT_NEW_SHAPE: flatbuffers::VOffsetT = 4;

  #[inline]
  pub fn init_from_table(table: flatbuffers::Table<'a>) -> Self {
    ReshapeOptions { _tab: table }
  }
  #[allow(unused_mut)]
  pub fn create<'bldr: 'args, 'args: 'mut_bldr, 'mut_bldr>(
    _fbb: &'mut_bldr mut flatbuffers::FlatBufferBuilder<'bldr>,
    args: &'args ReshapeOptionsArgs<'args>
  ) -> flatbuffers::WIPOffset<ReshapeOptions<'bldr>> {
    let mut builder = ReshapeOptionsBuilder::new(_fbb);
    if let Some(x) = args.new_shape { builder.add_new_shape(x); }
    builder.finish()
  }

  pub fn unpack(&self) -> ReshapeOptionsT {
    let new_shape = self.new_shape().map(|x| {
      x.into_iter().collect()
    });
    ReshapeOptionsT {
      new_shape,
    }
  }

  #[inline]
  pub fn new_shape(&self) -> Option<flatbuffers::Vector<'a, i32>> {
    self._tab.get::<flatbuffers::ForwardsUOffset<flatbuffers::Vector<'a, i32>>>(ReshapeOptions::VT_NEW_SHAPE, None)
  }
}

impl flatbuffers::Verifiable for ReshapeOptions<'_> {
  #[inline]
  fn run_verifier(
    v: &mut flatbuffers::Verifier, pos: usize
  ) -> Result<(), flatbuffers::InvalidFlatbuffer> {
    use self::flatbuffers::Verifiable;
    v.visit_table(pos)?
     .visit_field::<flatbuffers::ForwardsUOffset<flatbuffers::Vector<'_, i32>>>("new_shape", Self::VT_NEW_SHAPE, false)?
     .finish();
    Ok(())
  }
}
pub struct ReshapeOptionsArgs<'a> {
    pub new_shape: Option<flatbuffers::WIPOffset<flatbuffers::Vector<'a, i32>>>,
}
impl<'a> Default for ReshapeOptionsArgs<'a> {
  #[inline]
  fn default() -> Self {
    ReshapeOptionsArgs {
      new_shape: None,
    }
  }
}

pub struct ReshapeOptionsBuilder<'a: 'b, 'b> {
  fbb_: &'b mut flatbuffers::FlatBufferBuilder<'a>,
  start_: flatbuffers::WIPOffset<flatbuffers::TableUnfinishedWIPOffset>,
}
impl<'a: 'b, 'b> ReshapeOptionsBuilder<'a, 'b> {
  #[inline]
  pub fn add_new_shape(&mut self, new_shape: flatbuffers::WIPOffset<flatbuffers::Vector<'b , i32>>) {
    self.fbb_.push_slot_always::<flatbuffers::WIPOffset<_>>(ReshapeOptions::VT_NEW_SHAPE, new_shape);
  }
  #[inline]
  pub fn new(_fbb: &'b mut flatbuffers::FlatBufferBuilder<'a>) -> ReshapeOptionsBuilder<'a, 'b> {
    let start = _fbb.start_table();
    ReshapeOptionsBuilder {
      fbb_: _fbb,
      start_: start,
    }
  }
  #[inline]
  pub fn finish(self) -> flatbuffers::WIPOffset<ReshapeOptions<'a>> {
    let o = self.fbb_.end_table(self.start_);
    flatbuffers::WIPOffset::new(o.value())
  }
}

impl core::fmt::Debug for ReshapeOptions<'_> {
  fn fmt(&self, f: &mut core::fmt::Formatter<'_>) -> core::fmt::Result {
    let mut ds = f.debug_struct("ReshapeOptions");
      ds.field("new_shape", &self.new_shape());
      ds.finish()
  }
}
#[non_exhaustive]
#[derive(Debug, Clone, PartialEq)]
pub struct ReshapeOptionsT {
  pub new_shape: Option<Vec<i32>>,
}
impl Default for ReshapeOptionsT {
  fn default() -> Self {
    Self {
      new_shape: None,
    }
  }
}
impl ReshapeOptionsT {
  pub fn pack<'b>(
    &self,
    _fbb: &mut flatbuffers::FlatBufferBuilder<'b>
  ) -> flatbuffers::WIPOffset<ReshapeOptions<'b>> {
    let new_shape = self.new_shape.as_ref().map(|x|{
      _fbb.create_vector(x)
    });
    ReshapeOptions::create(_fbb, &ReshapeOptionsArgs{
      new_shape,
    })
  }
}
pub enum SpaceToBatchNDOptionsOffset {}
#[derive(Copy, Clone, PartialEq)]

pub struct SpaceToBatchNDOptions<'a> {
  pub _tab: flatbuffers::Table<'a>,
}

impl<'a> flatbuffers::Follow<'a> for SpaceToBatchNDOptions<'a> {
  type Inner = SpaceToBatchNDOptions<'a>;
  #[inline]
  fn follow(buf: &'a [u8], loc: usize) -> Self::Inner {
    Self { _tab: flatbuffers::Table { buf, loc } }
  }
}

impl<'a> SpaceToBatchNDOptions<'a> {

  #[inline]
  pub fn init_from_table(table: flatbuffers::Table<'a>) -> Self {
    SpaceToBatchNDOptions { _tab: table }
  }
  #[allow(unused_mut)]
  pub fn create<'bldr: 'args, 'args: 'mut_bldr, 'mut_bldr>(
    _fbb: &'mut_bldr mut flatbuffers::FlatBufferBuilder<'bldr>,
    _args: &'args SpaceToBatchNDOptionsArgs
  ) -> flatbuffers::WIPOffset<SpaceToBatchNDOptions<'bldr>> {
    let mut builder = SpaceToBatchNDOptionsBuilder::new(_fbb);
    builder.finish()
  }

  pub fn unpack(&self) -> SpaceToBatchNDOptionsT {
    SpaceToBatchNDOptionsT {
    }
  }
}

impl flatbuffers::Verifiable for SpaceToBatchNDOptions<'_> {
  #[inline]
  fn run_verifier(
    v: &mut flatbuffers::Verifier, pos: usize
  ) -> Result<(), flatbuffers::InvalidFlatbuffer> {
    use self::flatbuffers::Verifiable;
    v.visit_table(pos)?
     .finish();
    Ok(())
  }
}
pub struct SpaceToBatchNDOptionsArgs {
}
impl<'a> Default for SpaceToBatchNDOptionsArgs {
  #[inline]
  fn default() -> Self {
    SpaceToBatchNDOptionsArgs {
    }
  }
}

pub struct SpaceToBatchNDOptionsBuilder<'a: 'b, 'b> {
  fbb_: &'b mut flatbuffers::FlatBufferBuilder<'a>,
  start_: flatbuffers::WIPOffset<flatbuffers::TableUnfinishedWIPOffset>,
}
impl<'a: 'b, 'b> SpaceToBatchNDOptionsBuilder<'a, 'b> {
  #[inline]
  pub fn new(_fbb: &'b mut flatbuffers::FlatBufferBuilder<'a>) -> SpaceToBatchNDOptionsBuilder<'a, 'b> {
    let start = _fbb.start_table();
    SpaceToBatchNDOptionsBuilder {
      fbb_: _fbb,
      start_: start,
    }
  }
  #[inline]
  pub fn finish(self) -> flatbuffers::WIPOffset<SpaceToBatchNDOptions<'a>> {
    let o = self.fbb_.end_table(self.start_);
    flatbuffers::WIPOffset::new(o.value())
  }
}

impl core::fmt::Debug for SpaceToBatchNDOptions<'_> {
  fn fmt(&self, f: &mut core::fmt::Formatter<'_>) -> core::fmt::Result {
    let mut ds = f.debug_struct("SpaceToBatchNDOptions");
      ds.finish()
  }
}
#[non_exhaustive]
#[derive(Debug, Clone, PartialEq)]
pub struct SpaceToBatchNDOptionsT {
}
impl Default for SpaceToBatchNDOptionsT {
  fn default() -> Self {
    Self {
    }
  }
}
impl SpaceToBatchNDOptionsT {
  pub fn pack<'b>(
    &self,
    _fbb: &mut flatbuffers::FlatBufferBuilder<'b>
  ) -> flatbuffers::WIPOffset<SpaceToBatchNDOptions<'b>> {
    SpaceToBatchNDOptions::create(_fbb, &SpaceToBatchNDOptionsArgs{
    })
  }
}
pub enum BatchToSpaceNDOptionsOffset {}
#[derive(Copy, Clone, PartialEq)]

pub struct BatchToSpaceNDOptions<'a> {
  pub _tab: flatbuffers::Table<'a>,
}

impl<'a> flatbuffers::Follow<'a> for BatchToSpaceNDOptions<'a> {
  type Inner = BatchToSpaceNDOptions<'a>;
  #[inline]
  fn follow(buf: &'a [u8], loc: usize) -> Self::Inner {
    Self { _tab: flatbuffers::Table { buf, loc } }
  }
}

impl<'a> BatchToSpaceNDOptions<'a> {

  #[inline]
  pub fn init_from_table(table: flatbuffers::Table<'a>) -> Self {
    BatchToSpaceNDOptions { _tab: table }
  }
  #[allow(unused_mut)]
  pub fn create<'bldr: 'args, 'args: 'mut_bldr, 'mut_bldr>(
    _fbb: &'mut_bldr mut flatbuffers::FlatBufferBuilder<'bldr>,
    _args: &'args BatchToSpaceNDOptionsArgs
  ) -> flatbuffers::WIPOffset<BatchToSpaceNDOptions<'bldr>> {
    let mut builder = BatchToSpaceNDOptionsBuilder::new(_fbb);
    builder.finish()
  }

  pub fn unpack(&self) -> BatchToSpaceNDOptionsT {
    BatchToSpaceNDOptionsT {
    }
  }
}

impl flatbuffers::Verifiable for BatchToSpaceNDOptions<'_> {
  #[inline]
  fn run_verifier(
    v: &mut flatbuffers::Verifier, pos: usize
  ) -> Result<(), flatbuffers::InvalidFlatbuffer> {
    use self::flatbuffers::Verifiable;
    v.visit_table(pos)?
     .finish();
    Ok(())
  }
}
pub struct BatchToSpaceNDOptionsArgs {
}
impl<'a> Default for BatchToSpaceNDOptionsArgs {
  #[inline]
  fn default() -> Self {
    BatchToSpaceNDOptionsArgs {
    }
  }
}

pub struct BatchToSpaceNDOptionsBuilder<'a: 'b, 'b> {
  fbb_: &'b mut flatbuffers::FlatBufferBuilder<'a>,
  start_: flatbuffers::WIPOffset<flatbuffers::TableUnfinishedWIPOffset>,
}
impl<'a: 'b, 'b> BatchToSpaceNDOptionsBuilder<'a, 'b> {
  #[inline]
  pub fn new(_fbb: &'b mut flatbuffers::FlatBufferBuilder<'a>) -> BatchToSpaceNDOptionsBuilder<'a, 'b> {
    let start = _fbb.start_table();
    BatchToSpaceNDOptionsBuilder {
      fbb_: _fbb,
      start_: start,
    }
  }
  #[inline]
  pub fn finish(self) -> flatbuffers::WIPOffset<BatchToSpaceNDOptions<'a>> {
    let o = self.fbb_.end_table(self.start_);
    flatbuffers::WIPOffset::new(o.value())
  }
}

impl core::fmt::Debug for BatchToSpaceNDOptions<'_> {
  fn fmt(&self, f: &mut core::fmt::Formatter<'_>) -> core::fmt::Result {
    let mut ds = f.debug_struct("BatchToSpaceNDOptions");
      ds.finish()
  }
}
#[non_exhaustive]
#[derive(Debug, Clone, PartialEq)]
pub struct BatchToSpaceNDOptionsT {
}
impl Default for BatchToSpaceNDOptionsT {
  fn default() -> Self {
    Self {
    }
  }
}
impl BatchToSpaceNDOptionsT {
  pub fn pack<'b>(
    &self,
    _fbb: &mut flatbuffers::FlatBufferBuilder<'b>
  ) -> flatbuffers::WIPOffset<BatchToSpaceNDOptions<'b>> {
    BatchToSpaceNDOptions::create(_fbb, &BatchToSpaceNDOptionsArgs{
    })
  }
}
pub enum SkipGramOptionsOffset {}
#[derive(Copy, Clone, PartialEq)]

pub struct SkipGramOptions<'a> {
  pub _tab: flatbuffers::Table<'a>,
}

impl<'a> flatbuffers::Follow<'a> for SkipGramOptions<'a> {
  type Inner = SkipGramOptions<'a>;
  #[inline]
  fn follow(buf: &'a [u8], loc: usize) -> Self::Inner {
    Self { _tab: flatbuffers::Table { buf, loc } }
  }
}

impl<'a> SkipGramOptions<'a> {
  pub const VT_NGRAM_SIZE: flatbuffers::VOffsetT = 4;
  pub const VT_MAX_SKIP_SIZE: flatbuffers::VOffsetT = 6;
  pub const VT_INCLUDE_ALL_NGRAMS: flatbuffers::VOffsetT = 8;

  #[inline]
  pub fn init_from_table(table: flatbuffers::Table<'a>) -> Self {
    SkipGramOptions { _tab: table }
  }
  #[allow(unused_mut)]
  pub fn create<'bldr: 'args, 'args: 'mut_bldr, 'mut_bldr>(
    _fbb: &'mut_bldr mut flatbuffers::FlatBufferBuilder<'bldr>,
    args: &'args SkipGramOptionsArgs
  ) -> flatbuffers::WIPOffset<SkipGramOptions<'bldr>> {
    let mut builder = SkipGramOptionsBuilder::new(_fbb);
    builder.add_max_skip_size(args.max_skip_size);
    builder.add_ngram_size(args.ngram_size);
    builder.add_include_all_ngrams(args.include_all_ngrams);
    builder.finish()
  }

  pub fn unpack(&self) -> SkipGramOptionsT {
    let ngram_size = self.ngram_size();
    let max_skip_size = self.max_skip_size();
    let include_all_ngrams = self.include_all_ngrams();
    SkipGramOptionsT {
      ngram_size,
      max_skip_size,
      include_all_ngrams,
    }
  }

  #[inline]
  pub fn ngram_size(&self) -> i32 {
    self._tab.get::<i32>(SkipGramOptions::VT_NGRAM_SIZE, Some(0)).unwrap()
  }
  #[inline]
  pub fn max_skip_size(&self) -> i32 {
    self._tab.get::<i32>(SkipGramOptions::VT_MAX_SKIP_SIZE, Some(0)).unwrap()
  }
  #[inline]
  pub fn include_all_ngrams(&self) -> bool {
    self._tab.get::<bool>(SkipGramOptions::VT_INCLUDE_ALL_NGRAMS, Some(false)).unwrap()
  }
}

impl flatbuffers::Verifiable for SkipGramOptions<'_> {
  #[inline]
  fn run_verifier(
    v: &mut flatbuffers::Verifier, pos: usize
  ) -> Result<(), flatbuffers::InvalidFlatbuffer> {
    use self::flatbuffers::Verifiable;
    v.visit_table(pos)?
     .visit_field::<i32>("ngram_size", Self::VT_NGRAM_SIZE, false)?
     .visit_field::<i32>("max_skip_size", Self::VT_MAX_SKIP_SIZE, false)?
     .visit_field::<bool>("include_all_ngrams", Self::VT_INCLUDE_ALL_NGRAMS, false)?
     .finish();
    Ok(())
  }
}
pub struct SkipGramOptionsArgs {
    pub ngram_size: i32,
    pub max_skip_size: i32,
    pub include_all_ngrams: bool,
}
impl<'a> Default for SkipGramOptionsArgs {
  #[inline]
  fn default() -> Self {
    SkipGramOptionsArgs {
      ngram_size: 0,
      max_skip_size: 0,
      include_all_ngrams: false,
    }
  }
}

pub struct SkipGramOptionsBuilder<'a: 'b, 'b> {
  fbb_: &'b mut flatbuffers::FlatBufferBuilder<'a>,
  start_: flatbuffers::WIPOffset<flatbuffers::TableUnfinishedWIPOffset>,
}
impl<'a: 'b, 'b> SkipGramOptionsBuilder<'a, 'b> {
  #[inline]
  pub fn add_ngram_size(&mut self, ngram_size: i32) {
    self.fbb_.push_slot::<i32>(SkipGramOptions::VT_NGRAM_SIZE, ngram_size, 0);
  }
  #[inline]
  pub fn add_max_skip_size(&mut self, max_skip_size: i32) {
    self.fbb_.push_slot::<i32>(SkipGramOptions::VT_MAX_SKIP_SIZE, max_skip_size, 0);
  }
  #[inline]
  pub fn add_include_all_ngrams(&mut self, include_all_ngrams: bool) {
    self.fbb_.push_slot::<bool>(SkipGramOptions::VT_INCLUDE_ALL_NGRAMS, include_all_ngrams, false);
  }
  #[inline]
  pub fn new(_fbb: &'b mut flatbuffers::FlatBufferBuilder<'a>) -> SkipGramOptionsBuilder<'a, 'b> {
    let start = _fbb.start_table();
    SkipGramOptionsBuilder {
      fbb_: _fbb,
      start_: start,
    }
  }
  #[inline]
  pub fn finish(self) -> flatbuffers::WIPOffset<SkipGramOptions<'a>> {
    let o = self.fbb_.end_table(self.start_);
    flatbuffers::WIPOffset::new(o.value())
  }
}

impl core::fmt::Debug for SkipGramOptions<'_> {
  fn fmt(&self, f: &mut core::fmt::Formatter<'_>) -> core::fmt::Result {
    let mut ds = f.debug_struct("SkipGramOptions");
      ds.field("ngram_size", &self.ngram_size());
      ds.field("max_skip_size", &self.max_skip_size());
      ds.field("include_all_ngrams", &self.include_all_ngrams());
      ds.finish()
  }
}
#[non_exhaustive]
#[derive(Debug, Clone, PartialEq)]
pub struct SkipGramOptionsT {
  pub ngram_size: i32,
  pub max_skip_size: i32,
  pub include_all_ngrams: bool,
}
impl Default for SkipGramOptionsT {
  fn default() -> Self {
    Self {
      ngram_size: 0,
      max_skip_size: 0,
      include_all_ngrams: false,
    }
  }
}
impl SkipGramOptionsT {
  pub fn pack<'b>(
    &self,
    _fbb: &mut flatbuffers::FlatBufferBuilder<'b>
  ) -> flatbuffers::WIPOffset<SkipGramOptions<'b>> {
    let ngram_size = self.ngram_size;
    let max_skip_size = self.max_skip_size;
    let include_all_ngrams = self.include_all_ngrams;
    SkipGramOptions::create(_fbb, &SkipGramOptionsArgs{
      ngram_size,
      max_skip_size,
      include_all_ngrams,
    })
  }
}
pub enum SpaceToDepthOptionsOffset {}
#[derive(Copy, Clone, PartialEq)]

pub struct SpaceToDepthOptions<'a> {
  pub _tab: flatbuffers::Table<'a>,
}

impl<'a> flatbuffers::Follow<'a> for SpaceToDepthOptions<'a> {
  type Inner = SpaceToDepthOptions<'a>;
  #[inline]
  fn follow(buf: &'a [u8], loc: usize) -> Self::Inner {
    Self { _tab: flatbuffers::Table { buf, loc } }
  }
}

impl<'a> SpaceToDepthOptions<'a> {
  pub const VT_BLOCK_SIZE: flatbuffers::VOffsetT = 4;

  #[inline]
  pub fn init_from_table(table: flatbuffers::Table<'a>) -> Self {
    SpaceToDepthOptions { _tab: table }
  }
  #[allow(unused_mut)]
  pub fn create<'bldr: 'args, 'args: 'mut_bldr, 'mut_bldr>(
    _fbb: &'mut_bldr mut flatbuffers::FlatBufferBuilder<'bldr>,
    args: &'args SpaceToDepthOptionsArgs
  ) -> flatbuffers::WIPOffset<SpaceToDepthOptions<'bldr>> {
    let mut builder = SpaceToDepthOptionsBuilder::new(_fbb);
    builder.add_block_size(args.block_size);
    builder.finish()
  }

  pub fn unpack(&self) -> SpaceToDepthOptionsT {
    let block_size = self.block_size();
    SpaceToDepthOptionsT {
      block_size,
    }
  }

  #[inline]
  pub fn block_size(&self) -> i32 {
    self._tab.get::<i32>(SpaceToDepthOptions::VT_BLOCK_SIZE, Some(0)).unwrap()
  }
}

impl flatbuffers::Verifiable for SpaceToDepthOptions<'_> {
  #[inline]
  fn run_verifier(
    v: &mut flatbuffers::Verifier, pos: usize
  ) -> Result<(), flatbuffers::InvalidFlatbuffer> {
    use self::flatbuffers::Verifiable;
    v.visit_table(pos)?
     .visit_field::<i32>("block_size", Self::VT_BLOCK_SIZE, false)?
     .finish();
    Ok(())
  }
}
pub struct SpaceToDepthOptionsArgs {
    pub block_size: i32,
}
impl<'a> Default for SpaceToDepthOptionsArgs {
  #[inline]
  fn default() -> Self {
    SpaceToDepthOptionsArgs {
      block_size: 0,
    }
  }
}

pub struct SpaceToDepthOptionsBuilder<'a: 'b, 'b> {
  fbb_: &'b mut flatbuffers::FlatBufferBuilder<'a>,
  start_: flatbuffers::WIPOffset<flatbuffers::TableUnfinishedWIPOffset>,
}
impl<'a: 'b, 'b> SpaceToDepthOptionsBuilder<'a, 'b> {
  #[inline]
  pub fn add_block_size(&mut self, block_size: i32) {
    self.fbb_.push_slot::<i32>(SpaceToDepthOptions::VT_BLOCK_SIZE, block_size, 0);
  }
  #[inline]
  pub fn new(_fbb: &'b mut flatbuffers::FlatBufferBuilder<'a>) -> SpaceToDepthOptionsBuilder<'a, 'b> {
    let start = _fbb.start_table();
    SpaceToDepthOptionsBuilder {
      fbb_: _fbb,
      start_: start,
    }
  }
  #[inline]
  pub fn finish(self) -> flatbuffers::WIPOffset<SpaceToDepthOptions<'a>> {
    let o = self.fbb_.end_table(self.start_);
    flatbuffers::WIPOffset::new(o.value())
  }
}

impl core::fmt::Debug for SpaceToDepthOptions<'_> {
  fn fmt(&self, f: &mut core::fmt::Formatter<'_>) -> core::fmt::Result {
    let mut ds = f.debug_struct("SpaceToDepthOptions");
      ds.field("block_size", &self.block_size());
      ds.finish()
  }
}
#[non_exhaustive]
#[derive(Debug, Clone, PartialEq)]
pub struct SpaceToDepthOptionsT {
  pub block_size: i32,
}
impl Default for SpaceToDepthOptionsT {
  fn default() -> Self {
    Self {
      block_size: 0,
    }
  }
}
impl SpaceToDepthOptionsT {
  pub fn pack<'b>(
    &self,
    _fbb: &mut flatbuffers::FlatBufferBuilder<'b>
  ) -> flatbuffers::WIPOffset<SpaceToDepthOptions<'b>> {
    let block_size = self.block_size;
    SpaceToDepthOptions::create(_fbb, &SpaceToDepthOptionsArgs{
      block_size,
    })
  }
}
pub enum DepthToSpaceOptionsOffset {}
#[derive(Copy, Clone, PartialEq)]

pub struct DepthToSpaceOptions<'a> {
  pub _tab: flatbuffers::Table<'a>,
}

impl<'a> flatbuffers::Follow<'a> for DepthToSpaceOptions<'a> {
  type Inner = DepthToSpaceOptions<'a>;
  #[inline]
  fn follow(buf: &'a [u8], loc: usize) -> Self::Inner {
    Self { _tab: flatbuffers::Table { buf, loc } }
  }
}

impl<'a> DepthToSpaceOptions<'a> {
  pub const VT_BLOCK_SIZE: flatbuffers::VOffsetT = 4;

  #[inline]
  pub fn init_from_table(table: flatbuffers::Table<'a>) -> Self {
    DepthToSpaceOptions { _tab: table }
  }
  #[allow(unused_mut)]
  pub fn create<'bldr: 'args, 'args: 'mut_bldr, 'mut_bldr>(
    _fbb: &'mut_bldr mut flatbuffers::FlatBufferBuilder<'bldr>,
    args: &'args DepthToSpaceOptionsArgs
  ) -> flatbuffers::WIPOffset<DepthToSpaceOptions<'bldr>> {
    let mut builder = DepthToSpaceOptionsBuilder::new(_fbb);
    builder.add_block_size(args.block_size);
    builder.finish()
  }

  pub fn unpack(&self) -> DepthToSpaceOptionsT {
    let block_size = self.block_size();
    DepthToSpaceOptionsT {
      block_size,
    }
  }

  #[inline]
  pub fn block_size(&self) -> i32 {
    self._tab.get::<i32>(DepthToSpaceOptions::VT_BLOCK_SIZE, Some(0)).unwrap()
  }
}

impl flatbuffers::Verifiable for DepthToSpaceOptions<'_> {
  #[inline]
  fn run_verifier(
    v: &mut flatbuffers::Verifier, pos: usize
  ) -> Result<(), flatbuffers::InvalidFlatbuffer> {
    use self::flatbuffers::Verifiable;
    v.visit_table(pos)?
     .visit_field::<i32>("block_size", Self::VT_BLOCK_SIZE, false)?
     .finish();
    Ok(())
  }
}
pub struct DepthToSpaceOptionsArgs {
    pub block_size: i32,
}
impl<'a> Default for DepthToSpaceOptionsArgs {
  #[inline]
  fn default() -> Self {
    DepthToSpaceOptionsArgs {
      block_size: 0,
    }
  }
}

pub struct DepthToSpaceOptionsBuilder<'a: 'b, 'b> {
  fbb_: &'b mut flatbuffers::FlatBufferBuilder<'a>,
  start_: flatbuffers::WIPOffset<flatbuffers::TableUnfinishedWIPOffset>,
}
impl<'a: 'b, 'b> DepthToSpaceOptionsBuilder<'a, 'b> {
  #[inline]
  pub fn add_block_size(&mut self, block_size: i32) {
    self.fbb_.push_slot::<i32>(DepthToSpaceOptions::VT_BLOCK_SIZE, block_size, 0);
  }
  #[inline]
  pub fn new(_fbb: &'b mut flatbuffers::FlatBufferBuilder<'a>) -> DepthToSpaceOptionsBuilder<'a, 'b> {
    let start = _fbb.start_table();
    DepthToSpaceOptionsBuilder {
      fbb_: _fbb,
      start_: start,
    }
  }
  #[inline]
  pub fn finish(self) -> flatbuffers::WIPOffset<DepthToSpaceOptions<'a>> {
    let o = self.fbb_.end_table(self.start_);
    flatbuffers::WIPOffset::new(o.value())
  }
}

impl core::fmt::Debug for DepthToSpaceOptions<'_> {
  fn fmt(&self, f: &mut core::fmt::Formatter<'_>) -> core::fmt::Result {
    let mut ds = f.debug_struct("DepthToSpaceOptions");
      ds.field("block_size", &self.block_size());
      ds.finish()
  }
}
#[non_exhaustive]
#[derive(Debug, Clone, PartialEq)]
pub struct DepthToSpaceOptionsT {
  pub block_size: i32,
}
impl Default for DepthToSpaceOptionsT {
  fn default() -> Self {
    Self {
      block_size: 0,
    }
  }
}
impl DepthToSpaceOptionsT {
  pub fn pack<'b>(
    &self,
    _fbb: &mut flatbuffers::FlatBufferBuilder<'b>
  ) -> flatbuffers::WIPOffset<DepthToSpaceOptions<'b>> {
    let block_size = self.block_size;
    DepthToSpaceOptions::create(_fbb, &DepthToSpaceOptionsArgs{
      block_size,
    })
  }
}
pub enum SubOptionsOffset {}
#[derive(Copy, Clone, PartialEq)]

pub struct SubOptions<'a> {
  pub _tab: flatbuffers::Table<'a>,
}

impl<'a> flatbuffers::Follow<'a> for SubOptions<'a> {
  type Inner = SubOptions<'a>;
  #[inline]
  fn follow(buf: &'a [u8], loc: usize) -> Self::Inner {
    Self { _tab: flatbuffers::Table { buf, loc } }
  }
}

impl<'a> SubOptions<'a> {
  pub const VT_FUSED_ACTIVATION_FUNCTION: flatbuffers::VOffsetT = 4;

  #[inline]
  pub fn init_from_table(table: flatbuffers::Table<'a>) -> Self {
    SubOptions { _tab: table }
  }
  #[allow(unused_mut)]
  pub fn create<'bldr: 'args, 'args: 'mut_bldr, 'mut_bldr>(
    _fbb: &'mut_bldr mut flatbuffers::FlatBufferBuilder<'bldr>,
    args: &'args SubOptionsArgs
  ) -> flatbuffers::WIPOffset<SubOptions<'bldr>> {
    let mut builder = SubOptionsBuilder::new(_fbb);
    builder.add_fused_activation_function(args.fused_activation_function);
    builder.finish()
  }

  pub fn unpack(&self) -> SubOptionsT {
    let fused_activation_function = self.fused_activation_function();
    SubOptionsT {
      fused_activation_function,
    }
  }

  #[inline]
  pub fn fused_activation_function(&self) -> ActivationFunctionType {
    self._tab.get::<ActivationFunctionType>(SubOptions::VT_FUSED_ACTIVATION_FUNCTION, Some(ActivationFunctionType::NONE)).unwrap()
  }
}

impl flatbuffers::Verifiable for SubOptions<'_> {
  #[inline]
  fn run_verifier(
    v: &mut flatbuffers::Verifier, pos: usize
  ) -> Result<(), flatbuffers::InvalidFlatbuffer> {
    use self::flatbuffers::Verifiable;
    v.visit_table(pos)?
     .visit_field::<ActivationFunctionType>("fused_activation_function", Self::VT_FUSED_ACTIVATION_FUNCTION, false)?
     .finish();
    Ok(())
  }
}
pub struct SubOptionsArgs {
    pub fused_activation_function: ActivationFunctionType,
}
impl<'a> Default for SubOptionsArgs {
  #[inline]
  fn default() -> Self {
    SubOptionsArgs {
      fused_activation_function: ActivationFunctionType::NONE,
    }
  }
}

pub struct SubOptionsBuilder<'a: 'b, 'b> {
  fbb_: &'b mut flatbuffers::FlatBufferBuilder<'a>,
  start_: flatbuffers::WIPOffset<flatbuffers::TableUnfinishedWIPOffset>,
}
impl<'a: 'b, 'b> SubOptionsBuilder<'a, 'b> {
  #[inline]
  pub fn add_fused_activation_function(&mut self, fused_activation_function: ActivationFunctionType) {
    self.fbb_.push_slot::<ActivationFunctionType>(SubOptions::VT_FUSED_ACTIVATION_FUNCTION, fused_activation_function, ActivationFunctionType::NONE);
  }
  #[inline]
  pub fn new(_fbb: &'b mut flatbuffers::FlatBufferBuilder<'a>) -> SubOptionsBuilder<'a, 'b> {
    let start = _fbb.start_table();
    SubOptionsBuilder {
      fbb_: _fbb,
      start_: start,
    }
  }
  #[inline]
  pub fn finish(self) -> flatbuffers::WIPOffset<SubOptions<'a>> {
    let o = self.fbb_.end_table(self.start_);
    flatbuffers::WIPOffset::new(o.value())
  }
}

impl core::fmt::Debug for SubOptions<'_> {
  fn fmt(&self, f: &mut core::fmt::Formatter<'_>) -> core::fmt::Result {
    let mut ds = f.debug_struct("SubOptions");
      ds.field("fused_activation_function", &self.fused_activation_function());
      ds.finish()
  }
}
#[non_exhaustive]
#[derive(Debug, Clone, PartialEq)]
pub struct SubOptionsT {
  pub fused_activation_function: ActivationFunctionType,
}
impl Default for SubOptionsT {
  fn default() -> Self {
    Self {
      fused_activation_function: ActivationFunctionType::NONE,
    }
  }
}
impl SubOptionsT {
  pub fn pack<'b>(
    &self,
    _fbb: &mut flatbuffers::FlatBufferBuilder<'b>
  ) -> flatbuffers::WIPOffset<SubOptions<'b>> {
    let fused_activation_function = self.fused_activation_function;
    SubOptions::create(_fbb, &SubOptionsArgs{
      fused_activation_function,
    })
  }
}
pub enum DivOptionsOffset {}
#[derive(Copy, Clone, PartialEq)]

pub struct DivOptions<'a> {
  pub _tab: flatbuffers::Table<'a>,
}

impl<'a> flatbuffers::Follow<'a> for DivOptions<'a> {
  type Inner = DivOptions<'a>;
  #[inline]
  fn follow(buf: &'a [u8], loc: usize) -> Self::Inner {
    Self { _tab: flatbuffers::Table { buf, loc } }
  }
}

impl<'a> DivOptions<'a> {
  pub const VT_FUSED_ACTIVATION_FUNCTION: flatbuffers::VOffsetT = 4;

  #[inline]
  pub fn init_from_table(table: flatbuffers::Table<'a>) -> Self {
    DivOptions { _tab: table }
  }
  #[allow(unused_mut)]
  pub fn create<'bldr: 'args, 'args: 'mut_bldr, 'mut_bldr>(
    _fbb: &'mut_bldr mut flatbuffers::FlatBufferBuilder<'bldr>,
    args: &'args DivOptionsArgs
  ) -> flatbuffers::WIPOffset<DivOptions<'bldr>> {
    let mut builder = DivOptionsBuilder::new(_fbb);
    builder.add_fused_activation_function(args.fused_activation_function);
    builder.finish()
  }

  pub fn unpack(&self) -> DivOptionsT {
    let fused_activation_function = self.fused_activation_function();
    DivOptionsT {
      fused_activation_function,
    }
  }

  #[inline]
  pub fn fused_activation_function(&self) -> ActivationFunctionType {
    self._tab.get::<ActivationFunctionType>(DivOptions::VT_FUSED_ACTIVATION_FUNCTION, Some(ActivationFunctionType::NONE)).unwrap()
  }
}

impl flatbuffers::Verifiable for DivOptions<'_> {
  #[inline]
  fn run_verifier(
    v: &mut flatbuffers::Verifier, pos: usize
  ) -> Result<(), flatbuffers::InvalidFlatbuffer> {
    use self::flatbuffers::Verifiable;
    v.visit_table(pos)?
     .visit_field::<ActivationFunctionType>("fused_activation_function", Self::VT_FUSED_ACTIVATION_FUNCTION, false)?
     .finish();
    Ok(())
  }
}
pub struct DivOptionsArgs {
    pub fused_activation_function: ActivationFunctionType,
}
impl<'a> Default for DivOptionsArgs {
  #[inline]
  fn default() -> Self {
    DivOptionsArgs {
      fused_activation_function: ActivationFunctionType::NONE,
    }
  }
}

pub struct DivOptionsBuilder<'a: 'b, 'b> {
  fbb_: &'b mut flatbuffers::FlatBufferBuilder<'a>,
  start_: flatbuffers::WIPOffset<flatbuffers::TableUnfinishedWIPOffset>,
}
impl<'a: 'b, 'b> DivOptionsBuilder<'a, 'b> {
  #[inline]
  pub fn add_fused_activation_function(&mut self, fused_activation_function: ActivationFunctionType) {
    self.fbb_.push_slot::<ActivationFunctionType>(DivOptions::VT_FUSED_ACTIVATION_FUNCTION, fused_activation_function, ActivationFunctionType::NONE);
  }
  #[inline]
  pub fn new(_fbb: &'b mut flatbuffers::FlatBufferBuilder<'a>) -> DivOptionsBuilder<'a, 'b> {
    let start = _fbb.start_table();
    DivOptionsBuilder {
      fbb_: _fbb,
      start_: start,
    }
  }
  #[inline]
  pub fn finish(self) -> flatbuffers::WIPOffset<DivOptions<'a>> {
    let o = self.fbb_.end_table(self.start_);
    flatbuffers::WIPOffset::new(o.value())
  }
}

impl core::fmt::Debug for DivOptions<'_> {
  fn fmt(&self, f: &mut core::fmt::Formatter<'_>) -> core::fmt::Result {
    let mut ds = f.debug_struct("DivOptions");
      ds.field("fused_activation_function", &self.fused_activation_function());
      ds.finish()
  }
}
#[non_exhaustive]
#[derive(Debug, Clone, PartialEq)]
pub struct DivOptionsT {
  pub fused_activation_function: ActivationFunctionType,
}
impl Default for DivOptionsT {
  fn default() -> Self {
    Self {
      fused_activation_function: ActivationFunctionType::NONE,
    }
  }
}
impl DivOptionsT {
  pub fn pack<'b>(
    &self,
    _fbb: &mut flatbuffers::FlatBufferBuilder<'b>
  ) -> flatbuffers::WIPOffset<DivOptions<'b>> {
    let fused_activation_function = self.fused_activation_function;
    DivOptions::create(_fbb, &DivOptionsArgs{
      fused_activation_function,
    })
  }
}
pub enum TopKV2OptionsOffset {}
#[derive(Copy, Clone, PartialEq)]

pub struct TopKV2Options<'a> {
  pub _tab: flatbuffers::Table<'a>,
}

impl<'a> flatbuffers::Follow<'a> for TopKV2Options<'a> {
  type Inner = TopKV2Options<'a>;
  #[inline]
  fn follow(buf: &'a [u8], loc: usize) -> Self::Inner {
    Self { _tab: flatbuffers::Table { buf, loc } }
  }
}

impl<'a> TopKV2Options<'a> {

  #[inline]
  pub fn init_from_table(table: flatbuffers::Table<'a>) -> Self {
    TopKV2Options { _tab: table }
  }
  #[allow(unused_mut)]
  pub fn create<'bldr: 'args, 'args: 'mut_bldr, 'mut_bldr>(
    _fbb: &'mut_bldr mut flatbuffers::FlatBufferBuilder<'bldr>,
    _args: &'args TopKV2OptionsArgs
  ) -> flatbuffers::WIPOffset<TopKV2Options<'bldr>> {
    let mut builder = TopKV2OptionsBuilder::new(_fbb);
    builder.finish()
  }

  pub fn unpack(&self) -> TopKV2OptionsT {
    TopKV2OptionsT {
    }
  }
}

impl flatbuffers::Verifiable for TopKV2Options<'_> {
  #[inline]
  fn run_verifier(
    v: &mut flatbuffers::Verifier, pos: usize
  ) -> Result<(), flatbuffers::InvalidFlatbuffer> {
    use self::flatbuffers::Verifiable;
    v.visit_table(pos)?
     .finish();
    Ok(())
  }
}
pub struct TopKV2OptionsArgs {
}
impl<'a> Default for TopKV2OptionsArgs {
  #[inline]
  fn default() -> Self {
    TopKV2OptionsArgs {
    }
  }
}

pub struct TopKV2OptionsBuilder<'a: 'b, 'b> {
  fbb_: &'b mut flatbuffers::FlatBufferBuilder<'a>,
  start_: flatbuffers::WIPOffset<flatbuffers::TableUnfinishedWIPOffset>,
}
impl<'a: 'b, 'b> TopKV2OptionsBuilder<'a, 'b> {
  #[inline]
  pub fn new(_fbb: &'b mut flatbuffers::FlatBufferBuilder<'a>) -> TopKV2OptionsBuilder<'a, 'b> {
    let start = _fbb.start_table();
    TopKV2OptionsBuilder {
      fbb_: _fbb,
      start_: start,
    }
  }
  #[inline]
  pub fn finish(self) -> flatbuffers::WIPOffset<TopKV2Options<'a>> {
    let o = self.fbb_.end_table(self.start_);
    flatbuffers::WIPOffset::new(o.value())
  }
}

impl core::fmt::Debug for TopKV2Options<'_> {
  fn fmt(&self, f: &mut core::fmt::Formatter<'_>) -> core::fmt::Result {
    let mut ds = f.debug_struct("TopKV2Options");
      ds.finish()
  }
}
#[non_exhaustive]
#[derive(Debug, Clone, PartialEq)]
pub struct TopKV2OptionsT {
}
impl Default for TopKV2OptionsT {
  fn default() -> Self {
    Self {
    }
  }
}
impl TopKV2OptionsT {
  pub fn pack<'b>(
    &self,
    _fbb: &mut flatbuffers::FlatBufferBuilder<'b>
  ) -> flatbuffers::WIPOffset<TopKV2Options<'b>> {
    TopKV2Options::create(_fbb, &TopKV2OptionsArgs{
    })
  }
}
pub enum EmbeddingLookupSparseOptionsOffset {}
#[derive(Copy, Clone, PartialEq)]

pub struct EmbeddingLookupSparseOptions<'a> {
  pub _tab: flatbuffers::Table<'a>,
}

impl<'a> flatbuffers::Follow<'a> for EmbeddingLookupSparseOptions<'a> {
  type Inner = EmbeddingLookupSparseOptions<'a>;
  #[inline]
  fn follow(buf: &'a [u8], loc: usize) -> Self::Inner {
    Self { _tab: flatbuffers::Table { buf, loc } }
  }
}

impl<'a> EmbeddingLookupSparseOptions<'a> {
  pub const VT_COMBINER: flatbuffers::VOffsetT = 4;

  #[inline]
  pub fn init_from_table(table: flatbuffers::Table<'a>) -> Self {
    EmbeddingLookupSparseOptions { _tab: table }
  }
  #[allow(unused_mut)]
  pub fn create<'bldr: 'args, 'args: 'mut_bldr, 'mut_bldr>(
    _fbb: &'mut_bldr mut flatbuffers::FlatBufferBuilder<'bldr>,
    args: &'args EmbeddingLookupSparseOptionsArgs
  ) -> flatbuffers::WIPOffset<EmbeddingLookupSparseOptions<'bldr>> {
    let mut builder = EmbeddingLookupSparseOptionsBuilder::new(_fbb);
    builder.add_combiner(args.combiner);
    builder.finish()
  }

  pub fn unpack(&self) -> EmbeddingLookupSparseOptionsT {
    let combiner = self.combiner();
    EmbeddingLookupSparseOptionsT {
      combiner,
    }
  }

  #[inline]
  pub fn combiner(&self) -> CombinerType {
    self._tab.get::<CombinerType>(EmbeddingLookupSparseOptions::VT_COMBINER, Some(CombinerType::SUM)).unwrap()
  }
}

impl flatbuffers::Verifiable for EmbeddingLookupSparseOptions<'_> {
  #[inline]
  fn run_verifier(
    v: &mut flatbuffers::Verifier, pos: usize
  ) -> Result<(), flatbuffers::InvalidFlatbuffer> {
    use self::flatbuffers::Verifiable;
    v.visit_table(pos)?
     .visit_field::<CombinerType>("combiner", Self::VT_COMBINER, false)?
     .finish();
    Ok(())
  }
}
pub struct EmbeddingLookupSparseOptionsArgs {
    pub combiner: CombinerType,
}
impl<'a> Default for EmbeddingLookupSparseOptionsArgs {
  #[inline]
  fn default() -> Self {
    EmbeddingLookupSparseOptionsArgs {
      combiner: CombinerType::SUM,
    }
  }
}

pub struct EmbeddingLookupSparseOptionsBuilder<'a: 'b, 'b> {
  fbb_: &'b mut flatbuffers::FlatBufferBuilder<'a>,
  start_: flatbuffers::WIPOffset<flatbuffers::TableUnfinishedWIPOffset>,
}
impl<'a: 'b, 'b> EmbeddingLookupSparseOptionsBuilder<'a, 'b> {
  #[inline]
  pub fn add_combiner(&mut self, combiner: CombinerType) {
    self.fbb_.push_slot::<CombinerType>(EmbeddingLookupSparseOptions::VT_COMBINER, combiner, CombinerType::SUM);
  }
  #[inline]
  pub fn new(_fbb: &'b mut flatbuffers::FlatBufferBuilder<'a>) -> EmbeddingLookupSparseOptionsBuilder<'a, 'b> {
    let start = _fbb.start_table();
    EmbeddingLookupSparseOptionsBuilder {
      fbb_: _fbb,
      start_: start,
    }
  }
  #[inline]
  pub fn finish(self) -> flatbuffers::WIPOffset<EmbeddingLookupSparseOptions<'a>> {
    let o = self.fbb_.end_table(self.start_);
    flatbuffers::WIPOffset::new(o.value())
  }
}

impl core::fmt::Debug for EmbeddingLookupSparseOptions<'_> {
  fn fmt(&self, f: &mut core::fmt::Formatter<'_>) -> core::fmt::Result {
    let mut ds = f.debug_struct("EmbeddingLookupSparseOptions");
      ds.field("combiner", &self.combiner());
      ds.finish()
  }
}
#[non_exhaustive]
#[derive(Debug, Clone, PartialEq)]
pub struct EmbeddingLookupSparseOptionsT {
  pub combiner: CombinerType,
}
impl Default for EmbeddingLookupSparseOptionsT {
  fn default() -> Self {
    Self {
      combiner: CombinerType::SUM,
    }
  }
}
impl EmbeddingLookupSparseOptionsT {
  pub fn pack<'b>(
    &self,
    _fbb: &mut flatbuffers::FlatBufferBuilder<'b>
  ) -> flatbuffers::WIPOffset<EmbeddingLookupSparseOptions<'b>> {
    let combiner = self.combiner;
    EmbeddingLookupSparseOptions::create(_fbb, &EmbeddingLookupSparseOptionsArgs{
      combiner,
    })
  }
}
pub enum GatherOptionsOffset {}
#[derive(Copy, Clone, PartialEq)]

pub struct GatherOptions<'a> {
  pub _tab: flatbuffers::Table<'a>,
}

impl<'a> flatbuffers::Follow<'a> for GatherOptions<'a> {
  type Inner = GatherOptions<'a>;
  #[inline]
  fn follow(buf: &'a [u8], loc: usize) -> Self::Inner {
    Self { _tab: flatbuffers::Table { buf, loc } }
  }
}

impl<'a> GatherOptions<'a> {
  pub const VT_AXIS: flatbuffers::VOffsetT = 4;

  #[inline]
  pub fn init_from_table(table: flatbuffers::Table<'a>) -> Self {
    GatherOptions { _tab: table }
  }
  #[allow(unused_mut)]
  pub fn create<'bldr: 'args, 'args: 'mut_bldr, 'mut_bldr>(
    _fbb: &'mut_bldr mut flatbuffers::FlatBufferBuilder<'bldr>,
    args: &'args GatherOptionsArgs
  ) -> flatbuffers::WIPOffset<GatherOptions<'bldr>> {
    let mut builder = GatherOptionsBuilder::new(_fbb);
    builder.add_axis(args.axis);
    builder.finish()
  }

  pub fn unpack(&self) -> GatherOptionsT {
    let axis = self.axis();
    GatherOptionsT {
      axis,
    }
  }

  #[inline]
  pub fn axis(&self) -> i32 {
    self._tab.get::<i32>(GatherOptions::VT_AXIS, Some(0)).unwrap()
  }
}

impl flatbuffers::Verifiable for GatherOptions<'_> {
  #[inline]
  fn run_verifier(
    v: &mut flatbuffers::Verifier, pos: usize
  ) -> Result<(), flatbuffers::InvalidFlatbuffer> {
    use self::flatbuffers::Verifiable;
    v.visit_table(pos)?
     .visit_field::<i32>("axis", Self::VT_AXIS, false)?
     .finish();
    Ok(())
  }
}
pub struct GatherOptionsArgs {
    pub axis: i32,
}
impl<'a> Default for GatherOptionsArgs {
  #[inline]
  fn default() -> Self {
    GatherOptionsArgs {
      axis: 0,
    }
  }
}

pub struct GatherOptionsBuilder<'a: 'b, 'b> {
  fbb_: &'b mut flatbuffers::FlatBufferBuilder<'a>,
  start_: flatbuffers::WIPOffset<flatbuffers::TableUnfinishedWIPOffset>,
}
impl<'a: 'b, 'b> GatherOptionsBuilder<'a, 'b> {
  #[inline]
  pub fn add_axis(&mut self, axis: i32) {
    self.fbb_.push_slot::<i32>(GatherOptions::VT_AXIS, axis, 0);
  }
  #[inline]
  pub fn new(_fbb: &'b mut flatbuffers::FlatBufferBuilder<'a>) -> GatherOptionsBuilder<'a, 'b> {
    let start = _fbb.start_table();
    GatherOptionsBuilder {
      fbb_: _fbb,
      start_: start,
    }
  }
  #[inline]
  pub fn finish(self) -> flatbuffers::WIPOffset<GatherOptions<'a>> {
    let o = self.fbb_.end_table(self.start_);
    flatbuffers::WIPOffset::new(o.value())
  }
}

impl core::fmt::Debug for GatherOptions<'_> {
  fn fmt(&self, f: &mut core::fmt::Formatter<'_>) -> core::fmt::Result {
    let mut ds = f.debug_struct("GatherOptions");
      ds.field("axis", &self.axis());
      ds.finish()
  }
}
#[non_exhaustive]
#[derive(Debug, Clone, PartialEq)]
pub struct GatherOptionsT {
  pub axis: i32,
}
impl Default for GatherOptionsT {
  fn default() -> Self {
    Self {
      axis: 0,
    }
  }
}
impl GatherOptionsT {
  pub fn pack<'b>(
    &self,
    _fbb: &mut flatbuffers::FlatBufferBuilder<'b>
  ) -> flatbuffers::WIPOffset<GatherOptions<'b>> {
    let axis = self.axis;
    GatherOptions::create(_fbb, &GatherOptionsArgs{
      axis,
    })
  }
}
pub enum TransposeOptionsOffset {}
#[derive(Copy, Clone, PartialEq)]

pub struct TransposeOptions<'a> {
  pub _tab: flatbuffers::Table<'a>,
}

impl<'a> flatbuffers::Follow<'a> for TransposeOptions<'a> {
  type Inner = TransposeOptions<'a>;
  #[inline]
  fn follow(buf: &'a [u8], loc: usize) -> Self::Inner {
    Self { _tab: flatbuffers::Table { buf, loc } }
  }
}

impl<'a> TransposeOptions<'a> {

  #[inline]
  pub fn init_from_table(table: flatbuffers::Table<'a>) -> Self {
    TransposeOptions { _tab: table }
  }
  #[allow(unused_mut)]
  pub fn create<'bldr: 'args, 'args: 'mut_bldr, 'mut_bldr>(
    _fbb: &'mut_bldr mut flatbuffers::FlatBufferBuilder<'bldr>,
    _args: &'args TransposeOptionsArgs
  ) -> flatbuffers::WIPOffset<TransposeOptions<'bldr>> {
    let mut builder = TransposeOptionsBuilder::new(_fbb);
    builder.finish()
  }

  pub fn unpack(&self) -> TransposeOptionsT {
    TransposeOptionsT {
    }
  }
}

impl flatbuffers::Verifiable for TransposeOptions<'_> {
  #[inline]
  fn run_verifier(
    v: &mut flatbuffers::Verifier, pos: usize
  ) -> Result<(), flatbuffers::InvalidFlatbuffer> {
    use self::flatbuffers::Verifiable;
    v.visit_table(pos)?
     .finish();
    Ok(())
  }
}
pub struct TransposeOptionsArgs {
}
impl<'a> Default for TransposeOptionsArgs {
  #[inline]
  fn default() -> Self {
    TransposeOptionsArgs {
    }
  }
}

pub struct TransposeOptionsBuilder<'a: 'b, 'b> {
  fbb_: &'b mut flatbuffers::FlatBufferBuilder<'a>,
  start_: flatbuffers::WIPOffset<flatbuffers::TableUnfinishedWIPOffset>,
}
impl<'a: 'b, 'b> TransposeOptionsBuilder<'a, 'b> {
  #[inline]
  pub fn new(_fbb: &'b mut flatbuffers::FlatBufferBuilder<'a>) -> TransposeOptionsBuilder<'a, 'b> {
    let start = _fbb.start_table();
    TransposeOptionsBuilder {
      fbb_: _fbb,
      start_: start,
    }
  }
  #[inline]
  pub fn finish(self) -> flatbuffers::WIPOffset<TransposeOptions<'a>> {
    let o = self.fbb_.end_table(self.start_);
    flatbuffers::WIPOffset::new(o.value())
  }
}

impl core::fmt::Debug for TransposeOptions<'_> {
  fn fmt(&self, f: &mut core::fmt::Formatter<'_>) -> core::fmt::Result {
    let mut ds = f.debug_struct("TransposeOptions");
      ds.finish()
  }
}
#[non_exhaustive]
#[derive(Debug, Clone, PartialEq)]
pub struct TransposeOptionsT {
}
impl Default for TransposeOptionsT {
  fn default() -> Self {
    Self {
    }
  }
}
impl TransposeOptionsT {
  pub fn pack<'b>(
    &self,
    _fbb: &mut flatbuffers::FlatBufferBuilder<'b>
  ) -> flatbuffers::WIPOffset<TransposeOptions<'b>> {
    TransposeOptions::create(_fbb, &TransposeOptionsArgs{
    })
  }
}
pub enum ExpOptionsOffset {}
#[derive(Copy, Clone, PartialEq)]

pub struct ExpOptions<'a> {
  pub _tab: flatbuffers::Table<'a>,
}

impl<'a> flatbuffers::Follow<'a> for ExpOptions<'a> {
  type Inner = ExpOptions<'a>;
  #[inline]
  fn follow(buf: &'a [u8], loc: usize) -> Self::Inner {
    Self { _tab: flatbuffers::Table { buf, loc } }
  }
}

impl<'a> ExpOptions<'a> {

  #[inline]
  pub fn init_from_table(table: flatbuffers::Table<'a>) -> Self {
    ExpOptions { _tab: table }
  }
  #[allow(unused_mut)]
  pub fn create<'bldr: 'args, 'args: 'mut_bldr, 'mut_bldr>(
    _fbb: &'mut_bldr mut flatbuffers::FlatBufferBuilder<'bldr>,
    _args: &'args ExpOptionsArgs
  ) -> flatbuffers::WIPOffset<ExpOptions<'bldr>> {
    let mut builder = ExpOptionsBuilder::new(_fbb);
    builder.finish()
  }

  pub fn unpack(&self) -> ExpOptionsT {
    ExpOptionsT {
    }
  }
}

impl flatbuffers::Verifiable for ExpOptions<'_> {
  #[inline]
  fn run_verifier(
    v: &mut flatbuffers::Verifier, pos: usize
  ) -> Result<(), flatbuffers::InvalidFlatbuffer> {
    use self::flatbuffers::Verifiable;
    v.visit_table(pos)?
     .finish();
    Ok(())
  }
}
pub struct ExpOptionsArgs {
}
impl<'a> Default for ExpOptionsArgs {
  #[inline]
  fn default() -> Self {
    ExpOptionsArgs {
    }
  }
}

pub struct ExpOptionsBuilder<'a: 'b, 'b> {
  fbb_: &'b mut flatbuffers::FlatBufferBuilder<'a>,
  start_: flatbuffers::WIPOffset<flatbuffers::TableUnfinishedWIPOffset>,
}
impl<'a: 'b, 'b> ExpOptionsBuilder<'a, 'b> {
  #[inline]
  pub fn new(_fbb: &'b mut flatbuffers::FlatBufferBuilder<'a>) -> ExpOptionsBuilder<'a, 'b> {
    let start = _fbb.start_table();
    ExpOptionsBuilder {
      fbb_: _fbb,
      start_: start,
    }
  }
  #[inline]
  pub fn finish(self) -> flatbuffers::WIPOffset<ExpOptions<'a>> {
    let o = self.fbb_.end_table(self.start_);
    flatbuffers::WIPOffset::new(o.value())
  }
}

impl core::fmt::Debug for ExpOptions<'_> {
  fn fmt(&self, f: &mut core::fmt::Formatter<'_>) -> core::fmt::Result {
    let mut ds = f.debug_struct("ExpOptions");
      ds.finish()
  }
}
#[non_exhaustive]
#[derive(Debug, Clone, PartialEq)]
pub struct ExpOptionsT {
}
impl Default for ExpOptionsT {
  fn default() -> Self {
    Self {
    }
  }
}
impl ExpOptionsT {
  pub fn pack<'b>(
    &self,
    _fbb: &mut flatbuffers::FlatBufferBuilder<'b>
  ) -> flatbuffers::WIPOffset<ExpOptions<'b>> {
    ExpOptions::create(_fbb, &ExpOptionsArgs{
    })
  }
}
pub enum CosOptionsOffset {}
#[derive(Copy, Clone, PartialEq)]

pub struct CosOptions<'a> {
  pub _tab: flatbuffers::Table<'a>,
}

impl<'a> flatbuffers::Follow<'a> for CosOptions<'a> {
  type Inner = CosOptions<'a>;
  #[inline]
  fn follow(buf: &'a [u8], loc: usize) -> Self::Inner {
    Self { _tab: flatbuffers::Table { buf, loc } }
  }
}

impl<'a> CosOptions<'a> {

  #[inline]
  pub fn init_from_table(table: flatbuffers::Table<'a>) -> Self {
    CosOptions { _tab: table }
  }
  #[allow(unused_mut)]
  pub fn create<'bldr: 'args, 'args: 'mut_bldr, 'mut_bldr>(
    _fbb: &'mut_bldr mut flatbuffers::FlatBufferBuilder<'bldr>,
    _args: &'args CosOptionsArgs
  ) -> flatbuffers::WIPOffset<CosOptions<'bldr>> {
    let mut builder = CosOptionsBuilder::new(_fbb);
    builder.finish()
  }

  pub fn unpack(&self) -> CosOptionsT {
    CosOptionsT {
    }
  }
}

impl flatbuffers::Verifiable for CosOptions<'_> {
  #[inline]
  fn run_verifier(
    v: &mut flatbuffers::Verifier, pos: usize
  ) -> Result<(), flatbuffers::InvalidFlatbuffer> {
    use self::flatbuffers::Verifiable;
    v.visit_table(pos)?
     .finish();
    Ok(())
  }
}
pub struct CosOptionsArgs {
}
impl<'a> Default for CosOptionsArgs {
  #[inline]
  fn default() -> Self {
    CosOptionsArgs {
    }
  }
}

pub struct CosOptionsBuilder<'a: 'b, 'b> {
  fbb_: &'b mut flatbuffers::FlatBufferBuilder<'a>,
  start_: flatbuffers::WIPOffset<flatbuffers::TableUnfinishedWIPOffset>,
}
impl<'a: 'b, 'b> CosOptionsBuilder<'a, 'b> {
  #[inline]
  pub fn new(_fbb: &'b mut flatbuffers::FlatBufferBuilder<'a>) -> CosOptionsBuilder<'a, 'b> {
    let start = _fbb.start_table();
    CosOptionsBuilder {
      fbb_: _fbb,
      start_: start,
    }
  }
  #[inline]
  pub fn finish(self) -> flatbuffers::WIPOffset<CosOptions<'a>> {
    let o = self.fbb_.end_table(self.start_);
    flatbuffers::WIPOffset::new(o.value())
  }
}

impl core::fmt::Debug for CosOptions<'_> {
  fn fmt(&self, f: &mut core::fmt::Formatter<'_>) -> core::fmt::Result {
    let mut ds = f.debug_struct("CosOptions");
      ds.finish()
  }
}
#[non_exhaustive]
#[derive(Debug, Clone, PartialEq)]
pub struct CosOptionsT {
}
impl Default for CosOptionsT {
  fn default() -> Self {
    Self {
    }
  }
}
impl CosOptionsT {
  pub fn pack<'b>(
    &self,
    _fbb: &mut flatbuffers::FlatBufferBuilder<'b>
  ) -> flatbuffers::WIPOffset<CosOptions<'b>> {
    CosOptions::create(_fbb, &CosOptionsArgs{
    })
  }
}
pub enum ReducerOptionsOffset {}
#[derive(Copy, Clone, PartialEq)]

pub struct ReducerOptions<'a> {
  pub _tab: flatbuffers::Table<'a>,
}

impl<'a> flatbuffers::Follow<'a> for ReducerOptions<'a> {
  type Inner = ReducerOptions<'a>;
  #[inline]
  fn follow(buf: &'a [u8], loc: usize) -> Self::Inner {
    Self { _tab: flatbuffers::Table { buf, loc } }
  }
}

impl<'a> ReducerOptions<'a> {
  pub const VT_KEEP_DIMS: flatbuffers::VOffsetT = 4;

  #[inline]
  pub fn init_from_table(table: flatbuffers::Table<'a>) -> Self {
    ReducerOptions { _tab: table }
  }
  #[allow(unused_mut)]
  pub fn create<'bldr: 'args, 'args: 'mut_bldr, 'mut_bldr>(
    _fbb: &'mut_bldr mut flatbuffers::FlatBufferBuilder<'bldr>,
    args: &'args ReducerOptionsArgs
  ) -> flatbuffers::WIPOffset<ReducerOptions<'bldr>> {
    let mut builder = ReducerOptionsBuilder::new(_fbb);
    builder.add_keep_dims(args.keep_dims);
    builder.finish()
  }

  pub fn unpack(&self) -> ReducerOptionsT {
    let keep_dims = self.keep_dims();
    ReducerOptionsT {
      keep_dims,
    }
  }

  #[inline]
  pub fn keep_dims(&self) -> bool {
    self._tab.get::<bool>(ReducerOptions::VT_KEEP_DIMS, Some(false)).unwrap()
  }
}

impl flatbuffers::Verifiable for ReducerOptions<'_> {
  #[inline]
  fn run_verifier(
    v: &mut flatbuffers::Verifier, pos: usize
  ) -> Result<(), flatbuffers::InvalidFlatbuffer> {
    use self::flatbuffers::Verifiable;
    v.visit_table(pos)?
     .visit_field::<bool>("keep_dims", Self::VT_KEEP_DIMS, false)?
     .finish();
    Ok(())
  }
}
pub struct ReducerOptionsArgs {
    pub keep_dims: bool,
}
impl<'a> Default for ReducerOptionsArgs {
  #[inline]
  fn default() -> Self {
    ReducerOptionsArgs {
      keep_dims: false,
    }
  }
}

pub struct ReducerOptionsBuilder<'a: 'b, 'b> {
  fbb_: &'b mut flatbuffers::FlatBufferBuilder<'a>,
  start_: flatbuffers::WIPOffset<flatbuffers::TableUnfinishedWIPOffset>,
}
impl<'a: 'b, 'b> ReducerOptionsBuilder<'a, 'b> {
  #[inline]
  pub fn add_keep_dims(&mut self, keep_dims: bool) {
    self.fbb_.push_slot::<bool>(ReducerOptions::VT_KEEP_DIMS, keep_dims, false);
  }
  #[inline]
  pub fn new(_fbb: &'b mut flatbuffers::FlatBufferBuilder<'a>) -> ReducerOptionsBuilder<'a, 'b> {
    let start = _fbb.start_table();
    ReducerOptionsBuilder {
      fbb_: _fbb,
      start_: start,
    }
  }
  #[inline]
  pub fn finish(self) -> flatbuffers::WIPOffset<ReducerOptions<'a>> {
    let o = self.fbb_.end_table(self.start_);
    flatbuffers::WIPOffset::new(o.value())
  }
}

impl core::fmt::Debug for ReducerOptions<'_> {
  fn fmt(&self, f: &mut core::fmt::Formatter<'_>) -> core::fmt::Result {
    let mut ds = f.debug_struct("ReducerOptions");
      ds.field("keep_dims", &self.keep_dims());
      ds.finish()
  }
}
#[non_exhaustive]
#[derive(Debug, Clone, PartialEq)]
pub struct ReducerOptionsT {
  pub keep_dims: bool,
}
impl Default for ReducerOptionsT {
  fn default() -> Self {
    Self {
      keep_dims: false,
    }
  }
}
impl ReducerOptionsT {
  pub fn pack<'b>(
    &self,
    _fbb: &mut flatbuffers::FlatBufferBuilder<'b>
  ) -> flatbuffers::WIPOffset<ReducerOptions<'b>> {
    let keep_dims = self.keep_dims;
    ReducerOptions::create(_fbb, &ReducerOptionsArgs{
      keep_dims,
    })
  }
}
pub enum SqueezeOptionsOffset {}
#[derive(Copy, Clone, PartialEq)]

pub struct SqueezeOptions<'a> {
  pub _tab: flatbuffers::Table<'a>,
}

impl<'a> flatbuffers::Follow<'a> for SqueezeOptions<'a> {
  type Inner = SqueezeOptions<'a>;
  #[inline]
  fn follow(buf: &'a [u8], loc: usize) -> Self::Inner {
    Self { _tab: flatbuffers::Table { buf, loc } }
  }
}

impl<'a> SqueezeOptions<'a> {
  pub const VT_SQUEEZE_DIMS: flatbuffers::VOffsetT = 4;

  #[inline]
  pub fn init_from_table(table: flatbuffers::Table<'a>) -> Self {
    SqueezeOptions { _tab: table }
  }
  #[allow(unused_mut)]
  pub fn create<'bldr: 'args, 'args: 'mut_bldr, 'mut_bldr>(
    _fbb: &'mut_bldr mut flatbuffers::FlatBufferBuilder<'bldr>,
    args: &'args SqueezeOptionsArgs<'args>
  ) -> flatbuffers::WIPOffset<SqueezeOptions<'bldr>> {
    let mut builder = SqueezeOptionsBuilder::new(_fbb);
    if let Some(x) = args.squeeze_dims { builder.add_squeeze_dims(x); }
    builder.finish()
  }

  pub fn unpack(&self) -> SqueezeOptionsT {
    let squeeze_dims = self.squeeze_dims().map(|x| {
      x.into_iter().collect()
    });
    SqueezeOptionsT {
      squeeze_dims,
    }
  }

  #[inline]
  pub fn squeeze_dims(&self) -> Option<flatbuffers::Vector<'a, i32>> {
    self._tab.get::<flatbuffers::ForwardsUOffset<flatbuffers::Vector<'a, i32>>>(SqueezeOptions::VT_SQUEEZE_DIMS, None)
  }
}

impl flatbuffers::Verifiable for SqueezeOptions<'_> {
  #[inline]
  fn run_verifier(
    v: &mut flatbuffers::Verifier, pos: usize
  ) -> Result<(), flatbuffers::InvalidFlatbuffer> {
    use self::flatbuffers::Verifiable;
    v.visit_table(pos)?
     .visit_field::<flatbuffers::ForwardsUOffset<flatbuffers::Vector<'_, i32>>>("squeeze_dims", Self::VT_SQUEEZE_DIMS, false)?
     .finish();
    Ok(())
  }
}
pub struct SqueezeOptionsArgs<'a> {
    pub squeeze_dims: Option<flatbuffers::WIPOffset<flatbuffers::Vector<'a, i32>>>,
}
impl<'a> Default for SqueezeOptionsArgs<'a> {
  #[inline]
  fn default() -> Self {
    SqueezeOptionsArgs {
      squeeze_dims: None,
    }
  }
}

pub struct SqueezeOptionsBuilder<'a: 'b, 'b> {
  fbb_: &'b mut flatbuffers::FlatBufferBuilder<'a>,
  start_: flatbuffers::WIPOffset<flatbuffers::TableUnfinishedWIPOffset>,
}
impl<'a: 'b, 'b> SqueezeOptionsBuilder<'a, 'b> {
  #[inline]
  pub fn add_squeeze_dims(&mut self, squeeze_dims: flatbuffers::WIPOffset<flatbuffers::Vector<'b , i32>>) {
    self.fbb_.push_slot_always::<flatbuffers::WIPOffset<_>>(SqueezeOptions::VT_SQUEEZE_DIMS, squeeze_dims);
  }
  #[inline]
  pub fn new(_fbb: &'b mut flatbuffers::FlatBufferBuilder<'a>) -> SqueezeOptionsBuilder<'a, 'b> {
    let start = _fbb.start_table();
    SqueezeOptionsBuilder {
      fbb_: _fbb,
      start_: start,
    }
  }
  #[inline]
  pub fn finish(self) -> flatbuffers::WIPOffset<SqueezeOptions<'a>> {
    let o = self.fbb_.end_table(self.start_);
    flatbuffers::WIPOffset::new(o.value())
  }
}

impl core::fmt::Debug for SqueezeOptions<'_> {
  fn fmt(&self, f: &mut core::fmt::Formatter<'_>) -> core::fmt::Result {
    let mut ds = f.debug_struct("SqueezeOptions");
      ds.field("squeeze_dims", &self.squeeze_dims());
      ds.finish()
  }
}
#[non_exhaustive]
#[derive(Debug, Clone, PartialEq)]
pub struct SqueezeOptionsT {
  pub squeeze_dims: Option<Vec<i32>>,
}
impl Default for SqueezeOptionsT {
  fn default() -> Self {
    Self {
      squeeze_dims: None,
    }
  }
}
impl SqueezeOptionsT {
  pub fn pack<'b>(
    &self,
    _fbb: &mut flatbuffers::FlatBufferBuilder<'b>
  ) -> flatbuffers::WIPOffset<SqueezeOptions<'b>> {
    let squeeze_dims = self.squeeze_dims.as_ref().map(|x|{
      _fbb.create_vector(x)
    });
    SqueezeOptions::create(_fbb, &SqueezeOptionsArgs{
      squeeze_dims,
    })
  }
}
pub enum SplitOptionsOffset {}
#[derive(Copy, Clone, PartialEq)]

pub struct SplitOptions<'a> {
  pub _tab: flatbuffers::Table<'a>,
}

impl<'a> flatbuffers::Follow<'a> for SplitOptions<'a> {
  type Inner = SplitOptions<'a>;
  #[inline]
  fn follow(buf: &'a [u8], loc: usize) -> Self::Inner {
    Self { _tab: flatbuffers::Table { buf, loc } }
  }
}

impl<'a> SplitOptions<'a> {
  pub const VT_NUM_SPLITS: flatbuffers::VOffsetT = 4;

  #[inline]
  pub fn init_from_table(table: flatbuffers::Table<'a>) -> Self {
    SplitOptions { _tab: table }
  }
  #[allow(unused_mut)]
  pub fn create<'bldr: 'args, 'args: 'mut_bldr, 'mut_bldr>(
    _fbb: &'mut_bldr mut flatbuffers::FlatBufferBuilder<'bldr>,
    args: &'args SplitOptionsArgs
  ) -> flatbuffers::WIPOffset<SplitOptions<'bldr>> {
    let mut builder = SplitOptionsBuilder::new(_fbb);
    builder.add_num_splits(args.num_splits);
    builder.finish()
  }

  pub fn unpack(&self) -> SplitOptionsT {
    let num_splits = self.num_splits();
    SplitOptionsT {
      num_splits,
    }
  }

  #[inline]
  pub fn num_splits(&self) -> i32 {
    self._tab.get::<i32>(SplitOptions::VT_NUM_SPLITS, Some(0)).unwrap()
  }
}

impl flatbuffers::Verifiable for SplitOptions<'_> {
  #[inline]
  fn run_verifier(
    v: &mut flatbuffers::Verifier, pos: usize
  ) -> Result<(), flatbuffers::InvalidFlatbuffer> {
    use self::flatbuffers::Verifiable;
    v.visit_table(pos)?
     .visit_field::<i32>("num_splits", Self::VT_NUM_SPLITS, false)?
     .finish();
    Ok(())
  }
}
pub struct SplitOptionsArgs {
    pub num_splits: i32,
}
impl<'a> Default for SplitOptionsArgs {
  #[inline]
  fn default() -> Self {
    SplitOptionsArgs {
      num_splits: 0,
    }
  }
}

pub struct SplitOptionsBuilder<'a: 'b, 'b> {
  fbb_: &'b mut flatbuffers::FlatBufferBuilder<'a>,
  start_: flatbuffers::WIPOffset<flatbuffers::TableUnfinishedWIPOffset>,
}
impl<'a: 'b, 'b> SplitOptionsBuilder<'a, 'b> {
  #[inline]
  pub fn add_num_splits(&mut self, num_splits: i32) {
    self.fbb_.push_slot::<i32>(SplitOptions::VT_NUM_SPLITS, num_splits, 0);
  }
  #[inline]
  pub fn new(_fbb: &'b mut flatbuffers::FlatBufferBuilder<'a>) -> SplitOptionsBuilder<'a, 'b> {
    let start = _fbb.start_table();
    SplitOptionsBuilder {
      fbb_: _fbb,
      start_: start,
    }
  }
  #[inline]
  pub fn finish(self) -> flatbuffers::WIPOffset<SplitOptions<'a>> {
    let o = self.fbb_.end_table(self.start_);
    flatbuffers::WIPOffset::new(o.value())
  }
}

impl core::fmt::Debug for SplitOptions<'_> {
  fn fmt(&self, f: &mut core::fmt::Formatter<'_>) -> core::fmt::Result {
    let mut ds = f.debug_struct("SplitOptions");
      ds.field("num_splits", &self.num_splits());
      ds.finish()
  }
}
#[non_exhaustive]
#[derive(Debug, Clone, PartialEq)]
pub struct SplitOptionsT {
  pub num_splits: i32,
}
impl Default for SplitOptionsT {
  fn default() -> Self {
    Self {
      num_splits: 0,
    }
  }
}
impl SplitOptionsT {
  pub fn pack<'b>(
    &self,
    _fbb: &mut flatbuffers::FlatBufferBuilder<'b>
  ) -> flatbuffers::WIPOffset<SplitOptions<'b>> {
    let num_splits = self.num_splits;
    SplitOptions::create(_fbb, &SplitOptionsArgs{
      num_splits,
    })
  }
}
pub enum SplitVOptionsOffset {}
#[derive(Copy, Clone, PartialEq)]

pub struct SplitVOptions<'a> {
  pub _tab: flatbuffers::Table<'a>,
}

impl<'a> flatbuffers::Follow<'a> for SplitVOptions<'a> {
  type Inner = SplitVOptions<'a>;
  #[inline]
  fn follow(buf: &'a [u8], loc: usize) -> Self::Inner {
    Self { _tab: flatbuffers::Table { buf, loc } }
  }
}

impl<'a> SplitVOptions<'a> {
  pub const VT_NUM_SPLITS: flatbuffers::VOffsetT = 4;

  #[inline]
  pub fn init_from_table(table: flatbuffers::Table<'a>) -> Self {
    SplitVOptions { _tab: table }
  }
  #[allow(unused_mut)]
  pub fn create<'bldr: 'args, 'args: 'mut_bldr, 'mut_bldr>(
    _fbb: &'mut_bldr mut flatbuffers::FlatBufferBuilder<'bldr>,
    args: &'args SplitVOptionsArgs
  ) -> flatbuffers::WIPOffset<SplitVOptions<'bldr>> {
    let mut builder = SplitVOptionsBuilder::new(_fbb);
    builder.add_num_splits(args.num_splits);
    builder.finish()
  }

  pub fn unpack(&self) -> SplitVOptionsT {
    let num_splits = self.num_splits();
    SplitVOptionsT {
      num_splits,
    }
  }

  #[inline]
  pub fn num_splits(&self) -> i32 {
    self._tab.get::<i32>(SplitVOptions::VT_NUM_SPLITS, Some(0)).unwrap()
  }
}

impl flatbuffers::Verifiable for SplitVOptions<'_> {
  #[inline]
  fn run_verifier(
    v: &mut flatbuffers::Verifier, pos: usize
  ) -> Result<(), flatbuffers::InvalidFlatbuffer> {
    use self::flatbuffers::Verifiable;
    v.visit_table(pos)?
     .visit_field::<i32>("num_splits", Self::VT_NUM_SPLITS, false)?
     .finish();
    Ok(())
  }
}
pub struct SplitVOptionsArgs {
    pub num_splits: i32,
}
impl<'a> Default for SplitVOptionsArgs {
  #[inline]
  fn default() -> Self {
    SplitVOptionsArgs {
      num_splits: 0,
    }
  }
}

pub struct SplitVOptionsBuilder<'a: 'b, 'b> {
  fbb_: &'b mut flatbuffers::FlatBufferBuilder<'a>,
  start_: flatbuffers::WIPOffset<flatbuffers::TableUnfinishedWIPOffset>,
}
impl<'a: 'b, 'b> SplitVOptionsBuilder<'a, 'b> {
  #[inline]
  pub fn add_num_splits(&mut self, num_splits: i32) {
    self.fbb_.push_slot::<i32>(SplitVOptions::VT_NUM_SPLITS, num_splits, 0);
  }
  #[inline]
  pub fn new(_fbb: &'b mut flatbuffers::FlatBufferBuilder<'a>) -> SplitVOptionsBuilder<'a, 'b> {
    let start = _fbb.start_table();
    SplitVOptionsBuilder {
      fbb_: _fbb,
      start_: start,
    }
  }
  #[inline]
  pub fn finish(self) -> flatbuffers::WIPOffset<SplitVOptions<'a>> {
    let o = self.fbb_.end_table(self.start_);
    flatbuffers::WIPOffset::new(o.value())
  }
}

impl core::fmt::Debug for SplitVOptions<'_> {
  fn fmt(&self, f: &mut core::fmt::Formatter<'_>) -> core::fmt::Result {
    let mut ds = f.debug_struct("SplitVOptions");
      ds.field("num_splits", &self.num_splits());
      ds.finish()
  }
}
#[non_exhaustive]
#[derive(Debug, Clone, PartialEq)]
pub struct SplitVOptionsT {
  pub num_splits: i32,
}
impl Default for SplitVOptionsT {
  fn default() -> Self {
    Self {
      num_splits: 0,
    }
  }
}
impl SplitVOptionsT {
  pub fn pack<'b>(
    &self,
    _fbb: &mut flatbuffers::FlatBufferBuilder<'b>
  ) -> flatbuffers::WIPOffset<SplitVOptions<'b>> {
    let num_splits = self.num_splits;
    SplitVOptions::create(_fbb, &SplitVOptionsArgs{
      num_splits,
    })
  }
}
pub enum StridedSliceOptionsOffset {}
#[derive(Copy, Clone, PartialEq)]

pub struct StridedSliceOptions<'a> {
  pub _tab: flatbuffers::Table<'a>,
}

impl<'a> flatbuffers::Follow<'a> for StridedSliceOptions<'a> {
  type Inner = StridedSliceOptions<'a>;
  #[inline]
  fn follow(buf: &'a [u8], loc: usize) -> Self::Inner {
    Self { _tab: flatbuffers::Table { buf, loc } }
  }
}

impl<'a> StridedSliceOptions<'a> {
  pub const VT_BEGIN_MASK: flatbuffers::VOffsetT = 4;
  pub const VT_END_MASK: flatbuffers::VOffsetT = 6;
  pub const VT_ELLIPSIS_MASK: flatbuffers::VOffsetT = 8;
  pub const VT_NEW_AXIS_MASK: flatbuffers::VOffsetT = 10;
  pub const VT_SHRINK_AXIS_MASK: flatbuffers::VOffsetT = 12;

  #[inline]
  pub fn init_from_table(table: flatbuffers::Table<'a>) -> Self {
    StridedSliceOptions { _tab: table }
  }
  #[allow(unused_mut)]
  pub fn create<'bldr: 'args, 'args: 'mut_bldr, 'mut_bldr>(
    _fbb: &'mut_bldr mut flatbuffers::FlatBufferBuilder<'bldr>,
    args: &'args StridedSliceOptionsArgs
  ) -> flatbuffers::WIPOffset<StridedSliceOptions<'bldr>> {
    let mut builder = StridedSliceOptionsBuilder::new(_fbb);
    builder.add_shrink_axis_mask(args.shrink_axis_mask);
    builder.add_new_axis_mask(args.new_axis_mask);
    builder.add_ellipsis_mask(args.ellipsis_mask);
    builder.add_end_mask(args.end_mask);
    builder.add_begin_mask(args.begin_mask);
    builder.finish()
  }

  pub fn unpack(&self) -> StridedSliceOptionsT {
    let begin_mask = self.begin_mask();
    let end_mask = self.end_mask();
    let ellipsis_mask = self.ellipsis_mask();
    let new_axis_mask = self.new_axis_mask();
    let shrink_axis_mask = self.shrink_axis_mask();
    StridedSliceOptionsT {
      begin_mask,
      end_mask,
      ellipsis_mask,
      new_axis_mask,
      shrink_axis_mask,
    }
  }

  #[inline]
  pub fn begin_mask(&self) -> i32 {
    self._tab.get::<i32>(StridedSliceOptions::VT_BEGIN_MASK, Some(0)).unwrap()
  }
  #[inline]
  pub fn end_mask(&self) -> i32 {
    self._tab.get::<i32>(StridedSliceOptions::VT_END_MASK, Some(0)).unwrap()
  }
  #[inline]
  pub fn ellipsis_mask(&self) -> i32 {
    self._tab.get::<i32>(StridedSliceOptions::VT_ELLIPSIS_MASK, Some(0)).unwrap()
  }
  #[inline]
  pub fn new_axis_mask(&self) -> i32 {
    self._tab.get::<i32>(StridedSliceOptions::VT_NEW_AXIS_MASK, Some(0)).unwrap()
  }
  #[inline]
  pub fn shrink_axis_mask(&self) -> i32 {
    self._tab.get::<i32>(StridedSliceOptions::VT_SHRINK_AXIS_MASK, Some(0)).unwrap()
  }
}

impl flatbuffers::Verifiable for StridedSliceOptions<'_> {
  #[inline]
  fn run_verifier(
    v: &mut flatbuffers::Verifier, pos: usize
  ) -> Result<(), flatbuffers::InvalidFlatbuffer> {
    use self::flatbuffers::Verifiable;
    v.visit_table(pos)?
     .visit_field::<i32>("begin_mask", Self::VT_BEGIN_MASK, false)?
     .visit_field::<i32>("end_mask", Self::VT_END_MASK, false)?
     .visit_field::<i32>("ellipsis_mask", Self::VT_ELLIPSIS_MASK, false)?
     .visit_field::<i32>("new_axis_mask", Self::VT_NEW_AXIS_MASK, false)?
     .visit_field::<i32>("shrink_axis_mask", Self::VT_SHRINK_AXIS_MASK, false)?
     .finish();
    Ok(())
  }
}
pub struct StridedSliceOptionsArgs {
    pub begin_mask: i32,
    pub end_mask: i32,
    pub ellipsis_mask: i32,
    pub new_axis_mask: i32,
    pub shrink_axis_mask: i32,
}
impl<'a> Default for StridedSliceOptionsArgs {
  #[inline]
  fn default() -> Self {
    StridedSliceOptionsArgs {
      begin_mask: 0,
      end_mask: 0,
      ellipsis_mask: 0,
      new_axis_mask: 0,
      shrink_axis_mask: 0,
    }
  }
}

pub struct StridedSliceOptionsBuilder<'a: 'b, 'b> {
  fbb_: &'b mut flatbuffers::FlatBufferBuilder<'a>,
  start_: flatbuffers::WIPOffset<flatbuffers::TableUnfinishedWIPOffset>,
}
impl<'a: 'b, 'b> StridedSliceOptionsBuilder<'a, 'b> {
  #[inline]
  pub fn add_begin_mask(&mut self, begin_mask: i32) {
    self.fbb_.push_slot::<i32>(StridedSliceOptions::VT_BEGIN_MASK, begin_mask, 0);
  }
  #[inline]
  pub fn add_end_mask(&mut self, end_mask: i32) {
    self.fbb_.push_slot::<i32>(StridedSliceOptions::VT_END_MASK, end_mask, 0);
  }
  #[inline]
  pub fn add_ellipsis_mask(&mut self, ellipsis_mask: i32) {
    self.fbb_.push_slot::<i32>(StridedSliceOptions::VT_ELLIPSIS_MASK, ellipsis_mask, 0);
  }
  #[inline]
  pub fn add_new_axis_mask(&mut self, new_axis_mask: i32) {
    self.fbb_.push_slot::<i32>(StridedSliceOptions::VT_NEW_AXIS_MASK, new_axis_mask, 0);
  }
  #[inline]
  pub fn add_shrink_axis_mask(&mut self, shrink_axis_mask: i32) {
    self.fbb_.push_slot::<i32>(StridedSliceOptions::VT_SHRINK_AXIS_MASK, shrink_axis_mask, 0);
  }
  #[inline]
  pub fn new(_fbb: &'b mut flatbuffers::FlatBufferBuilder<'a>) -> StridedSliceOptionsBuilder<'a, 'b> {
    let start = _fbb.start_table();
    StridedSliceOptionsBuilder {
      fbb_: _fbb,
      start_: start,
    }
  }
  #[inline]
  pub fn finish(self) -> flatbuffers::WIPOffset<StridedSliceOptions<'a>> {
    let o = self.fbb_.end_table(self.start_);
    flatbuffers::WIPOffset::new(o.value())
  }
}

impl core::fmt::Debug for StridedSliceOptions<'_> {
  fn fmt(&self, f: &mut core::fmt::Formatter<'_>) -> core::fmt::Result {
    let mut ds = f.debug_struct("StridedSliceOptions");
      ds.field("begin_mask", &self.begin_mask());
      ds.field("end_mask", &self.end_mask());
      ds.field("ellipsis_mask", &self.ellipsis_mask());
      ds.field("new_axis_mask", &self.new_axis_mask());
      ds.field("shrink_axis_mask", &self.shrink_axis_mask());
      ds.finish()
  }
}
#[non_exhaustive]
#[derive(Debug, Clone, PartialEq)]
pub struct StridedSliceOptionsT {
  pub begin_mask: i32,
  pub end_mask: i32,
  pub ellipsis_mask: i32,
  pub new_axis_mask: i32,
  pub shrink_axis_mask: i32,
}
impl Default for StridedSliceOptionsT {
  fn default() -> Self {
    Self {
      begin_mask: 0,
      end_mask: 0,
      ellipsis_mask: 0,
      new_axis_mask: 0,
      shrink_axis_mask: 0,
    }
  }
}
impl StridedSliceOptionsT {
  pub fn pack<'b>(
    &self,
    _fbb: &mut flatbuffers::FlatBufferBuilder<'b>
  ) -> flatbuffers::WIPOffset<StridedSliceOptions<'b>> {
    let begin_mask = self.begin_mask;
    let end_mask = self.end_mask;
    let ellipsis_mask = self.ellipsis_mask;
    let new_axis_mask = self.new_axis_mask;
    let shrink_axis_mask = self.shrink_axis_mask;
    StridedSliceOptions::create(_fbb, &StridedSliceOptionsArgs{
      begin_mask,
      end_mask,
      ellipsis_mask,
      new_axis_mask,
      shrink_axis_mask,
    })
  }
}
pub enum LogSoftmaxOptionsOffset {}
#[derive(Copy, Clone, PartialEq)]

pub struct LogSoftmaxOptions<'a> {
  pub _tab: flatbuffers::Table<'a>,
}

impl<'a> flatbuffers::Follow<'a> for LogSoftmaxOptions<'a> {
  type Inner = LogSoftmaxOptions<'a>;
  #[inline]
  fn follow(buf: &'a [u8], loc: usize) -> Self::Inner {
    Self { _tab: flatbuffers::Table { buf, loc } }
  }
}

impl<'a> LogSoftmaxOptions<'a> {

  #[inline]
  pub fn init_from_table(table: flatbuffers::Table<'a>) -> Self {
    LogSoftmaxOptions { _tab: table }
  }
  #[allow(unused_mut)]
  pub fn create<'bldr: 'args, 'args: 'mut_bldr, 'mut_bldr>(
    _fbb: &'mut_bldr mut flatbuffers::FlatBufferBuilder<'bldr>,
    _args: &'args LogSoftmaxOptionsArgs
  ) -> flatbuffers::WIPOffset<LogSoftmaxOptions<'bldr>> {
    let mut builder = LogSoftmaxOptionsBuilder::new(_fbb);
    builder.finish()
  }

  pub fn unpack(&self) -> LogSoftmaxOptionsT {
    LogSoftmaxOptionsT {
    }
  }
}

impl flatbuffers::Verifiable for LogSoftmaxOptions<'_> {
  #[inline]
  fn run_verifier(
    v: &mut flatbuffers::Verifier, pos: usize
  ) -> Result<(), flatbuffers::InvalidFlatbuffer> {
    use self::flatbuffers::Verifiable;
    v.visit_table(pos)?
     .finish();
    Ok(())
  }
}
pub struct LogSoftmaxOptionsArgs {
}
impl<'a> Default for LogSoftmaxOptionsArgs {
  #[inline]
  fn default() -> Self {
    LogSoftmaxOptionsArgs {
    }
  }
}

pub struct LogSoftmaxOptionsBuilder<'a: 'b, 'b> {
  fbb_: &'b mut flatbuffers::FlatBufferBuilder<'a>,
  start_: flatbuffers::WIPOffset<flatbuffers::TableUnfinishedWIPOffset>,
}
impl<'a: 'b, 'b> LogSoftmaxOptionsBuilder<'a, 'b> {
  #[inline]
  pub fn new(_fbb: &'b mut flatbuffers::FlatBufferBuilder<'a>) -> LogSoftmaxOptionsBuilder<'a, 'b> {
    let start = _fbb.start_table();
    LogSoftmaxOptionsBuilder {
      fbb_: _fbb,
      start_: start,
    }
  }
  #[inline]
  pub fn finish(self) -> flatbuffers::WIPOffset<LogSoftmaxOptions<'a>> {
    let o = self.fbb_.end_table(self.start_);
    flatbuffers::WIPOffset::new(o.value())
  }
}

impl core::fmt::Debug for LogSoftmaxOptions<'_> {
  fn fmt(&self, f: &mut core::fmt::Formatter<'_>) -> core::fmt::Result {
    let mut ds = f.debug_struct("LogSoftmaxOptions");
      ds.finish()
  }
}
#[non_exhaustive]
#[derive(Debug, Clone, PartialEq)]
pub struct LogSoftmaxOptionsT {
}
impl Default for LogSoftmaxOptionsT {
  fn default() -> Self {
    Self {
    }
  }
}
impl LogSoftmaxOptionsT {
  pub fn pack<'b>(
    &self,
    _fbb: &mut flatbuffers::FlatBufferBuilder<'b>
  ) -> flatbuffers::WIPOffset<LogSoftmaxOptions<'b>> {
    LogSoftmaxOptions::create(_fbb, &LogSoftmaxOptionsArgs{
    })
  }
}
pub enum CastOptionsOffset {}
#[derive(Copy, Clone, PartialEq)]

pub struct CastOptions<'a> {
  pub _tab: flatbuffers::Table<'a>,
}

impl<'a> flatbuffers::Follow<'a> for CastOptions<'a> {
  type Inner = CastOptions<'a>;
  #[inline]
  fn follow(buf: &'a [u8], loc: usize) -> Self::Inner {
    Self { _tab: flatbuffers::Table { buf, loc } }
  }
}

impl<'a> CastOptions<'a> {
  pub const VT_IN_DATA_TYPE: flatbuffers::VOffsetT = 4;
  pub const VT_OUT_DATA_TYPE: flatbuffers::VOffsetT = 6;

  #[inline]
  pub fn init_from_table(table: flatbuffers::Table<'a>) -> Self {
    CastOptions { _tab: table }
  }
  #[allow(unused_mut)]
  pub fn create<'bldr: 'args, 'args: 'mut_bldr, 'mut_bldr>(
    _fbb: &'mut_bldr mut flatbuffers::FlatBufferBuilder<'bldr>,
    args: &'args CastOptionsArgs
  ) -> flatbuffers::WIPOffset<CastOptions<'bldr>> {
    let mut builder = CastOptionsBuilder::new(_fbb);
    builder.add_out_data_type(args.out_data_type);
    builder.add_in_data_type(args.in_data_type);
    builder.finish()
  }

  pub fn unpack(&self) -> CastOptionsT {
    let in_data_type = self.in_data_type();
    let out_data_type = self.out_data_type();
    CastOptionsT {
      in_data_type,
      out_data_type,
    }
  }

  #[inline]
  pub fn in_data_type(&self) -> TensorType {
    self._tab.get::<TensorType>(CastOptions::VT_IN_DATA_TYPE, Some(TensorType::FLOAT32)).unwrap()
  }
  #[inline]
  pub fn out_data_type(&self) -> TensorType {
    self._tab.get::<TensorType>(CastOptions::VT_OUT_DATA_TYPE, Some(TensorType::FLOAT32)).unwrap()
  }
}

impl flatbuffers::Verifiable for CastOptions<'_> {
  #[inline]
  fn run_verifier(
    v: &mut flatbuffers::Verifier, pos: usize
  ) -> Result<(), flatbuffers::InvalidFlatbuffer> {
    use self::flatbuffers::Verifiable;
    v.visit_table(pos)?
     .visit_field::<TensorType>("in_data_type", Self::VT_IN_DATA_TYPE, false)?
     .visit_field::<TensorType>("out_data_type", Self::VT_OUT_DATA_TYPE, false)?
     .finish();
    Ok(())
  }
}
pub struct CastOptionsArgs {
    pub in_data_type: TensorType,
    pub out_data_type: TensorType,
}
impl<'a> Default for CastOptionsArgs {
  #[inline]
  fn default() -> Self {
    CastOptionsArgs {
      in_data_type: TensorType::FLOAT32,
      out_data_type: TensorType::FLOAT32,
    }
  }
}

pub struct CastOptionsBuilder<'a: 'b, 'b> {
  fbb_: &'b mut flatbuffers::FlatBufferBuilder<'a>,
  start_: flatbuffers::WIPOffset<flatbuffers::TableUnfinishedWIPOffset>,
}
impl<'a: 'b, 'b> CastOptionsBuilder<'a, 'b> {
  #[inline]
  pub fn add_in_data_type(&mut self, in_data_type: TensorType) {
    self.fbb_.push_slot::<TensorType>(CastOptions::VT_IN_DATA_TYPE, in_data_type, TensorType::FLOAT32);
  }
  #[inline]
  pub fn add_out_data_type(&mut self, out_data_type: TensorType) {
    self.fbb_.push_slot::<TensorType>(CastOptions::VT_OUT_DATA_TYPE, out_data_type, TensorType::FLOAT32);
  }
  #[inline]
  pub fn new(_fbb: &'b mut flatbuffers::FlatBufferBuilder<'a>) -> CastOptionsBuilder<'a, 'b> {
    let start = _fbb.start_table();
    CastOptionsBuilder {
      fbb_: _fbb,
      start_: start,
    }
  }
  #[inline]
  pub fn finish(self) -> flatbuffers::WIPOffset<CastOptions<'a>> {
    let o = self.fbb_.end_table(self.start_);
    flatbuffers::WIPOffset::new(o.value())
  }
}

impl core::fmt::Debug for CastOptions<'_> {
  fn fmt(&self, f: &mut core::fmt::Formatter<'_>) -> core::fmt::Result {
    let mut ds = f.debug_struct("CastOptions");
      ds.field("in_data_type", &self.in_data_type());
      ds.field("out_data_type", &self.out_data_type());
      ds.finish()
  }
}
#[non_exhaustive]
#[derive(Debug, Clone, PartialEq)]
pub struct CastOptionsT {
  pub in_data_type: TensorType,
  pub out_data_type: TensorType,
}
impl Default for CastOptionsT {
  fn default() -> Self {
    Self {
      in_data_type: TensorType::FLOAT32,
      out_data_type: TensorType::FLOAT32,
    }
  }
}
impl CastOptionsT {
  pub fn pack<'b>(
    &self,
    _fbb: &mut flatbuffers::FlatBufferBuilder<'b>
  ) -> flatbuffers::WIPOffset<CastOptions<'b>> {
    let in_data_type = self.in_data_type;
    let out_data_type = self.out_data_type;
    CastOptions::create(_fbb, &CastOptionsArgs{
      in_data_type,
      out_data_type,
    })
  }
}
pub enum DequantizeOptionsOffset {}
#[derive(Copy, Clone, PartialEq)]

pub struct DequantizeOptions<'a> {
  pub _tab: flatbuffers::Table<'a>,
}

impl<'a> flatbuffers::Follow<'a> for DequantizeOptions<'a> {
  type Inner = DequantizeOptions<'a>;
  #[inline]
  fn follow(buf: &'a [u8], loc: usize) -> Self::Inner {
    Self { _tab: flatbuffers::Table { buf, loc } }
  }
}

impl<'a> DequantizeOptions<'a> {

  #[inline]
  pub fn init_from_table(table: flatbuffers::Table<'a>) -> Self {
    DequantizeOptions { _tab: table }
  }
  #[allow(unused_mut)]
  pub fn create<'bldr: 'args, 'args: 'mut_bldr, 'mut_bldr>(
    _fbb: &'mut_bldr mut flatbuffers::FlatBufferBuilder<'bldr>,
    _args: &'args DequantizeOptionsArgs
  ) -> flatbuffers::WIPOffset<DequantizeOptions<'bldr>> {
    let mut builder = DequantizeOptionsBuilder::new(_fbb);
    builder.finish()
  }

  pub fn unpack(&self) -> DequantizeOptionsT {
    DequantizeOptionsT {
    }
  }
}

impl flatbuffers::Verifiable for DequantizeOptions<'_> {
  #[inline]
  fn run_verifier(
    v: &mut flatbuffers::Verifier, pos: usize
  ) -> Result<(), flatbuffers::InvalidFlatbuffer> {
    use self::flatbuffers::Verifiable;
    v.visit_table(pos)?
     .finish();
    Ok(())
  }
}
pub struct DequantizeOptionsArgs {
}
impl<'a> Default for DequantizeOptionsArgs {
  #[inline]
  fn default() -> Self {
    DequantizeOptionsArgs {
    }
  }
}

pub struct DequantizeOptionsBuilder<'a: 'b, 'b> {
  fbb_: &'b mut flatbuffers::FlatBufferBuilder<'a>,
  start_: flatbuffers::WIPOffset<flatbuffers::TableUnfinishedWIPOffset>,
}
impl<'a: 'b, 'b> DequantizeOptionsBuilder<'a, 'b> {
  #[inline]
  pub fn new(_fbb: &'b mut flatbuffers::FlatBufferBuilder<'a>) -> DequantizeOptionsBuilder<'a, 'b> {
    let start = _fbb.start_table();
    DequantizeOptionsBuilder {
      fbb_: _fbb,
      start_: start,
    }
  }
  #[inline]
  pub fn finish(self) -> flatbuffers::WIPOffset<DequantizeOptions<'a>> {
    let o = self.fbb_.end_table(self.start_);
    flatbuffers::WIPOffset::new(o.value())
  }
}

impl core::fmt::Debug for DequantizeOptions<'_> {
  fn fmt(&self, f: &mut core::fmt::Formatter<'_>) -> core::fmt::Result {
    let mut ds = f.debug_struct("DequantizeOptions");
      ds.finish()
  }
}
#[non_exhaustive]
#[derive(Debug, Clone, PartialEq)]
pub struct DequantizeOptionsT {
}
impl Default for DequantizeOptionsT {
  fn default() -> Self {
    Self {
    }
  }
}
impl DequantizeOptionsT {
  pub fn pack<'b>(
    &self,
    _fbb: &mut flatbuffers::FlatBufferBuilder<'b>
  ) -> flatbuffers::WIPOffset<DequantizeOptions<'b>> {
    DequantizeOptions::create(_fbb, &DequantizeOptionsArgs{
    })
  }
}
pub enum MaximumMinimumOptionsOffset {}
#[derive(Copy, Clone, PartialEq)]

pub struct MaximumMinimumOptions<'a> {
  pub _tab: flatbuffers::Table<'a>,
}

impl<'a> flatbuffers::Follow<'a> for MaximumMinimumOptions<'a> {
  type Inner = MaximumMinimumOptions<'a>;
  #[inline]
  fn follow(buf: &'a [u8], loc: usize) -> Self::Inner {
    Self { _tab: flatbuffers::Table { buf, loc } }
  }
}

impl<'a> MaximumMinimumOptions<'a> {

  #[inline]
  pub fn init_from_table(table: flatbuffers::Table<'a>) -> Self {
    MaximumMinimumOptions { _tab: table }
  }
  #[allow(unused_mut)]
  pub fn create<'bldr: 'args, 'args: 'mut_bldr, 'mut_bldr>(
    _fbb: &'mut_bldr mut flatbuffers::FlatBufferBuilder<'bldr>,
    _args: &'args MaximumMinimumOptionsArgs
  ) -> flatbuffers::WIPOffset<MaximumMinimumOptions<'bldr>> {
    let mut builder = MaximumMinimumOptionsBuilder::new(_fbb);
    builder.finish()
  }

  pub fn unpack(&self) -> MaximumMinimumOptionsT {
    MaximumMinimumOptionsT {
    }
  }
}

impl flatbuffers::Verifiable for MaximumMinimumOptions<'_> {
  #[inline]
  fn run_verifier(
    v: &mut flatbuffers::Verifier, pos: usize
  ) -> Result<(), flatbuffers::InvalidFlatbuffer> {
    use self::flatbuffers::Verifiable;
    v.visit_table(pos)?
     .finish();
    Ok(())
  }
}
pub struct MaximumMinimumOptionsArgs {
}
impl<'a> Default for MaximumMinimumOptionsArgs {
  #[inline]
  fn default() -> Self {
    MaximumMinimumOptionsArgs {
    }
  }
}

pub struct MaximumMinimumOptionsBuilder<'a: 'b, 'b> {
  fbb_: &'b mut flatbuffers::FlatBufferBuilder<'a>,
  start_: flatbuffers::WIPOffset<flatbuffers::TableUnfinishedWIPOffset>,
}
impl<'a: 'b, 'b> MaximumMinimumOptionsBuilder<'a, 'b> {
  #[inline]
  pub fn new(_fbb: &'b mut flatbuffers::FlatBufferBuilder<'a>) -> MaximumMinimumOptionsBuilder<'a, 'b> {
    let start = _fbb.start_table();
    MaximumMinimumOptionsBuilder {
      fbb_: _fbb,
      start_: start,
    }
  }
  #[inline]
  pub fn finish(self) -> flatbuffers::WIPOffset<MaximumMinimumOptions<'a>> {
    let o = self.fbb_.end_table(self.start_);
    flatbuffers::WIPOffset::new(o.value())
  }
}

impl core::fmt::Debug for MaximumMinimumOptions<'_> {
  fn fmt(&self, f: &mut core::fmt::Formatter<'_>) -> core::fmt::Result {
    let mut ds = f.debug_struct("MaximumMinimumOptions");
      ds.finish()
  }
}
#[non_exhaustive]
#[derive(Debug, Clone, PartialEq)]
pub struct MaximumMinimumOptionsT {
}
impl Default for MaximumMinimumOptionsT {
  fn default() -> Self {
    Self {
    }
  }
}
impl MaximumMinimumOptionsT {
  pub fn pack<'b>(
    &self,
    _fbb: &mut flatbuffers::FlatBufferBuilder<'b>
  ) -> flatbuffers::WIPOffset<MaximumMinimumOptions<'b>> {
    MaximumMinimumOptions::create(_fbb, &MaximumMinimumOptionsArgs{
    })
  }
}
pub enum TileOptionsOffset {}
#[derive(Copy, Clone, PartialEq)]

pub struct TileOptions<'a> {
  pub _tab: flatbuffers::Table<'a>,
}

impl<'a> flatbuffers::Follow<'a> for TileOptions<'a> {
  type Inner = TileOptions<'a>;
  #[inline]
  fn follow(buf: &'a [u8], loc: usize) -> Self::Inner {
    Self { _tab: flatbuffers::Table { buf, loc } }
  }
}

impl<'a> TileOptions<'a> {

  #[inline]
  pub fn init_from_table(table: flatbuffers::Table<'a>) -> Self {
    TileOptions { _tab: table }
  }
  #[allow(unused_mut)]
  pub fn create<'bldr: 'args, 'args: 'mut_bldr, 'mut_bldr>(
    _fbb: &'mut_bldr mut flatbuffers::FlatBufferBuilder<'bldr>,
    _args: &'args TileOptionsArgs
  ) -> flatbuffers::WIPOffset<TileOptions<'bldr>> {
    let mut builder = TileOptionsBuilder::new(_fbb);
    builder.finish()
  }

  pub fn unpack(&self) -> TileOptionsT {
    TileOptionsT {
    }
  }
}

impl flatbuffers::Verifiable for TileOptions<'_> {
  #[inline]
  fn run_verifier(
    v: &mut flatbuffers::Verifier, pos: usize
  ) -> Result<(), flatbuffers::InvalidFlatbuffer> {
    use self::flatbuffers::Verifiable;
    v.visit_table(pos)?
     .finish();
    Ok(())
  }
}
pub struct TileOptionsArgs {
}
impl<'a> Default for TileOptionsArgs {
  #[inline]
  fn default() -> Self {
    TileOptionsArgs {
    }
  }
}

pub struct TileOptionsBuilder<'a: 'b, 'b> {
  fbb_: &'b mut flatbuffers::FlatBufferBuilder<'a>,
  start_: flatbuffers::WIPOffset<flatbuffers::TableUnfinishedWIPOffset>,
}
impl<'a: 'b, 'b> TileOptionsBuilder<'a, 'b> {
  #[inline]
  pub fn new(_fbb: &'b mut flatbuffers::FlatBufferBuilder<'a>) -> TileOptionsBuilder<'a, 'b> {
    let start = _fbb.start_table();
    TileOptionsBuilder {
      fbb_: _fbb,
      start_: start,
    }
  }
  #[inline]
  pub fn finish(self) -> flatbuffers::WIPOffset<TileOptions<'a>> {
    let o = self.fbb_.end_table(self.start_);
    flatbuffers::WIPOffset::new(o.value())
  }
}

impl core::fmt::Debug for TileOptions<'_> {
  fn fmt(&self, f: &mut core::fmt::Formatter<'_>) -> core::fmt::Result {
    let mut ds = f.debug_struct("TileOptions");
      ds.finish()
  }
}
#[non_exhaustive]
#[derive(Debug, Clone, PartialEq)]
pub struct TileOptionsT {
}
impl Default for TileOptionsT {
  fn default() -> Self {
    Self {
    }
  }
}
impl TileOptionsT {
  pub fn pack<'b>(
    &self,
    _fbb: &mut flatbuffers::FlatBufferBuilder<'b>
  ) -> flatbuffers::WIPOffset<TileOptions<'b>> {
    TileOptions::create(_fbb, &TileOptionsArgs{
    })
  }
}
pub enum ArgMaxOptionsOffset {}
#[derive(Copy, Clone, PartialEq)]

pub struct ArgMaxOptions<'a> {
  pub _tab: flatbuffers::Table<'a>,
}

impl<'a> flatbuffers::Follow<'a> for ArgMaxOptions<'a> {
  type Inner = ArgMaxOptions<'a>;
  #[inline]
  fn follow(buf: &'a [u8], loc: usize) -> Self::Inner {
    Self { _tab: flatbuffers::Table { buf, loc } }
  }
}

impl<'a> ArgMaxOptions<'a> {
  pub const VT_OUTPUT_TYPE: flatbuffers::VOffsetT = 4;

  #[inline]
  pub fn init_from_table(table: flatbuffers::Table<'a>) -> Self {
    ArgMaxOptions { _tab: table }
  }
  #[allow(unused_mut)]
  pub fn create<'bldr: 'args, 'args: 'mut_bldr, 'mut_bldr>(
    _fbb: &'mut_bldr mut flatbuffers::FlatBufferBuilder<'bldr>,
    args: &'args ArgMaxOptionsArgs
  ) -> flatbuffers::WIPOffset<ArgMaxOptions<'bldr>> {
    let mut builder = ArgMaxOptionsBuilder::new(_fbb);
    builder.add_output_type(args.output_type);
    builder.finish()
  }

  pub fn unpack(&self) -> ArgMaxOptionsT {
    let output_type = self.output_type();
    ArgMaxOptionsT {
      output_type,
    }
  }

  #[inline]
  pub fn output_type(&self) -> TensorType {
    self._tab.get::<TensorType>(ArgMaxOptions::VT_OUTPUT_TYPE, Some(TensorType::FLOAT32)).unwrap()
  }
}

impl flatbuffers::Verifiable for ArgMaxOptions<'_> {
  #[inline]
  fn run_verifier(
    v: &mut flatbuffers::Verifier, pos: usize
  ) -> Result<(), flatbuffers::InvalidFlatbuffer> {
    use self::flatbuffers::Verifiable;
    v.visit_table(pos)?
     .visit_field::<TensorType>("output_type", Self::VT_OUTPUT_TYPE, false)?
     .finish();
    Ok(())
  }
}
pub struct ArgMaxOptionsArgs {
    pub output_type: TensorType,
}
impl<'a> Default for ArgMaxOptionsArgs {
  #[inline]
  fn default() -> Self {
    ArgMaxOptionsArgs {
      output_type: TensorType::FLOAT32,
    }
  }
}

pub struct ArgMaxOptionsBuilder<'a: 'b, 'b> {
  fbb_: &'b mut flatbuffers::FlatBufferBuilder<'a>,
  start_: flatbuffers::WIPOffset<flatbuffers::TableUnfinishedWIPOffset>,
}
impl<'a: 'b, 'b> ArgMaxOptionsBuilder<'a, 'b> {
  #[inline]
  pub fn add_output_type(&mut self, output_type: TensorType) {
    self.fbb_.push_slot::<TensorType>(ArgMaxOptions::VT_OUTPUT_TYPE, output_type, TensorType::FLOAT32);
  }
  #[inline]
  pub fn new(_fbb: &'b mut flatbuffers::FlatBufferBuilder<'a>) -> ArgMaxOptionsBuilder<'a, 'b> {
    let start = _fbb.start_table();
    ArgMaxOptionsBuilder {
      fbb_: _fbb,
      start_: start,
    }
  }
  #[inline]
  pub fn finish(self) -> flatbuffers::WIPOffset<ArgMaxOptions<'a>> {
    let o = self.fbb_.end_table(self.start_);
    flatbuffers::WIPOffset::new(o.value())
  }
}

impl core::fmt::Debug for ArgMaxOptions<'_> {
  fn fmt(&self, f: &mut core::fmt::Formatter<'_>) -> core::fmt::Result {
    let mut ds = f.debug_struct("ArgMaxOptions");
      ds.field("output_type", &self.output_type());
      ds.finish()
  }
}
#[non_exhaustive]
#[derive(Debug, Clone, PartialEq)]
pub struct ArgMaxOptionsT {
  pub output_type: TensorType,
}
impl Default for ArgMaxOptionsT {
  fn default() -> Self {
    Self {
      output_type: TensorType::FLOAT32,
    }
  }
}
impl ArgMaxOptionsT {
  pub fn pack<'b>(
    &self,
    _fbb: &mut flatbuffers::FlatBufferBuilder<'b>
  ) -> flatbuffers::WIPOffset<ArgMaxOptions<'b>> {
    let output_type = self.output_type;
    ArgMaxOptions::create(_fbb, &ArgMaxOptionsArgs{
      output_type,
    })
  }
}
pub enum ArgMinOptionsOffset {}
#[derive(Copy, Clone, PartialEq)]

pub struct ArgMinOptions<'a> {
  pub _tab: flatbuffers::Table<'a>,
}

impl<'a> flatbuffers::Follow<'a> for ArgMinOptions<'a> {
  type Inner = ArgMinOptions<'a>;
  #[inline]
  fn follow(buf: &'a [u8], loc: usize) -> Self::Inner {
    Self { _tab: flatbuffers::Table { buf, loc } }
  }
}

impl<'a> ArgMinOptions<'a> {
  pub const VT_OUTPUT_TYPE: flatbuffers::VOffsetT = 4;

  #[inline]
  pub fn init_from_table(table: flatbuffers::Table<'a>) -> Self {
    ArgMinOptions { _tab: table }
  }
  #[allow(unused_mut)]
  pub fn create<'bldr: 'args, 'args: 'mut_bldr, 'mut_bldr>(
    _fbb: &'mut_bldr mut flatbuffers::FlatBufferBuilder<'bldr>,
    args: &'args ArgMinOptionsArgs
  ) -> flatbuffers::WIPOffset<ArgMinOptions<'bldr>> {
    let mut builder = ArgMinOptionsBuilder::new(_fbb);
    builder.add_output_type(args.output_type);
    builder.finish()
  }

  pub fn unpack(&self) -> ArgMinOptionsT {
    let output_type = self.output_type();
    ArgMinOptionsT {
      output_type,
    }
  }

  #[inline]
  pub fn output_type(&self) -> TensorType {
    self._tab.get::<TensorType>(ArgMinOptions::VT_OUTPUT_TYPE, Some(TensorType::FLOAT32)).unwrap()
  }
}

impl flatbuffers::Verifiable for ArgMinOptions<'_> {
  #[inline]
  fn run_verifier(
    v: &mut flatbuffers::Verifier, pos: usize
  ) -> Result<(), flatbuffers::InvalidFlatbuffer> {
    use self::flatbuffers::Verifiable;
    v.visit_table(pos)?
     .visit_field::<TensorType>("output_type", Self::VT_OUTPUT_TYPE, false)?
     .finish();
    Ok(())
  }
}
pub struct ArgMinOptionsArgs {
    pub output_type: TensorType,
}
impl<'a> Default for ArgMinOptionsArgs {
  #[inline]
  fn default() -> Self {
    ArgMinOptionsArgs {
      output_type: TensorType::FLOAT32,
    }
  }
}

pub struct ArgMinOptionsBuilder<'a: 'b, 'b> {
  fbb_: &'b mut flatbuffers::FlatBufferBuilder<'a>,
  start_: flatbuffers::WIPOffset<flatbuffers::TableUnfinishedWIPOffset>,
}
impl<'a: 'b, 'b> ArgMinOptionsBuilder<'a, 'b> {
  #[inline]
  pub fn add_output_type(&mut self, output_type: TensorType) {
    self.fbb_.push_slot::<TensorType>(ArgMinOptions::VT_OUTPUT_TYPE, output_type, TensorType::FLOAT32);
  }
  #[inline]
  pub fn new(_fbb: &'b mut flatbuffers::FlatBufferBuilder<'a>) -> ArgMinOptionsBuilder<'a, 'b> {
    let start = _fbb.start_table();
    ArgMinOptionsBuilder {
      fbb_: _fbb,
      start_: start,
    }
  }
  #[inline]
  pub fn finish(self) -> flatbuffers::WIPOffset<ArgMinOptions<'a>> {
    let o = self.fbb_.end_table(self.start_);
    flatbuffers::WIPOffset::new(o.value())
  }
}

impl core::fmt::Debug for ArgMinOptions<'_> {
  fn fmt(&self, f: &mut core::fmt::Formatter<'_>) -> core::fmt::Result {
    let mut ds = f.debug_struct("ArgMinOptions");
      ds.field("output_type", &self.output_type());
      ds.finish()
  }
}
#[non_exhaustive]
#[derive(Debug, Clone, PartialEq)]
pub struct ArgMinOptionsT {
  pub output_type: TensorType,
}
impl Default for ArgMinOptionsT {
  fn default() -> Self {
    Self {
      output_type: TensorType::FLOAT32,
    }
  }
}
impl ArgMinOptionsT {
  pub fn pack<'b>(
    &self,
    _fbb: &mut flatbuffers::FlatBufferBuilder<'b>
  ) -> flatbuffers::WIPOffset<ArgMinOptions<'b>> {
    let output_type = self.output_type;
    ArgMinOptions::create(_fbb, &ArgMinOptionsArgs{
      output_type,
    })
  }
}
pub enum GreaterOptionsOffset {}
#[derive(Copy, Clone, PartialEq)]

pub struct GreaterOptions<'a> {
  pub _tab: flatbuffers::Table<'a>,
}

impl<'a> flatbuffers::Follow<'a> for GreaterOptions<'a> {
  type Inner = GreaterOptions<'a>;
  #[inline]
  fn follow(buf: &'a [u8], loc: usize) -> Self::Inner {
    Self { _tab: flatbuffers::Table { buf, loc } }
  }
}

impl<'a> GreaterOptions<'a> {

  #[inline]
  pub fn init_from_table(table: flatbuffers::Table<'a>) -> Self {
    GreaterOptions { _tab: table }
  }
  #[allow(unused_mut)]
  pub fn create<'bldr: 'args, 'args: 'mut_bldr, 'mut_bldr>(
    _fbb: &'mut_bldr mut flatbuffers::FlatBufferBuilder<'bldr>,
    _args: &'args GreaterOptionsArgs
  ) -> flatbuffers::WIPOffset<GreaterOptions<'bldr>> {
    let mut builder = GreaterOptionsBuilder::new(_fbb);
    builder.finish()
  }

  pub fn unpack(&self) -> GreaterOptionsT {
    GreaterOptionsT {
    }
  }
}

impl flatbuffers::Verifiable for GreaterOptions<'_> {
  #[inline]
  fn run_verifier(
    v: &mut flatbuffers::Verifier, pos: usize
  ) -> Result<(), flatbuffers::InvalidFlatbuffer> {
    use self::flatbuffers::Verifiable;
    v.visit_table(pos)?
     .finish();
    Ok(())
  }
}
pub struct GreaterOptionsArgs {
}
impl<'a> Default for GreaterOptionsArgs {
  #[inline]
  fn default() -> Self {
    GreaterOptionsArgs {
    }
  }
}

pub struct GreaterOptionsBuilder<'a: 'b, 'b> {
  fbb_: &'b mut flatbuffers::FlatBufferBuilder<'a>,
  start_: flatbuffers::WIPOffset<flatbuffers::TableUnfinishedWIPOffset>,
}
impl<'a: 'b, 'b> GreaterOptionsBuilder<'a, 'b> {
  #[inline]
  pub fn new(_fbb: &'b mut flatbuffers::FlatBufferBuilder<'a>) -> GreaterOptionsBuilder<'a, 'b> {
    let start = _fbb.start_table();
    GreaterOptionsBuilder {
      fbb_: _fbb,
      start_: start,
    }
  }
  #[inline]
  pub fn finish(self) -> flatbuffers::WIPOffset<GreaterOptions<'a>> {
    let o = self.fbb_.end_table(self.start_);
    flatbuffers::WIPOffset::new(o.value())
  }
}

impl core::fmt::Debug for GreaterOptions<'_> {
  fn fmt(&self, f: &mut core::fmt::Formatter<'_>) -> core::fmt::Result {
    let mut ds = f.debug_struct("GreaterOptions");
      ds.finish()
  }
}
#[non_exhaustive]
#[derive(Debug, Clone, PartialEq)]
pub struct GreaterOptionsT {
}
impl Default for GreaterOptionsT {
  fn default() -> Self {
    Self {
    }
  }
}
impl GreaterOptionsT {
  pub fn pack<'b>(
    &self,
    _fbb: &mut flatbuffers::FlatBufferBuilder<'b>
  ) -> flatbuffers::WIPOffset<GreaterOptions<'b>> {
    GreaterOptions::create(_fbb, &GreaterOptionsArgs{
    })
  }
}
pub enum GreaterEqualOptionsOffset {}
#[derive(Copy, Clone, PartialEq)]

pub struct GreaterEqualOptions<'a> {
  pub _tab: flatbuffers::Table<'a>,
}

impl<'a> flatbuffers::Follow<'a> for GreaterEqualOptions<'a> {
  type Inner = GreaterEqualOptions<'a>;
  #[inline]
  fn follow(buf: &'a [u8], loc: usize) -> Self::Inner {
    Self { _tab: flatbuffers::Table { buf, loc } }
  }
}

impl<'a> GreaterEqualOptions<'a> {

  #[inline]
  pub fn init_from_table(table: flatbuffers::Table<'a>) -> Self {
    GreaterEqualOptions { _tab: table }
  }
  #[allow(unused_mut)]
  pub fn create<'bldr: 'args, 'args: 'mut_bldr, 'mut_bldr>(
    _fbb: &'mut_bldr mut flatbuffers::FlatBufferBuilder<'bldr>,
    _args: &'args GreaterEqualOptionsArgs
  ) -> flatbuffers::WIPOffset<GreaterEqualOptions<'bldr>> {
    let mut builder = GreaterEqualOptionsBuilder::new(_fbb);
    builder.finish()
  }

  pub fn unpack(&self) -> GreaterEqualOptionsT {
    GreaterEqualOptionsT {
    }
  }
}

impl flatbuffers::Verifiable for GreaterEqualOptions<'_> {
  #[inline]
  fn run_verifier(
    v: &mut flatbuffers::Verifier, pos: usize
  ) -> Result<(), flatbuffers::InvalidFlatbuffer> {
    use self::flatbuffers::Verifiable;
    v.visit_table(pos)?
     .finish();
    Ok(())
  }
}
pub struct GreaterEqualOptionsArgs {
}
impl<'a> Default for GreaterEqualOptionsArgs {
  #[inline]
  fn default() -> Self {
    GreaterEqualOptionsArgs {
    }
  }
}

pub struct GreaterEqualOptionsBuilder<'a: 'b, 'b> {
  fbb_: &'b mut flatbuffers::FlatBufferBuilder<'a>,
  start_: flatbuffers::WIPOffset<flatbuffers::TableUnfinishedWIPOffset>,
}
impl<'a: 'b, 'b> GreaterEqualOptionsBuilder<'a, 'b> {
  #[inline]
  pub fn new(_fbb: &'b mut flatbuffers::FlatBufferBuilder<'a>) -> GreaterEqualOptionsBuilder<'a, 'b> {
    let start = _fbb.start_table();
    GreaterEqualOptionsBuilder {
      fbb_: _fbb,
      start_: start,
    }
  }
  #[inline]
  pub fn finish(self) -> flatbuffers::WIPOffset<GreaterEqualOptions<'a>> {
    let o = self.fbb_.end_table(self.start_);
    flatbuffers::WIPOffset::new(o.value())
  }
}

impl core::fmt::Debug for GreaterEqualOptions<'_> {
  fn fmt(&self, f: &mut core::fmt::Formatter<'_>) -> core::fmt::Result {
    let mut ds = f.debug_struct("GreaterEqualOptions");
      ds.finish()
  }
}
#[non_exhaustive]
#[derive(Debug, Clone, PartialEq)]
pub struct GreaterEqualOptionsT {
}
impl Default for GreaterEqualOptionsT {
  fn default() -> Self {
    Self {
    }
  }
}
impl GreaterEqualOptionsT {
  pub fn pack<'b>(
    &self,
    _fbb: &mut flatbuffers::FlatBufferBuilder<'b>
  ) -> flatbuffers::WIPOffset<GreaterEqualOptions<'b>> {
    GreaterEqualOptions::create(_fbb, &GreaterEqualOptionsArgs{
    })
  }
}
pub enum LessOptionsOffset {}
#[derive(Copy, Clone, PartialEq)]

pub struct LessOptions<'a> {
  pub _tab: flatbuffers::Table<'a>,
}

impl<'a> flatbuffers::Follow<'a> for LessOptions<'a> {
  type Inner = LessOptions<'a>;
  #[inline]
  fn follow(buf: &'a [u8], loc: usize) -> Self::Inner {
    Self { _tab: flatbuffers::Table { buf, loc } }
  }
}

impl<'a> LessOptions<'a> {

  #[inline]
  pub fn init_from_table(table: flatbuffers::Table<'a>) -> Self {
    LessOptions { _tab: table }
  }
  #[allow(unused_mut)]
  pub fn create<'bldr: 'args, 'args: 'mut_bldr, 'mut_bldr>(
    _fbb: &'mut_bldr mut flatbuffers::FlatBufferBuilder<'bldr>,
    _args: &'args LessOptionsArgs
  ) -> flatbuffers::WIPOffset<LessOptions<'bldr>> {
    let mut builder = LessOptionsBuilder::new(_fbb);
    builder.finish()
  }

  pub fn unpack(&self) -> LessOptionsT {
    LessOptionsT {
    }
  }
}

impl flatbuffers::Verifiable for LessOptions<'_> {
  #[inline]
  fn run_verifier(
    v: &mut flatbuffers::Verifier, pos: usize
  ) -> Result<(), flatbuffers::InvalidFlatbuffer> {
    use self::flatbuffers::Verifiable;
    v.visit_table(pos)?
     .finish();
    Ok(())
  }
}
pub struct LessOptionsArgs {
}
impl<'a> Default for LessOptionsArgs {
  #[inline]
  fn default() -> Self {
    LessOptionsArgs {
    }
  }
}

pub struct LessOptionsBuilder<'a: 'b, 'b> {
  fbb_: &'b mut flatbuffers::FlatBufferBuilder<'a>,
  start_: flatbuffers::WIPOffset<flatbuffers::TableUnfinishedWIPOffset>,
}
impl<'a: 'b, 'b> LessOptionsBuilder<'a, 'b> {
  #[inline]
  pub fn new(_fbb: &'b mut flatbuffers::FlatBufferBuilder<'a>) -> LessOptionsBuilder<'a, 'b> {
    let start = _fbb.start_table();
    LessOptionsBuilder {
      fbb_: _fbb,
      start_: start,
    }
  }
  #[inline]
  pub fn finish(self) -> flatbuffers::WIPOffset<LessOptions<'a>> {
    let o = self.fbb_.end_table(self.start_);
    flatbuffers::WIPOffset::new(o.value())
  }
}

impl core::fmt::Debug for LessOptions<'_> {
  fn fmt(&self, f: &mut core::fmt::Formatter<'_>) -> core::fmt::Result {
    let mut ds = f.debug_struct("LessOptions");
      ds.finish()
  }
}
#[non_exhaustive]
#[derive(Debug, Clone, PartialEq)]
pub struct LessOptionsT {
}
impl Default for LessOptionsT {
  fn default() -> Self {
    Self {
    }
  }
}
impl LessOptionsT {
  pub fn pack<'b>(
    &self,
    _fbb: &mut flatbuffers::FlatBufferBuilder<'b>
  ) -> flatbuffers::WIPOffset<LessOptions<'b>> {
    LessOptions::create(_fbb, &LessOptionsArgs{
    })
  }
}
pub enum LessEqualOptionsOffset {}
#[derive(Copy, Clone, PartialEq)]

pub struct LessEqualOptions<'a> {
  pub _tab: flatbuffers::Table<'a>,
}

impl<'a> flatbuffers::Follow<'a> for LessEqualOptions<'a> {
  type Inner = LessEqualOptions<'a>;
  #[inline]
  fn follow(buf: &'a [u8], loc: usize) -> Self::Inner {
    Self { _tab: flatbuffers::Table { buf, loc } }
  }
}

impl<'a> LessEqualOptions<'a> {

  #[inline]
  pub fn init_from_table(table: flatbuffers::Table<'a>) -> Self {
    LessEqualOptions { _tab: table }
  }
  #[allow(unused_mut)]
  pub fn create<'bldr: 'args, 'args: 'mut_bldr, 'mut_bldr>(
    _fbb: &'mut_bldr mut flatbuffers::FlatBufferBuilder<'bldr>,
    _args: &'args LessEqualOptionsArgs
  ) -> flatbuffers::WIPOffset<LessEqualOptions<'bldr>> {
    let mut builder = LessEqualOptionsBuilder::new(_fbb);
    builder.finish()
  }

  pub fn unpack(&self) -> LessEqualOptionsT {
    LessEqualOptionsT {
    }
  }
}

impl flatbuffers::Verifiable for LessEqualOptions<'_> {
  #[inline]
  fn run_verifier(
    v: &mut flatbuffers::Verifier, pos: usize
  ) -> Result<(), flatbuffers::InvalidFlatbuffer> {
    use self::flatbuffers::Verifiable;
    v.visit_table(pos)?
     .finish();
    Ok(())
  }
}
pub struct LessEqualOptionsArgs {
}
impl<'a> Default for LessEqualOptionsArgs {
  #[inline]
  fn default() -> Self {
    LessEqualOptionsArgs {
    }
  }
}

pub struct LessEqualOptionsBuilder<'a: 'b, 'b> {
  fbb_: &'b mut flatbuffers::FlatBufferBuilder<'a>,
  start_: flatbuffers::WIPOffset<flatbuffers::TableUnfinishedWIPOffset>,
}
impl<'a: 'b, 'b> LessEqualOptionsBuilder<'a, 'b> {
  #[inline]
  pub fn new(_fbb: &'b mut flatbuffers::FlatBufferBuilder<'a>) -> LessEqualOptionsBuilder<'a, 'b> {
    let start = _fbb.start_table();
    LessEqualOptionsBuilder {
      fbb_: _fbb,
      start_: start,
    }
  }
  #[inline]
  pub fn finish(self) -> flatbuffers::WIPOffset<LessEqualOptions<'a>> {
    let o = self.fbb_.end_table(self.start_);
    flatbuffers::WIPOffset::new(o.value())
  }
}

impl core::fmt::Debug for LessEqualOptions<'_> {
  fn fmt(&self, f: &mut core::fmt::Formatter<'_>) -> core::fmt::Result {
    let mut ds = f.debug_struct("LessEqualOptions");
      ds.finish()
  }
}
#[non_exhaustive]
#[derive(Debug, Clone, PartialEq)]
pub struct LessEqualOptionsT {
}
impl Default for LessEqualOptionsT {
  fn default() -> Self {
    Self {
    }
  }
}
impl LessEqualOptionsT {
  pub fn pack<'b>(
    &self,
    _fbb: &mut flatbuffers::FlatBufferBuilder<'b>
  ) -> flatbuffers::WIPOffset<LessEqualOptions<'b>> {
    LessEqualOptions::create(_fbb, &LessEqualOptionsArgs{
    })
  }
}
pub enum NegOptionsOffset {}
#[derive(Copy, Clone, PartialEq)]

pub struct NegOptions<'a> {
  pub _tab: flatbuffers::Table<'a>,
}

impl<'a> flatbuffers::Follow<'a> for NegOptions<'a> {
  type Inner = NegOptions<'a>;
  #[inline]
  fn follow(buf: &'a [u8], loc: usize) -> Self::Inner {
    Self { _tab: flatbuffers::Table { buf, loc } }
  }
}

impl<'a> NegOptions<'a> {

  #[inline]
  pub fn init_from_table(table: flatbuffers::Table<'a>) -> Self {
    NegOptions { _tab: table }
  }
  #[allow(unused_mut)]
  pub fn create<'bldr: 'args, 'args: 'mut_bldr, 'mut_bldr>(
    _fbb: &'mut_bldr mut flatbuffers::FlatBufferBuilder<'bldr>,
    _args: &'args NegOptionsArgs
  ) -> flatbuffers::WIPOffset<NegOptions<'bldr>> {
    let mut builder = NegOptionsBuilder::new(_fbb);
    builder.finish()
  }

  pub fn unpack(&self) -> NegOptionsT {
    NegOptionsT {
    }
  }
}

impl flatbuffers::Verifiable for NegOptions<'_> {
  #[inline]
  fn run_verifier(
    v: &mut flatbuffers::Verifier, pos: usize
  ) -> Result<(), flatbuffers::InvalidFlatbuffer> {
    use self::flatbuffers::Verifiable;
    v.visit_table(pos)?
     .finish();
    Ok(())
  }
}
pub struct NegOptionsArgs {
}
impl<'a> Default for NegOptionsArgs {
  #[inline]
  fn default() -> Self {
    NegOptionsArgs {
    }
  }
}

pub struct NegOptionsBuilder<'a: 'b, 'b> {
  fbb_: &'b mut flatbuffers::FlatBufferBuilder<'a>,
  start_: flatbuffers::WIPOffset<flatbuffers::TableUnfinishedWIPOffset>,
}
impl<'a: 'b, 'b> NegOptionsBuilder<'a, 'b> {
  #[inline]
  pub fn new(_fbb: &'b mut flatbuffers::FlatBufferBuilder<'a>) -> NegOptionsBuilder<'a, 'b> {
    let start = _fbb.start_table();
    NegOptionsBuilder {
      fbb_: _fbb,
      start_: start,
    }
  }
  #[inline]
  pub fn finish(self) -> flatbuffers::WIPOffset<NegOptions<'a>> {
    let o = self.fbb_.end_table(self.start_);
    flatbuffers::WIPOffset::new(o.value())
  }
}

impl core::fmt::Debug for NegOptions<'_> {
  fn fmt(&self, f: &mut core::fmt::Formatter<'_>) -> core::fmt::Result {
    let mut ds = f.debug_struct("NegOptions");
      ds.finish()
  }
}
#[non_exhaustive]
#[derive(Debug, Clone, PartialEq)]
pub struct NegOptionsT {
}
impl Default for NegOptionsT {
  fn default() -> Self {
    Self {
    }
  }
}
impl NegOptionsT {
  pub fn pack<'b>(
    &self,
    _fbb: &mut flatbuffers::FlatBufferBuilder<'b>
  ) -> flatbuffers::WIPOffset<NegOptions<'b>> {
    NegOptions::create(_fbb, &NegOptionsArgs{
    })
  }
}
pub enum SelectOptionsOffset {}
#[derive(Copy, Clone, PartialEq)]

pub struct SelectOptions<'a> {
  pub _tab: flatbuffers::Table<'a>,
}

impl<'a> flatbuffers::Follow<'a> for SelectOptions<'a> {
  type Inner = SelectOptions<'a>;
  #[inline]
  fn follow(buf: &'a [u8], loc: usize) -> Self::Inner {
    Self { _tab: flatbuffers::Table { buf, loc } }
  }
}

impl<'a> SelectOptions<'a> {

  #[inline]
  pub fn init_from_table(table: flatbuffers::Table<'a>) -> Self {
    SelectOptions { _tab: table }
  }
  #[allow(unused_mut)]
  pub fn create<'bldr: 'args, 'args: 'mut_bldr, 'mut_bldr>(
    _fbb: &'mut_bldr mut flatbuffers::FlatBufferBuilder<'bldr>,
    _args: &'args SelectOptionsArgs
  ) -> flatbuffers::WIPOffset<SelectOptions<'bldr>> {
    let mut builder = SelectOptionsBuilder::new(_fbb);
    builder.finish()
  }

  pub fn unpack(&self) -> SelectOptionsT {
    SelectOptionsT {
    }
  }
}

impl flatbuffers::Verifiable for SelectOptions<'_> {
  #[inline]
  fn run_verifier(
    v: &mut flatbuffers::Verifier, pos: usize
  ) -> Result<(), flatbuffers::InvalidFlatbuffer> {
    use self::flatbuffers::Verifiable;
    v.visit_table(pos)?
     .finish();
    Ok(())
  }
}
pub struct SelectOptionsArgs {
}
impl<'a> Default for SelectOptionsArgs {
  #[inline]
  fn default() -> Self {
    SelectOptionsArgs {
    }
  }
}

pub struct SelectOptionsBuilder<'a: 'b, 'b> {
  fbb_: &'b mut flatbuffers::FlatBufferBuilder<'a>,
  start_: flatbuffers::WIPOffset<flatbuffers::TableUnfinishedWIPOffset>,
}
impl<'a: 'b, 'b> SelectOptionsBuilder<'a, 'b> {
  #[inline]
  pub fn new(_fbb: &'b mut flatbuffers::FlatBufferBuilder<'a>) -> SelectOptionsBuilder<'a, 'b> {
    let start = _fbb.start_table();
    SelectOptionsBuilder {
      fbb_: _fbb,
      start_: start,
    }
  }
  #[inline]
  pub fn finish(self) -> flatbuffers::WIPOffset<SelectOptions<'a>> {
    let o = self.fbb_.end_table(self.start_);
    flatbuffers::WIPOffset::new(o.value())
  }
}

impl core::fmt::Debug for SelectOptions<'_> {
  fn fmt(&self, f: &mut core::fmt::Formatter<'_>) -> core::fmt::Result {
    let mut ds = f.debug_struct("SelectOptions");
      ds.finish()
  }
}
#[non_exhaustive]
#[derive(Debug, Clone, PartialEq)]
pub struct SelectOptionsT {
}
impl Default for SelectOptionsT {
  fn default() -> Self {
    Self {
    }
  }
}
impl SelectOptionsT {
  pub fn pack<'b>(
    &self,
    _fbb: &mut flatbuffers::FlatBufferBuilder<'b>
  ) -> flatbuffers::WIPOffset<SelectOptions<'b>> {
    SelectOptions::create(_fbb, &SelectOptionsArgs{
    })
  }
}
pub enum SliceOptionsOffset {}
#[derive(Copy, Clone, PartialEq)]

pub struct SliceOptions<'a> {
  pub _tab: flatbuffers::Table<'a>,
}

impl<'a> flatbuffers::Follow<'a> for SliceOptions<'a> {
  type Inner = SliceOptions<'a>;
  #[inline]
  fn follow(buf: &'a [u8], loc: usize) -> Self::Inner {
    Self { _tab: flatbuffers::Table { buf, loc } }
  }
}

impl<'a> SliceOptions<'a> {

  #[inline]
  pub fn init_from_table(table: flatbuffers::Table<'a>) -> Self {
    SliceOptions { _tab: table }
  }
  #[allow(unused_mut)]
  pub fn create<'bldr: 'args, 'args: 'mut_bldr, 'mut_bldr>(
    _fbb: &'mut_bldr mut flatbuffers::FlatBufferBuilder<'bldr>,
    _args: &'args SliceOptionsArgs
  ) -> flatbuffers::WIPOffset<SliceOptions<'bldr>> {
    let mut builder = SliceOptionsBuilder::new(_fbb);
    builder.finish()
  }

  pub fn unpack(&self) -> SliceOptionsT {
    SliceOptionsT {
    }
  }
}

impl flatbuffers::Verifiable for SliceOptions<'_> {
  #[inline]
  fn run_verifier(
    v: &mut flatbuffers::Verifier, pos: usize
  ) -> Result<(), flatbuffers::InvalidFlatbuffer> {
    use self::flatbuffers::Verifiable;
    v.visit_table(pos)?
     .finish();
    Ok(())
  }
}
pub struct SliceOptionsArgs {
}
impl<'a> Default for SliceOptionsArgs {
  #[inline]
  fn default() -> Self {
    SliceOptionsArgs {
    }
  }
}

pub struct SliceOptionsBuilder<'a: 'b, 'b> {
  fbb_: &'b mut flatbuffers::FlatBufferBuilder<'a>,
  start_: flatbuffers::WIPOffset<flatbuffers::TableUnfinishedWIPOffset>,
}
impl<'a: 'b, 'b> SliceOptionsBuilder<'a, 'b> {
  #[inline]
  pub fn new(_fbb: &'b mut flatbuffers::FlatBufferBuilder<'a>) -> SliceOptionsBuilder<'a, 'b> {
    let start = _fbb.start_table();
    SliceOptionsBuilder {
      fbb_: _fbb,
      start_: start,
    }
  }
  #[inline]
  pub fn finish(self) -> flatbuffers::WIPOffset<SliceOptions<'a>> {
    let o = self.fbb_.end_table(self.start_);
    flatbuffers::WIPOffset::new(o.value())
  }
}

impl core::fmt::Debug for SliceOptions<'_> {
  fn fmt(&self, f: &mut core::fmt::Formatter<'_>) -> core::fmt::Result {
    let mut ds = f.debug_struct("SliceOptions");
      ds.finish()
  }
}
#[non_exhaustive]
#[derive(Debug, Clone, PartialEq)]
pub struct SliceOptionsT {
}
impl Default for SliceOptionsT {
  fn default() -> Self {
    Self {
    }
  }
}
impl SliceOptionsT {
  pub fn pack<'b>(
    &self,
    _fbb: &mut flatbuffers::FlatBufferBuilder<'b>
  ) -> flatbuffers::WIPOffset<SliceOptions<'b>> {
    SliceOptions::create(_fbb, &SliceOptionsArgs{
    })
  }
}
pub enum TransposeConvOptionsOffset {}
#[derive(Copy, Clone, PartialEq)]

pub struct TransposeConvOptions<'a> {
  pub _tab: flatbuffers::Table<'a>,
}

impl<'a> flatbuffers::Follow<'a> for TransposeConvOptions<'a> {
  type Inner = TransposeConvOptions<'a>;
  #[inline]
  fn follow(buf: &'a [u8], loc: usize) -> Self::Inner {
    Self { _tab: flatbuffers::Table { buf, loc } }
  }
}

impl<'a> TransposeConvOptions<'a> {
  pub const VT_PADDING: flatbuffers::VOffsetT = 4;
  pub const VT_STRIDE_W: flatbuffers::VOffsetT = 6;
  pub const VT_STRIDE_H: flatbuffers::VOffsetT = 8;

  #[inline]
  pub fn init_from_table(table: flatbuffers::Table<'a>) -> Self {
    TransposeConvOptions { _tab: table }
  }
  #[allow(unused_mut)]
  pub fn create<'bldr: 'args, 'args: 'mut_bldr, 'mut_bldr>(
    _fbb: &'mut_bldr mut flatbuffers::FlatBufferBuilder<'bldr>,
    args: &'args TransposeConvOptionsArgs
  ) -> flatbuffers::WIPOffset<TransposeConvOptions<'bldr>> {
    let mut builder = TransposeConvOptionsBuilder::new(_fbb);
    builder.add_stride_h(args.stride_h);
    builder.add_stride_w(args.stride_w);
    builder.add_padding(args.padding);
    builder.finish()
  }

  pub fn unpack(&self) -> TransposeConvOptionsT {
    let padding = self.padding();
    let stride_w = self.stride_w();
    let stride_h = self.stride_h();
    TransposeConvOptionsT {
      padding,
      stride_w,
      stride_h,
    }
  }

  #[inline]
  pub fn padding(&self) -> Padding {
    self._tab.get::<Padding>(TransposeConvOptions::VT_PADDING, Some(Padding::SAME)).unwrap()
  }
  #[inline]
  pub fn stride_w(&self) -> i32 {
    self._tab.get::<i32>(TransposeConvOptions::VT_STRIDE_W, Some(0)).unwrap()
  }
  #[inline]
  pub fn stride_h(&self) -> i32 {
    self._tab.get::<i32>(TransposeConvOptions::VT_STRIDE_H, Some(0)).unwrap()
  }
}

impl flatbuffers::Verifiable for TransposeConvOptions<'_> {
  #[inline]
  fn run_verifier(
    v: &mut flatbuffers::Verifier, pos: usize
  ) -> Result<(), flatbuffers::InvalidFlatbuffer> {
    use self::flatbuffers::Verifiable;
    v.visit_table(pos)?
     .visit_field::<Padding>("padding", Self::VT_PADDING, false)?
     .visit_field::<i32>("stride_w", Self::VT_STRIDE_W, false)?
     .visit_field::<i32>("stride_h", Self::VT_STRIDE_H, false)?
     .finish();
    Ok(())
  }
}
pub struct TransposeConvOptionsArgs {
    pub padding: Padding,
    pub stride_w: i32,
    pub stride_h: i32,
}
impl<'a> Default for TransposeConvOptionsArgs {
  #[inline]
  fn default() -> Self {
    TransposeConvOptionsArgs {
      padding: Padding::SAME,
      stride_w: 0,
      stride_h: 0,
    }
  }
}

pub struct TransposeConvOptionsBuilder<'a: 'b, 'b> {
  fbb_: &'b mut flatbuffers::FlatBufferBuilder<'a>,
  start_: flatbuffers::WIPOffset<flatbuffers::TableUnfinishedWIPOffset>,
}
impl<'a: 'b, 'b> TransposeConvOptionsBuilder<'a, 'b> {
  #[inline]
  pub fn add_padding(&mut self, padding: Padding) {
    self.fbb_.push_slot::<Padding>(TransposeConvOptions::VT_PADDING, padding, Padding::SAME);
  }
  #[inline]
  pub fn add_stride_w(&mut self, stride_w: i32) {
    self.fbb_.push_slot::<i32>(TransposeConvOptions::VT_STRIDE_W, stride_w, 0);
  }
  #[inline]
  pub fn add_stride_h(&mut self, stride_h: i32) {
    self.fbb_.push_slot::<i32>(TransposeConvOptions::VT_STRIDE_H, stride_h, 0);
  }
  #[inline]
  pub fn new(_fbb: &'b mut flatbuffers::FlatBufferBuilder<'a>) -> TransposeConvOptionsBuilder<'a, 'b> {
    let start = _fbb.start_table();
    TransposeConvOptionsBuilder {
      fbb_: _fbb,
      start_: start,
    }
  }
  #[inline]
  pub fn finish(self) -> flatbuffers::WIPOffset<TransposeConvOptions<'a>> {
    let o = self.fbb_.end_table(self.start_);
    flatbuffers::WIPOffset::new(o.value())
  }
}

impl core::fmt::Debug for TransposeConvOptions<'_> {
  fn fmt(&self, f: &mut core::fmt::Formatter<'_>) -> core::fmt::Result {
    let mut ds = f.debug_struct("TransposeConvOptions");
      ds.field("padding", &self.padding());
      ds.field("stride_w", &self.stride_w());
      ds.field("stride_h", &self.stride_h());
      ds.finish()
  }
}
#[non_exhaustive]
#[derive(Debug, Clone, PartialEq)]
pub struct TransposeConvOptionsT {
  pub padding: Padding,
  pub stride_w: i32,
  pub stride_h: i32,
}
impl Default for TransposeConvOptionsT {
  fn default() -> Self {
    Self {
      padding: Padding::SAME,
      stride_w: 0,
      stride_h: 0,
    }
  }
}
impl TransposeConvOptionsT {
  pub fn pack<'b>(
    &self,
    _fbb: &mut flatbuffers::FlatBufferBuilder<'b>
  ) -> flatbuffers::WIPOffset<TransposeConvOptions<'b>> {
    let padding = self.padding;
    let stride_w = self.stride_w;
    let stride_h = self.stride_h;
    TransposeConvOptions::create(_fbb, &TransposeConvOptionsArgs{
      padding,
      stride_w,
      stride_h,
    })
  }
}
pub enum ExpandDimsOptionsOffset {}
#[derive(Copy, Clone, PartialEq)]

pub struct ExpandDimsOptions<'a> {
  pub _tab: flatbuffers::Table<'a>,
}

impl<'a> flatbuffers::Follow<'a> for ExpandDimsOptions<'a> {
  type Inner = ExpandDimsOptions<'a>;
  #[inline]
  fn follow(buf: &'a [u8], loc: usize) -> Self::Inner {
    Self { _tab: flatbuffers::Table { buf, loc } }
  }
}

impl<'a> ExpandDimsOptions<'a> {

  #[inline]
  pub fn init_from_table(table: flatbuffers::Table<'a>) -> Self {
    ExpandDimsOptions { _tab: table }
  }
  #[allow(unused_mut)]
  pub fn create<'bldr: 'args, 'args: 'mut_bldr, 'mut_bldr>(
    _fbb: &'mut_bldr mut flatbuffers::FlatBufferBuilder<'bldr>,
    _args: &'args ExpandDimsOptionsArgs
  ) -> flatbuffers::WIPOffset<ExpandDimsOptions<'bldr>> {
    let mut builder = ExpandDimsOptionsBuilder::new(_fbb);
    builder.finish()
  }

  pub fn unpack(&self) -> ExpandDimsOptionsT {
    ExpandDimsOptionsT {
    }
  }
}

impl flatbuffers::Verifiable for ExpandDimsOptions<'_> {
  #[inline]
  fn run_verifier(
    v: &mut flatbuffers::Verifier, pos: usize
  ) -> Result<(), flatbuffers::InvalidFlatbuffer> {
    use self::flatbuffers::Verifiable;
    v.visit_table(pos)?
     .finish();
    Ok(())
  }
}
pub struct ExpandDimsOptionsArgs {
}
impl<'a> Default for ExpandDimsOptionsArgs {
  #[inline]
  fn default() -> Self {
    ExpandDimsOptionsArgs {
    }
  }
}

pub struct ExpandDimsOptionsBuilder<'a: 'b, 'b> {
  fbb_: &'b mut flatbuffers::FlatBufferBuilder<'a>,
  start_: flatbuffers::WIPOffset<flatbuffers::TableUnfinishedWIPOffset>,
}
impl<'a: 'b, 'b> ExpandDimsOptionsBuilder<'a, 'b> {
  #[inline]
  pub fn new(_fbb: &'b mut flatbuffers::FlatBufferBuilder<'a>) -> ExpandDimsOptionsBuilder<'a, 'b> {
    let start = _fbb.start_table();
    ExpandDimsOptionsBuilder {
      fbb_: _fbb,
      start_: start,
    }
  }
  #[inline]
  pub fn finish(self) -> flatbuffers::WIPOffset<ExpandDimsOptions<'a>> {
    let o = self.fbb_.end_table(self.start_);
    flatbuffers::WIPOffset::new(o.value())
  }
}

impl core::fmt::Debug for ExpandDimsOptions<'_> {
  fn fmt(&self, f: &mut core::fmt::Formatter<'_>) -> core::fmt::Result {
    let mut ds = f.debug_struct("ExpandDimsOptions");
      ds.finish()
  }
}
#[non_exhaustive]
#[derive(Debug, Clone, PartialEq)]
pub struct ExpandDimsOptionsT {
}
impl Default for ExpandDimsOptionsT {
  fn default() -> Self {
    Self {
    }
  }
}
impl ExpandDimsOptionsT {
  pub fn pack<'b>(
    &self,
    _fbb: &mut flatbuffers::FlatBufferBuilder<'b>
  ) -> flatbuffers::WIPOffset<ExpandDimsOptions<'b>> {
    ExpandDimsOptions::create(_fbb, &ExpandDimsOptionsArgs{
    })
  }
}
pub enum SparseToDenseOptionsOffset {}
#[derive(Copy, Clone, PartialEq)]

pub struct SparseToDenseOptions<'a> {
  pub _tab: flatbuffers::Table<'a>,
}

impl<'a> flatbuffers::Follow<'a> for SparseToDenseOptions<'a> {
  type Inner = SparseToDenseOptions<'a>;
  #[inline]
  fn follow(buf: &'a [u8], loc: usize) -> Self::Inner {
    Self { _tab: flatbuffers::Table { buf, loc } }
  }
}

impl<'a> SparseToDenseOptions<'a> {
  pub const VT_VALIDATE_INDICES: flatbuffers::VOffsetT = 4;

  #[inline]
  pub fn init_from_table(table: flatbuffers::Table<'a>) -> Self {
    SparseToDenseOptions { _tab: table }
  }
  #[allow(unused_mut)]
  pub fn create<'bldr: 'args, 'args: 'mut_bldr, 'mut_bldr>(
    _fbb: &'mut_bldr mut flatbuffers::FlatBufferBuilder<'bldr>,
    args: &'args SparseToDenseOptionsArgs
  ) -> flatbuffers::WIPOffset<SparseToDenseOptions<'bldr>> {
    let mut builder = SparseToDenseOptionsBuilder::new(_fbb);
    builder.add_validate_indices(args.validate_indices);
    builder.finish()
  }

  pub fn unpack(&self) -> SparseToDenseOptionsT {
    let validate_indices = self.validate_indices();
    SparseToDenseOptionsT {
      validate_indices,
    }
  }

  #[inline]
  pub fn validate_indices(&self) -> bool {
    self._tab.get::<bool>(SparseToDenseOptions::VT_VALIDATE_INDICES, Some(false)).unwrap()
  }
}

impl flatbuffers::Verifiable for SparseToDenseOptions<'_> {
  #[inline]
  fn run_verifier(
    v: &mut flatbuffers::Verifier, pos: usize
  ) -> Result<(), flatbuffers::InvalidFlatbuffer> {
    use self::flatbuffers::Verifiable;
    v.visit_table(pos)?
     .visit_field::<bool>("validate_indices", Self::VT_VALIDATE_INDICES, false)?
     .finish();
    Ok(())
  }
}
pub struct SparseToDenseOptionsArgs {
    pub validate_indices: bool,
}
impl<'a> Default for SparseToDenseOptionsArgs {
  #[inline]
  fn default() -> Self {
    SparseToDenseOptionsArgs {
      validate_indices: false,
    }
  }
}

pub struct SparseToDenseOptionsBuilder<'a: 'b, 'b> {
  fbb_: &'b mut flatbuffers::FlatBufferBuilder<'a>,
  start_: flatbuffers::WIPOffset<flatbuffers::TableUnfinishedWIPOffset>,
}
impl<'a: 'b, 'b> SparseToDenseOptionsBuilder<'a, 'b> {
  #[inline]
  pub fn add_validate_indices(&mut self, validate_indices: bool) {
    self.fbb_.push_slot::<bool>(SparseToDenseOptions::VT_VALIDATE_INDICES, validate_indices, false);
  }
  #[inline]
  pub fn new(_fbb: &'b mut flatbuffers::FlatBufferBuilder<'a>) -> SparseToDenseOptionsBuilder<'a, 'b> {
    let start = _fbb.start_table();
    SparseToDenseOptionsBuilder {
      fbb_: _fbb,
      start_: start,
    }
  }
  #[inline]
  pub fn finish(self) -> flatbuffers::WIPOffset<SparseToDenseOptions<'a>> {
    let o = self.fbb_.end_table(self.start_);
    flatbuffers::WIPOffset::new(o.value())
  }
}

impl core::fmt::Debug for SparseToDenseOptions<'_> {
  fn fmt(&self, f: &mut core::fmt::Formatter<'_>) -> core::fmt::Result {
    let mut ds = f.debug_struct("SparseToDenseOptions");
      ds.field("validate_indices", &self.validate_indices());
      ds.finish()
  }
}
#[non_exhaustive]
#[derive(Debug, Clone, PartialEq)]
pub struct SparseToDenseOptionsT {
  pub validate_indices: bool,
}
impl Default for SparseToDenseOptionsT {
  fn default() -> Self {
    Self {
      validate_indices: false,
    }
  }
}
impl SparseToDenseOptionsT {
  pub fn pack<'b>(
    &self,
    _fbb: &mut flatbuffers::FlatBufferBuilder<'b>
  ) -> flatbuffers::WIPOffset<SparseToDenseOptions<'b>> {
    let validate_indices = self.validate_indices;
    SparseToDenseOptions::create(_fbb, &SparseToDenseOptionsArgs{
      validate_indices,
    })
  }
}
pub enum EqualOptionsOffset {}
#[derive(Copy, Clone, PartialEq)]

pub struct EqualOptions<'a> {
  pub _tab: flatbuffers::Table<'a>,
}

impl<'a> flatbuffers::Follow<'a> for EqualOptions<'a> {
  type Inner = EqualOptions<'a>;
  #[inline]
  fn follow(buf: &'a [u8], loc: usize) -> Self::Inner {
    Self { _tab: flatbuffers::Table { buf, loc } }
  }
}

impl<'a> EqualOptions<'a> {

  #[inline]
  pub fn init_from_table(table: flatbuffers::Table<'a>) -> Self {
    EqualOptions { _tab: table }
  }
  #[allow(unused_mut)]
  pub fn create<'bldr: 'args, 'args: 'mut_bldr, 'mut_bldr>(
    _fbb: &'mut_bldr mut flatbuffers::FlatBufferBuilder<'bldr>,
    _args: &'args EqualOptionsArgs
  ) -> flatbuffers::WIPOffset<EqualOptions<'bldr>> {
    let mut builder = EqualOptionsBuilder::new(_fbb);
    builder.finish()
  }

  pub fn unpack(&self) -> EqualOptionsT {
    EqualOptionsT {
    }
  }
}

impl flatbuffers::Verifiable for EqualOptions<'_> {
  #[inline]
  fn run_verifier(
    v: &mut flatbuffers::Verifier, pos: usize
  ) -> Result<(), flatbuffers::InvalidFlatbuffer> {
    use self::flatbuffers::Verifiable;
    v.visit_table(pos)?
     .finish();
    Ok(())
  }
}
pub struct EqualOptionsArgs {
}
impl<'a> Default for EqualOptionsArgs {
  #[inline]
  fn default() -> Self {
    EqualOptionsArgs {
    }
  }
}

pub struct EqualOptionsBuilder<'a: 'b, 'b> {
  fbb_: &'b mut flatbuffers::FlatBufferBuilder<'a>,
  start_: flatbuffers::WIPOffset<flatbuffers::TableUnfinishedWIPOffset>,
}
impl<'a: 'b, 'b> EqualOptionsBuilder<'a, 'b> {
  #[inline]
  pub fn new(_fbb: &'b mut flatbuffers::FlatBufferBuilder<'a>) -> EqualOptionsBuilder<'a, 'b> {
    let start = _fbb.start_table();
    EqualOptionsBuilder {
      fbb_: _fbb,
      start_: start,
    }
  }
  #[inline]
  pub fn finish(self) -> flatbuffers::WIPOffset<EqualOptions<'a>> {
    let o = self.fbb_.end_table(self.start_);
    flatbuffers::WIPOffset::new(o.value())
  }
}

impl core::fmt::Debug for EqualOptions<'_> {
  fn fmt(&self, f: &mut core::fmt::Formatter<'_>) -> core::fmt::Result {
    let mut ds = f.debug_struct("EqualOptions");
      ds.finish()
  }
}
#[non_exhaustive]
#[derive(Debug, Clone, PartialEq)]
pub struct EqualOptionsT {
}
impl Default for EqualOptionsT {
  fn default() -> Self {
    Self {
    }
  }
}
impl EqualOptionsT {
  pub fn pack<'b>(
    &self,
    _fbb: &mut flatbuffers::FlatBufferBuilder<'b>
  ) -> flatbuffers::WIPOffset<EqualOptions<'b>> {
    EqualOptions::create(_fbb, &EqualOptionsArgs{
    })
  }
}
pub enum NotEqualOptionsOffset {}
#[derive(Copy, Clone, PartialEq)]

pub struct NotEqualOptions<'a> {
  pub _tab: flatbuffers::Table<'a>,
}

impl<'a> flatbuffers::Follow<'a> for NotEqualOptions<'a> {
  type Inner = NotEqualOptions<'a>;
  #[inline]
  fn follow(buf: &'a [u8], loc: usize) -> Self::Inner {
    Self { _tab: flatbuffers::Table { buf, loc } }
  }
}

impl<'a> NotEqualOptions<'a> {

  #[inline]
  pub fn init_from_table(table: flatbuffers::Table<'a>) -> Self {
    NotEqualOptions { _tab: table }
  }
  #[allow(unused_mut)]
  pub fn create<'bldr: 'args, 'args: 'mut_bldr, 'mut_bldr>(
    _fbb: &'mut_bldr mut flatbuffers::FlatBufferBuilder<'bldr>,
    _args: &'args NotEqualOptionsArgs
  ) -> flatbuffers::WIPOffset<NotEqualOptions<'bldr>> {
    let mut builder = NotEqualOptionsBuilder::new(_fbb);
    builder.finish()
  }

  pub fn unpack(&self) -> NotEqualOptionsT {
    NotEqualOptionsT {
    }
  }
}

impl flatbuffers::Verifiable for NotEqualOptions<'_> {
  #[inline]
  fn run_verifier(
    v: &mut flatbuffers::Verifier, pos: usize
  ) -> Result<(), flatbuffers::InvalidFlatbuffer> {
    use self::flatbuffers::Verifiable;
    v.visit_table(pos)?
     .finish();
    Ok(())
  }
}
pub struct NotEqualOptionsArgs {
}
impl<'a> Default for NotEqualOptionsArgs {
  #[inline]
  fn default() -> Self {
    NotEqualOptionsArgs {
    }
  }
}

pub struct NotEqualOptionsBuilder<'a: 'b, 'b> {
  fbb_: &'b mut flatbuffers::FlatBufferBuilder<'a>,
  start_: flatbuffers::WIPOffset<flatbuffers::TableUnfinishedWIPOffset>,
}
impl<'a: 'b, 'b> NotEqualOptionsBuilder<'a, 'b> {
  #[inline]
  pub fn new(_fbb: &'b mut flatbuffers::FlatBufferBuilder<'a>) -> NotEqualOptionsBuilder<'a, 'b> {
    let start = _fbb.start_table();
    NotEqualOptionsBuilder {
      fbb_: _fbb,
      start_: start,
    }
  }
  #[inline]
  pub fn finish(self) -> flatbuffers::WIPOffset<NotEqualOptions<'a>> {
    let o = self.fbb_.end_table(self.start_);
    flatbuffers::WIPOffset::new(o.value())
  }
}

impl core::fmt::Debug for NotEqualOptions<'_> {
  fn fmt(&self, f: &mut core::fmt::Formatter<'_>) -> core::fmt::Result {
    let mut ds = f.debug_struct("NotEqualOptions");
      ds.finish()
  }
}
#[non_exhaustive]
#[derive(Debug, Clone, PartialEq)]
pub struct NotEqualOptionsT {
}
impl Default for NotEqualOptionsT {
  fn default() -> Self {
    Self {
    }
  }
}
impl NotEqualOptionsT {
  pub fn pack<'b>(
    &self,
    _fbb: &mut flatbuffers::FlatBufferBuilder<'b>
  ) -> flatbuffers::WIPOffset<NotEqualOptions<'b>> {
    NotEqualOptions::create(_fbb, &NotEqualOptionsArgs{
    })
  }
}
pub enum ShapeOptionsOffset {}
#[derive(Copy, Clone, PartialEq)]

pub struct ShapeOptions<'a> {
  pub _tab: flatbuffers::Table<'a>,
}

impl<'a> flatbuffers::Follow<'a> for ShapeOptions<'a> {
  type Inner = ShapeOptions<'a>;
  #[inline]
  fn follow(buf: &'a [u8], loc: usize) -> Self::Inner {
    Self { _tab: flatbuffers::Table { buf, loc } }
  }
}

impl<'a> ShapeOptions<'a> {
  pub const VT_OUT_TYPE: flatbuffers::VOffsetT = 4;

  #[inline]
  pub fn init_from_table(table: flatbuffers::Table<'a>) -> Self {
    ShapeOptions { _tab: table }
  }
  #[allow(unused_mut)]
  pub fn create<'bldr: 'args, 'args: 'mut_bldr, 'mut_bldr>(
    _fbb: &'mut_bldr mut flatbuffers::FlatBufferBuilder<'bldr>,
    args: &'args ShapeOptionsArgs
  ) -> flatbuffers::WIPOffset<ShapeOptions<'bldr>> {
    let mut builder = ShapeOptionsBuilder::new(_fbb);
    builder.add_out_type(args.out_type);
    builder.finish()
  }

  pub fn unpack(&self) -> ShapeOptionsT {
    let out_type = self.out_type();
    ShapeOptionsT {
      out_type,
    }
  }

  #[inline]
  pub fn out_type(&self) -> TensorType {
    self._tab.get::<TensorType>(ShapeOptions::VT_OUT_TYPE, Some(TensorType::FLOAT32)).unwrap()
  }
}

impl flatbuffers::Verifiable for ShapeOptions<'_> {
  #[inline]
  fn run_verifier(
    v: &mut flatbuffers::Verifier, pos: usize
  ) -> Result<(), flatbuffers::InvalidFlatbuffer> {
    use self::flatbuffers::Verifiable;
    v.visit_table(pos)?
     .visit_field::<TensorType>("out_type", Self::VT_OUT_TYPE, false)?
     .finish();
    Ok(())
  }
}
pub struct ShapeOptionsArgs {
    pub out_type: TensorType,
}
impl<'a> Default for ShapeOptionsArgs {
  #[inline]
  fn default() -> Self {
    ShapeOptionsArgs {
      out_type: TensorType::FLOAT32,
    }
  }
}

pub struct ShapeOptionsBuilder<'a: 'b, 'b> {
  fbb_: &'b mut flatbuffers::FlatBufferBuilder<'a>,
  start_: flatbuffers::WIPOffset<flatbuffers::TableUnfinishedWIPOffset>,
}
impl<'a: 'b, 'b> ShapeOptionsBuilder<'a, 'b> {
  #[inline]
  pub fn add_out_type(&mut self, out_type: TensorType) {
    self.fbb_.push_slot::<TensorType>(ShapeOptions::VT_OUT_TYPE, out_type, TensorType::FLOAT32);
  }
  #[inline]
  pub fn new(_fbb: &'b mut flatbuffers::FlatBufferBuilder<'a>) -> ShapeOptionsBuilder<'a, 'b> {
    let start = _fbb.start_table();
    ShapeOptionsBuilder {
      fbb_: _fbb,
      start_: start,
    }
  }
  #[inline]
  pub fn finish(self) -> flatbuffers::WIPOffset<ShapeOptions<'a>> {
    let o = self.fbb_.end_table(self.start_);
    flatbuffers::WIPOffset::new(o.value())
  }
}

impl core::fmt::Debug for ShapeOptions<'_> {
  fn fmt(&self, f: &mut core::fmt::Formatter<'_>) -> core::fmt::Result {
    let mut ds = f.debug_struct("ShapeOptions");
      ds.field("out_type", &self.out_type());
      ds.finish()
  }
}
#[non_exhaustive]
#[derive(Debug, Clone, PartialEq)]
pub struct ShapeOptionsT {
  pub out_type: TensorType,
}
impl Default for ShapeOptionsT {
  fn default() -> Self {
    Self {
      out_type: TensorType::FLOAT32,
    }
  }
}
impl ShapeOptionsT {
  pub fn pack<'b>(
    &self,
    _fbb: &mut flatbuffers::FlatBufferBuilder<'b>
  ) -> flatbuffers::WIPOffset<ShapeOptions<'b>> {
    let out_type = self.out_type;
    ShapeOptions::create(_fbb, &ShapeOptionsArgs{
      out_type,
    })
  }
}
pub enum RankOptionsOffset {}
#[derive(Copy, Clone, PartialEq)]

pub struct RankOptions<'a> {
  pub _tab: flatbuffers::Table<'a>,
}

impl<'a> flatbuffers::Follow<'a> for RankOptions<'a> {
  type Inner = RankOptions<'a>;
  #[inline]
  fn follow(buf: &'a [u8], loc: usize) -> Self::Inner {
    Self { _tab: flatbuffers::Table { buf, loc } }
  }
}

impl<'a> RankOptions<'a> {

  #[inline]
  pub fn init_from_table(table: flatbuffers::Table<'a>) -> Self {
    RankOptions { _tab: table }
  }
  #[allow(unused_mut)]
  pub fn create<'bldr: 'args, 'args: 'mut_bldr, 'mut_bldr>(
    _fbb: &'mut_bldr mut flatbuffers::FlatBufferBuilder<'bldr>,
    _args: &'args RankOptionsArgs
  ) -> flatbuffers::WIPOffset<RankOptions<'bldr>> {
    let mut builder = RankOptionsBuilder::new(_fbb);
    builder.finish()
  }

  pub fn unpack(&self) -> RankOptionsT {
    RankOptionsT {
    }
  }
}

impl flatbuffers::Verifiable for RankOptions<'_> {
  #[inline]
  fn run_verifier(
    v: &mut flatbuffers::Verifier, pos: usize
  ) -> Result<(), flatbuffers::InvalidFlatbuffer> {
    use self::flatbuffers::Verifiable;
    v.visit_table(pos)?
     .finish();
    Ok(())
  }
}
pub struct RankOptionsArgs {
}
impl<'a> Default for RankOptionsArgs {
  #[inline]
  fn default() -> Self {
    RankOptionsArgs {
    }
  }
}

pub struct RankOptionsBuilder<'a: 'b, 'b> {
  fbb_: &'b mut flatbuffers::FlatBufferBuilder<'a>,
  start_: flatbuffers::WIPOffset<flatbuffers::TableUnfinishedWIPOffset>,
}
impl<'a: 'b, 'b> RankOptionsBuilder<'a, 'b> {
  #[inline]
  pub fn new(_fbb: &'b mut flatbuffers::FlatBufferBuilder<'a>) -> RankOptionsBuilder<'a, 'b> {
    let start = _fbb.start_table();
    RankOptionsBuilder {
      fbb_: _fbb,
      start_: start,
    }
  }
  #[inline]
  pub fn finish(self) -> flatbuffers::WIPOffset<RankOptions<'a>> {
    let o = self.fbb_.end_table(self.start_);
    flatbuffers::WIPOffset::new(o.value())
  }
}

impl core::fmt::Debug for RankOptions<'_> {
  fn fmt(&self, f: &mut core::fmt::Formatter<'_>) -> core::fmt::Result {
    let mut ds = f.debug_struct("RankOptions");
      ds.finish()
  }
}
#[non_exhaustive]
#[derive(Debug, Clone, PartialEq)]
pub struct RankOptionsT {
}
impl Default for RankOptionsT {
  fn default() -> Self {
    Self {
    }
  }
}
impl RankOptionsT {
  pub fn pack<'b>(
    &self,
    _fbb: &mut flatbuffers::FlatBufferBuilder<'b>
  ) -> flatbuffers::WIPOffset<RankOptions<'b>> {
    RankOptions::create(_fbb, &RankOptionsArgs{
    })
  }
}
pub enum PowOptionsOffset {}
#[derive(Copy, Clone, PartialEq)]

pub struct PowOptions<'a> {
  pub _tab: flatbuffers::Table<'a>,
}

impl<'a> flatbuffers::Follow<'a> for PowOptions<'a> {
  type Inner = PowOptions<'a>;
  #[inline]
  fn follow(buf: &'a [u8], loc: usize) -> Self::Inner {
    Self { _tab: flatbuffers::Table { buf, loc } }
  }
}

impl<'a> PowOptions<'a> {

  #[inline]
  pub fn init_from_table(table: flatbuffers::Table<'a>) -> Self {
    PowOptions { _tab: table }
  }
  #[allow(unused_mut)]
  pub fn create<'bldr: 'args, 'args: 'mut_bldr, 'mut_bldr>(
    _fbb: &'mut_bldr mut flatbuffers::FlatBufferBuilder<'bldr>,
    _args: &'args PowOptionsArgs
  ) -> flatbuffers::WIPOffset<PowOptions<'bldr>> {
    let mut builder = PowOptionsBuilder::new(_fbb);
    builder.finish()
  }

  pub fn unpack(&self) -> PowOptionsT {
    PowOptionsT {
    }
  }
}

impl flatbuffers::Verifiable for PowOptions<'_> {
  #[inline]
  fn run_verifier(
    v: &mut flatbuffers::Verifier, pos: usize
  ) -> Result<(), flatbuffers::InvalidFlatbuffer> {
    use self::flatbuffers::Verifiable;
    v.visit_table(pos)?
     .finish();
    Ok(())
  }
}
pub struct PowOptionsArgs {
}
impl<'a> Default for PowOptionsArgs {
  #[inline]
  fn default() -> Self {
    PowOptionsArgs {
    }
  }
}

pub struct PowOptionsBuilder<'a: 'b, 'b> {
  fbb_: &'b mut flatbuffers::FlatBufferBuilder<'a>,
  start_: flatbuffers::WIPOffset<flatbuffers::TableUnfinishedWIPOffset>,
}
impl<'a: 'b, 'b> PowOptionsBuilder<'a, 'b> {
  #[inline]
  pub fn new(_fbb: &'b mut flatbuffers::FlatBufferBuilder<'a>) -> PowOptionsBuilder<'a, 'b> {
    let start = _fbb.start_table();
    PowOptionsBuilder {
      fbb_: _fbb,
      start_: start,
    }
  }
  #[inline]
  pub fn finish(self) -> flatbuffers::WIPOffset<PowOptions<'a>> {
    let o = self.fbb_.end_table(self.start_);
    flatbuffers::WIPOffset::new(o.value())
  }
}

impl core::fmt::Debug for PowOptions<'_> {
  fn fmt(&self, f: &mut core::fmt::Formatter<'_>) -> core::fmt::Result {
    let mut ds = f.debug_struct("PowOptions");
      ds.finish()
  }
}
#[non_exhaustive]
#[derive(Debug, Clone, PartialEq)]
pub struct PowOptionsT {
}
impl Default for PowOptionsT {
  fn default() -> Self {
    Self {
    }
  }
}
impl PowOptionsT {
  pub fn pack<'b>(
    &self,
    _fbb: &mut flatbuffers::FlatBufferBuilder<'b>
  ) -> flatbuffers::WIPOffset<PowOptions<'b>> {
    PowOptions::create(_fbb, &PowOptionsArgs{
    })
  }
}
pub enum FakeQuantOptionsOffset {}
#[derive(Copy, Clone, PartialEq)]

pub struct FakeQuantOptions<'a> {
  pub _tab: flatbuffers::Table<'a>,
}

impl<'a> flatbuffers::Follow<'a> for FakeQuantOptions<'a> {
  type Inner = FakeQuantOptions<'a>;
  #[inline]
  fn follow(buf: &'a [u8], loc: usize) -> Self::Inner {
    Self { _tab: flatbuffers::Table { buf, loc } }
  }
}

impl<'a> FakeQuantOptions<'a> {
  pub const VT_MIN: flatbuffers::VOffsetT = 4;
  pub const VT_MAX: flatbuffers::VOffsetT = 6;
  pub const VT_NUM_BITS: flatbuffers::VOffsetT = 8;
  pub const VT_NARROW_RANGE: flatbuffers::VOffsetT = 10;

  #[inline]
  pub fn init_from_table(table: flatbuffers::Table<'a>) -> Self {
    FakeQuantOptions { _tab: table }
  }
  #[allow(unused_mut)]
  pub fn create<'bldr: 'args, 'args: 'mut_bldr, 'mut_bldr>(
    _fbb: &'mut_bldr mut flatbuffers::FlatBufferBuilder<'bldr>,
    args: &'args FakeQuantOptionsArgs
  ) -> flatbuffers::WIPOffset<FakeQuantOptions<'bldr>> {
    let mut builder = FakeQuantOptionsBuilder::new(_fbb);
    builder.add_num_bits(args.num_bits);
    builder.add_max(args.max);
    builder.add_min(args.min);
    builder.add_narrow_range(args.narrow_range);
    builder.finish()
  }

  pub fn unpack(&self) -> FakeQuantOptionsT {
    let min = self.min();
    let max = self.max();
    let num_bits = self.num_bits();
    let narrow_range = self.narrow_range();
    FakeQuantOptionsT {
      min,
      max,
      num_bits,
      narrow_range,
    }
  }

  #[inline]
  pub fn min(&self) -> f32 {
    self._tab.get::<f32>(FakeQuantOptions::VT_MIN, Some(0.0)).unwrap()
  }
  #[inline]
  pub fn max(&self) -> f32 {
    self._tab.get::<f32>(FakeQuantOptions::VT_MAX, Some(0.0)).unwrap()
  }
  #[inline]
  pub fn num_bits(&self) -> i32 {
    self._tab.get::<i32>(FakeQuantOptions::VT_NUM_BITS, Some(0)).unwrap()
  }
  #[inline]
  pub fn narrow_range(&self) -> bool {
    self._tab.get::<bool>(FakeQuantOptions::VT_NARROW_RANGE, Some(false)).unwrap()
  }
}

impl flatbuffers::Verifiable for FakeQuantOptions<'_> {
  #[inline]
  fn run_verifier(
    v: &mut flatbuffers::Verifier, pos: usize
  ) -> Result<(), flatbuffers::InvalidFlatbuffer> {
    use self::flatbuffers::Verifiable;
    v.visit_table(pos)?
     .visit_field::<f32>("min", Self::VT_MIN, false)?
     .visit_field::<f32>("max", Self::VT_MAX, false)?
     .visit_field::<i32>("num_bits", Self::VT_NUM_BITS, false)?
     .visit_field::<bool>("narrow_range", Self::VT_NARROW_RANGE, false)?
     .finish();
    Ok(())
  }
}
pub struct FakeQuantOptionsArgs {
    pub min: f32,
    pub max: f32,
    pub num_bits: i32,
    pub narrow_range: bool,
}
impl<'a> Default for FakeQuantOptionsArgs {
  #[inline]
  fn default() -> Self {
    FakeQuantOptionsArgs {
      min: 0.0,
      max: 0.0,
      num_bits: 0,
      narrow_range: false,
    }
  }
}

pub struct FakeQuantOptionsBuilder<'a: 'b, 'b> {
  fbb_: &'b mut flatbuffers::FlatBufferBuilder<'a>,
  start_: flatbuffers::WIPOffset<flatbuffers::TableUnfinishedWIPOffset>,
}
impl<'a: 'b, 'b> FakeQuantOptionsBuilder<'a, 'b> {
  #[inline]
  pub fn add_min(&mut self, min: f32) {
    self.fbb_.push_slot::<f32>(FakeQuantOptions::VT_MIN, min, 0.0);
  }
  #[inline]
  pub fn add_max(&mut self, max: f32) {
    self.fbb_.push_slot::<f32>(FakeQuantOptions::VT_MAX, max, 0.0);
  }
  #[inline]
  pub fn add_num_bits(&mut self, num_bits: i32) {
    self.fbb_.push_slot::<i32>(FakeQuantOptions::VT_NUM_BITS, num_bits, 0);
  }
  #[inline]
  pub fn add_narrow_range(&mut self, narrow_range: bool) {
    self.fbb_.push_slot::<bool>(FakeQuantOptions::VT_NARROW_RANGE, narrow_range, false);
  }
  #[inline]
  pub fn new(_fbb: &'b mut flatbuffers::FlatBufferBuilder<'a>) -> FakeQuantOptionsBuilder<'a, 'b> {
    let start = _fbb.start_table();
    FakeQuantOptionsBuilder {
      fbb_: _fbb,
      start_: start,
    }
  }
  #[inline]
  pub fn finish(self) -> flatbuffers::WIPOffset<FakeQuantOptions<'a>> {
    let o = self.fbb_.end_table(self.start_);
    flatbuffers::WIPOffset::new(o.value())
  }
}

impl core::fmt::Debug for FakeQuantOptions<'_> {
  fn fmt(&self, f: &mut core::fmt::Formatter<'_>) -> core::fmt::Result {
    let mut ds = f.debug_struct("FakeQuantOptions");
      ds.field("min", &self.min());
      ds.field("max", &self.max());
      ds.field("num_bits", &self.num_bits());
      ds.field("narrow_range", &self.narrow_range());
      ds.finish()
  }
}
#[non_exhaustive]
#[derive(Debug, Clone, PartialEq)]
pub struct FakeQuantOptionsT {
  pub min: f32,
  pub max: f32,
  pub num_bits: i32,
  pub narrow_range: bool,
}
impl Default for FakeQuantOptionsT {
  fn default() -> Self {
    Self {
      min: 0.0,
      max: 0.0,
      num_bits: 0,
      narrow_range: false,
    }
  }
}
impl FakeQuantOptionsT {
  pub fn pack<'b>(
    &self,
    _fbb: &mut flatbuffers::FlatBufferBuilder<'b>
  ) -> flatbuffers::WIPOffset<FakeQuantOptions<'b>> {
    let min = self.min;
    let max = self.max;
    let num_bits = self.num_bits;
    let narrow_range = self.narrow_range;
    FakeQuantOptions::create(_fbb, &FakeQuantOptionsArgs{
      min,
      max,
      num_bits,
      narrow_range,
    })
  }
}
pub enum PackOptionsOffset {}
#[derive(Copy, Clone, PartialEq)]

pub struct PackOptions<'a> {
  pub _tab: flatbuffers::Table<'a>,
}

impl<'a> flatbuffers::Follow<'a> for PackOptions<'a> {
  type Inner = PackOptions<'a>;
  #[inline]
  fn follow(buf: &'a [u8], loc: usize) -> Self::Inner {
    Self { _tab: flatbuffers::Table { buf, loc } }
  }
}

impl<'a> PackOptions<'a> {
  pub const VT_VALUES_COUNT: flatbuffers::VOffsetT = 4;
  pub const VT_AXIS: flatbuffers::VOffsetT = 6;

  #[inline]
  pub fn init_from_table(table: flatbuffers::Table<'a>) -> Self {
    PackOptions { _tab: table }
  }
  #[allow(unused_mut)]
  pub fn create<'bldr: 'args, 'args: 'mut_bldr, 'mut_bldr>(
    _fbb: &'mut_bldr mut flatbuffers::FlatBufferBuilder<'bldr>,
    args: &'args PackOptionsArgs
  ) -> flatbuffers::WIPOffset<PackOptions<'bldr>> {
    let mut builder = PackOptionsBuilder::new(_fbb);
    builder.add_axis(args.axis);
    builder.add_values_count(args.values_count);
    builder.finish()
  }

  pub fn unpack(&self) -> PackOptionsT {
    let values_count = self.values_count();
    let axis = self.axis();
    PackOptionsT {
      values_count,
      axis,
    }
  }

  #[inline]
  pub fn values_count(&self) -> i32 {
    self._tab.get::<i32>(PackOptions::VT_VALUES_COUNT, Some(0)).unwrap()
  }
  #[inline]
  pub fn axis(&self) -> i32 {
    self._tab.get::<i32>(PackOptions::VT_AXIS, Some(0)).unwrap()
  }
}

impl flatbuffers::Verifiable for PackOptions<'_> {
  #[inline]
  fn run_verifier(
    v: &mut flatbuffers::Verifier, pos: usize
  ) -> Result<(), flatbuffers::InvalidFlatbuffer> {
    use self::flatbuffers::Verifiable;
    v.visit_table(pos)?
     .visit_field::<i32>("values_count", Self::VT_VALUES_COUNT, false)?
     .visit_field::<i32>("axis", Self::VT_AXIS, false)?
     .finish();
    Ok(())
  }
}
pub struct PackOptionsArgs {
    pub values_count: i32,
    pub axis: i32,
}
impl<'a> Default for PackOptionsArgs {
  #[inline]
  fn default() -> Self {
    PackOptionsArgs {
      values_count: 0,
      axis: 0,
    }
  }
}

pub struct PackOptionsBuilder<'a: 'b, 'b> {
  fbb_: &'b mut flatbuffers::FlatBufferBuilder<'a>,
  start_: flatbuffers::WIPOffset<flatbuffers::TableUnfinishedWIPOffset>,
}
impl<'a: 'b, 'b> PackOptionsBuilder<'a, 'b> {
  #[inline]
  pub fn add_values_count(&mut self, values_count: i32) {
    self.fbb_.push_slot::<i32>(PackOptions::VT_VALUES_COUNT, values_count, 0);
  }
  #[inline]
  pub fn add_axis(&mut self, axis: i32) {
    self.fbb_.push_slot::<i32>(PackOptions::VT_AXIS, axis, 0);
  }
  #[inline]
  pub fn new(_fbb: &'b mut flatbuffers::FlatBufferBuilder<'a>) -> PackOptionsBuilder<'a, 'b> {
    let start = _fbb.start_table();
    PackOptionsBuilder {
      fbb_: _fbb,
      start_: start,
    }
  }
  #[inline]
  pub fn finish(self) -> flatbuffers::WIPOffset<PackOptions<'a>> {
    let o = self.fbb_.end_table(self.start_);
    flatbuffers::WIPOffset::new(o.value())
  }
}

impl core::fmt::Debug for PackOptions<'_> {
  fn fmt(&self, f: &mut core::fmt::Formatter<'_>) -> core::fmt::Result {
    let mut ds = f.debug_struct("PackOptions");
      ds.field("values_count", &self.values_count());
      ds.field("axis", &self.axis());
      ds.finish()
  }
}
#[non_exhaustive]
#[derive(Debug, Clone, PartialEq)]
pub struct PackOptionsT {
  pub values_count: i32,
  pub axis: i32,
}
impl Default for PackOptionsT {
  fn default() -> Self {
    Self {
      values_count: 0,
      axis: 0,
    }
  }
}
impl PackOptionsT {
  pub fn pack<'b>(
    &self,
    _fbb: &mut flatbuffers::FlatBufferBuilder<'b>
  ) -> flatbuffers::WIPOffset<PackOptions<'b>> {
    let values_count = self.values_count;
    let axis = self.axis;
    PackOptions::create(_fbb, &PackOptionsArgs{
      values_count,
      axis,
    })
  }
}
pub enum LogicalOrOptionsOffset {}
#[derive(Copy, Clone, PartialEq)]

pub struct LogicalOrOptions<'a> {
  pub _tab: flatbuffers::Table<'a>,
}

impl<'a> flatbuffers::Follow<'a> for LogicalOrOptions<'a> {
  type Inner = LogicalOrOptions<'a>;
  #[inline]
  fn follow(buf: &'a [u8], loc: usize) -> Self::Inner {
    Self { _tab: flatbuffers::Table { buf, loc } }
  }
}

impl<'a> LogicalOrOptions<'a> {

  #[inline]
  pub fn init_from_table(table: flatbuffers::Table<'a>) -> Self {
    LogicalOrOptions { _tab: table }
  }
  #[allow(unused_mut)]
  pub fn create<'bldr: 'args, 'args: 'mut_bldr, 'mut_bldr>(
    _fbb: &'mut_bldr mut flatbuffers::FlatBufferBuilder<'bldr>,
    _args: &'args LogicalOrOptionsArgs
  ) -> flatbuffers::WIPOffset<LogicalOrOptions<'bldr>> {
    let mut builder = LogicalOrOptionsBuilder::new(_fbb);
    builder.finish()
  }

  pub fn unpack(&self) -> LogicalOrOptionsT {
    LogicalOrOptionsT {
    }
  }
}

impl flatbuffers::Verifiable for LogicalOrOptions<'_> {
  #[inline]
  fn run_verifier(
    v: &mut flatbuffers::Verifier, pos: usize
  ) -> Result<(), flatbuffers::InvalidFlatbuffer> {
    use self::flatbuffers::Verifiable;
    v.visit_table(pos)?
     .finish();
    Ok(())
  }
}
pub struct LogicalOrOptionsArgs {
}
impl<'a> Default for LogicalOrOptionsArgs {
  #[inline]
  fn default() -> Self {
    LogicalOrOptionsArgs {
    }
  }
}

pub struct LogicalOrOptionsBuilder<'a: 'b, 'b> {
  fbb_: &'b mut flatbuffers::FlatBufferBuilder<'a>,
  start_: flatbuffers::WIPOffset<flatbuffers::TableUnfinishedWIPOffset>,
}
impl<'a: 'b, 'b> LogicalOrOptionsBuilder<'a, 'b> {
  #[inline]
  pub fn new(_fbb: &'b mut flatbuffers::FlatBufferBuilder<'a>) -> LogicalOrOptionsBuilder<'a, 'b> {
    let start = _fbb.start_table();
    LogicalOrOptionsBuilder {
      fbb_: _fbb,
      start_: start,
    }
  }
  #[inline]
  pub fn finish(self) -> flatbuffers::WIPOffset<LogicalOrOptions<'a>> {
    let o = self.fbb_.end_table(self.start_);
    flatbuffers::WIPOffset::new(o.value())
  }
}

impl core::fmt::Debug for LogicalOrOptions<'_> {
  fn fmt(&self, f: &mut core::fmt::Formatter<'_>) -> core::fmt::Result {
    let mut ds = f.debug_struct("LogicalOrOptions");
      ds.finish()
  }
}
#[non_exhaustive]
#[derive(Debug, Clone, PartialEq)]
pub struct LogicalOrOptionsT {
}
impl Default for LogicalOrOptionsT {
  fn default() -> Self {
    Self {
    }
  }
}
impl LogicalOrOptionsT {
  pub fn pack<'b>(
    &self,
    _fbb: &mut flatbuffers::FlatBufferBuilder<'b>
  ) -> flatbuffers::WIPOffset<LogicalOrOptions<'b>> {
    LogicalOrOptions::create(_fbb, &LogicalOrOptionsArgs{
    })
  }
}
pub enum OneHotOptionsOffset {}
#[derive(Copy, Clone, PartialEq)]

pub struct OneHotOptions<'a> {
  pub _tab: flatbuffers::Table<'a>,
}

impl<'a> flatbuffers::Follow<'a> for OneHotOptions<'a> {
  type Inner = OneHotOptions<'a>;
  #[inline]
  fn follow(buf: &'a [u8], loc: usize) -> Self::Inner {
    Self { _tab: flatbuffers::Table { buf, loc } }
  }
}

impl<'a> OneHotOptions<'a> {
  pub const VT_AXIS: flatbuffers::VOffsetT = 4;

  #[inline]
  pub fn init_from_table(table: flatbuffers::Table<'a>) -> Self {
    OneHotOptions { _tab: table }
  }
  #[allow(unused_mut)]
  pub fn create<'bldr: 'args, 'args: 'mut_bldr, 'mut_bldr>(
    _fbb: &'mut_bldr mut flatbuffers::FlatBufferBuilder<'bldr>,
    args: &'args OneHotOptionsArgs
  ) -> flatbuffers::WIPOffset<OneHotOptions<'bldr>> {
    let mut builder = OneHotOptionsBuilder::new(_fbb);
    builder.add_axis(args.axis);
    builder.finish()
  }

  pub fn unpack(&self) -> OneHotOptionsT {
    let axis = self.axis();
    OneHotOptionsT {
      axis,
    }
  }

  #[inline]
  pub fn axis(&self) -> i32 {
    self._tab.get::<i32>(OneHotOptions::VT_AXIS, Some(0)).unwrap()
  }
}

impl flatbuffers::Verifiable for OneHotOptions<'_> {
  #[inline]
  fn run_verifier(
    v: &mut flatbuffers::Verifier, pos: usize
  ) -> Result<(), flatbuffers::InvalidFlatbuffer> {
    use self::flatbuffers::Verifiable;
    v.visit_table(pos)?
     .visit_field::<i32>("axis", Self::VT_AXIS, false)?
     .finish();
    Ok(())
  }
}
pub struct OneHotOptionsArgs {
    pub axis: i32,
}
impl<'a> Default for OneHotOptionsArgs {
  #[inline]
  fn default() -> Self {
    OneHotOptionsArgs {
      axis: 0,
    }
  }
}

pub struct OneHotOptionsBuilder<'a: 'b, 'b> {
  fbb_: &'b mut flatbuffers::FlatBufferBuilder<'a>,
  start_: flatbuffers::WIPOffset<flatbuffers::TableUnfinishedWIPOffset>,
}
impl<'a: 'b, 'b> OneHotOptionsBuilder<'a, 'b> {
  #[inline]
  pub fn add_axis(&mut self, axis: i32) {
    self.fbb_.push_slot::<i32>(OneHotOptions::VT_AXIS, axis, 0);
  }
  #[inline]
  pub fn new(_fbb: &'b mut flatbuffers::FlatBufferBuilder<'a>) -> OneHotOptionsBuilder<'a, 'b> {
    let start = _fbb.start_table();
    OneHotOptionsBuilder {
      fbb_: _fbb,
      start_: start,
    }
  }
  #[inline]
  pub fn finish(self) -> flatbuffers::WIPOffset<OneHotOptions<'a>> {
    let o = self.fbb_.end_table(self.start_);
    flatbuffers::WIPOffset::new(o.value())
  }
}

impl core::fmt::Debug for OneHotOptions<'_> {
  fn fmt(&self, f: &mut core::fmt::Formatter<'_>) -> core::fmt::Result {
    let mut ds = f.debug_struct("OneHotOptions");
      ds.field("axis", &self.axis());
      ds.finish()
  }
}
#[non_exhaustive]
#[derive(Debug, Clone, PartialEq)]
pub struct OneHotOptionsT {
  pub axis: i32,
}
impl Default for OneHotOptionsT {
  fn default() -> Self {
    Self {
      axis: 0,
    }
  }
}
impl OneHotOptionsT {
  pub fn pack<'b>(
    &self,
    _fbb: &mut flatbuffers::FlatBufferBuilder<'b>
  ) -> flatbuffers::WIPOffset<OneHotOptions<'b>> {
    let axis = self.axis;
    OneHotOptions::create(_fbb, &OneHotOptionsArgs{
      axis,
    })
  }
}
pub enum AbsOptionsOffset {}
#[derive(Copy, Clone, PartialEq)]

pub struct AbsOptions<'a> {
  pub _tab: flatbuffers::Table<'a>,
}

impl<'a> flatbuffers::Follow<'a> for AbsOptions<'a> {
  type Inner = AbsOptions<'a>;
  #[inline]
  fn follow(buf: &'a [u8], loc: usize) -> Self::Inner {
    Self { _tab: flatbuffers::Table { buf, loc } }
  }
}

impl<'a> AbsOptions<'a> {

  #[inline]
  pub fn init_from_table(table: flatbuffers::Table<'a>) -> Self {
    AbsOptions { _tab: table }
  }
  #[allow(unused_mut)]
  pub fn create<'bldr: 'args, 'args: 'mut_bldr, 'mut_bldr>(
    _fbb: &'mut_bldr mut flatbuffers::FlatBufferBuilder<'bldr>,
    _args: &'args AbsOptionsArgs
  ) -> flatbuffers::WIPOffset<AbsOptions<'bldr>> {
    let mut builder = AbsOptionsBuilder::new(_fbb);
    builder.finish()
  }

  pub fn unpack(&self) -> AbsOptionsT {
    AbsOptionsT {
    }
  }
}

impl flatbuffers::Verifiable for AbsOptions<'_> {
  #[inline]
  fn run_verifier(
    v: &mut flatbuffers::Verifier, pos: usize
  ) -> Result<(), flatbuffers::InvalidFlatbuffer> {
    use self::flatbuffers::Verifiable;
    v.visit_table(pos)?
     .finish();
    Ok(())
  }
}
pub struct AbsOptionsArgs {
}
impl<'a> Default for AbsOptionsArgs {
  #[inline]
  fn default() -> Self {
    AbsOptionsArgs {
    }
  }
}

pub struct AbsOptionsBuilder<'a: 'b, 'b> {
  fbb_: &'b mut flatbuffers::FlatBufferBuilder<'a>,
  start_: flatbuffers::WIPOffset<flatbuffers::TableUnfinishedWIPOffset>,
}
impl<'a: 'b, 'b> AbsOptionsBuilder<'a, 'b> {
  #[inline]
  pub fn new(_fbb: &'b mut flatbuffers::FlatBufferBuilder<'a>) -> AbsOptionsBuilder<'a, 'b> {
    let start = _fbb.start_table();
    AbsOptionsBuilder {
      fbb_: _fbb,
      start_: start,
    }
  }
  #[inline]
  pub fn finish(self) -> flatbuffers::WIPOffset<AbsOptions<'a>> {
    let o = self.fbb_.end_table(self.start_);
    flatbuffers::WIPOffset::new(o.value())
  }
}

impl core::fmt::Debug for AbsOptions<'_> {
  fn fmt(&self, f: &mut core::fmt::Formatter<'_>) -> core::fmt::Result {
    let mut ds = f.debug_struct("AbsOptions");
      ds.finish()
  }
}
#[non_exhaustive]
#[derive(Debug, Clone, PartialEq)]
pub struct AbsOptionsT {
}
impl Default for AbsOptionsT {
  fn default() -> Self {
    Self {
    }
  }
}
impl AbsOptionsT {
  pub fn pack<'b>(
    &self,
    _fbb: &mut flatbuffers::FlatBufferBuilder<'b>
  ) -> flatbuffers::WIPOffset<AbsOptions<'b>> {
    AbsOptions::create(_fbb, &AbsOptionsArgs{
    })
  }
}
pub enum HardSwishOptionsOffset {}
#[derive(Copy, Clone, PartialEq)]

pub struct HardSwishOptions<'a> {
  pub _tab: flatbuffers::Table<'a>,
}

impl<'a> flatbuffers::Follow<'a> for HardSwishOptions<'a> {
  type Inner = HardSwishOptions<'a>;
  #[inline]
  fn follow(buf: &'a [u8], loc: usize) -> Self::Inner {
    Self { _tab: flatbuffers::Table { buf, loc } }
  }
}

impl<'a> HardSwishOptions<'a> {

  #[inline]
  pub fn init_from_table(table: flatbuffers::Table<'a>) -> Self {
    HardSwishOptions { _tab: table }
  }
  #[allow(unused_mut)]
  pub fn create<'bldr: 'args, 'args: 'mut_bldr, 'mut_bldr>(
    _fbb: &'mut_bldr mut flatbuffers::FlatBufferBuilder<'bldr>,
    _args: &'args HardSwishOptionsArgs
  ) -> flatbuffers::WIPOffset<HardSwishOptions<'bldr>> {
    let mut builder = HardSwishOptionsBuilder::new(_fbb);
    builder.finish()
  }

  pub fn unpack(&self) -> HardSwishOptionsT {
    HardSwishOptionsT {
    }
  }
}

impl flatbuffers::Verifiable for HardSwishOptions<'_> {
  #[inline]
  fn run_verifier(
    v: &mut flatbuffers::Verifier, pos: usize
  ) -> Result<(), flatbuffers::InvalidFlatbuffer> {
    use self::flatbuffers::Verifiable;
    v.visit_table(pos)?
     .finish();
    Ok(())
  }
}
pub struct HardSwishOptionsArgs {
}
impl<'a> Default for HardSwishOptionsArgs {
  #[inline]
  fn default() -> Self {
    HardSwishOptionsArgs {
    }
  }
}

pub struct HardSwishOptionsBuilder<'a: 'b, 'b> {
  fbb_: &'b mut flatbuffers::FlatBufferBuilder<'a>,
  start_: flatbuffers::WIPOffset<flatbuffers::TableUnfinishedWIPOffset>,
}
impl<'a: 'b, 'b> HardSwishOptionsBuilder<'a, 'b> {
  #[inline]
  pub fn new(_fbb: &'b mut flatbuffers::FlatBufferBuilder<'a>) -> HardSwishOptionsBuilder<'a, 'b> {
    let start = _fbb.start_table();
    HardSwishOptionsBuilder {
      fbb_: _fbb,
      start_: start,
    }
  }
  #[inline]
  pub fn finish(self) -> flatbuffers::WIPOffset<HardSwishOptions<'a>> {
    let o = self.fbb_.end_table(self.start_);
    flatbuffers::WIPOffset::new(o.value())
  }
}

impl core::fmt::Debug for HardSwishOptions<'_> {
  fn fmt(&self, f: &mut core::fmt::Formatter<'_>) -> core::fmt::Result {
    let mut ds = f.debug_struct("HardSwishOptions");
      ds.finish()
  }
}
#[non_exhaustive]
#[derive(Debug, Clone, PartialEq)]
pub struct HardSwishOptionsT {
}
impl Default for HardSwishOptionsT {
  fn default() -> Self {
    Self {
    }
  }
}
impl HardSwishOptionsT {
  pub fn pack<'b>(
    &self,
    _fbb: &mut flatbuffers::FlatBufferBuilder<'b>
  ) -> flatbuffers::WIPOffset<HardSwishOptions<'b>> {
    HardSwishOptions::create(_fbb, &HardSwishOptionsArgs{
    })
  }
}
pub enum LogicalAndOptionsOffset {}
#[derive(Copy, Clone, PartialEq)]

pub struct LogicalAndOptions<'a> {
  pub _tab: flatbuffers::Table<'a>,
}

impl<'a> flatbuffers::Follow<'a> for LogicalAndOptions<'a> {
  type Inner = LogicalAndOptions<'a>;
  #[inline]
  fn follow(buf: &'a [u8], loc: usize) -> Self::Inner {
    Self { _tab: flatbuffers::Table { buf, loc } }
  }
}

impl<'a> LogicalAndOptions<'a> {

  #[inline]
  pub fn init_from_table(table: flatbuffers::Table<'a>) -> Self {
    LogicalAndOptions { _tab: table }
  }
  #[allow(unused_mut)]
  pub fn create<'bldr: 'args, 'args: 'mut_bldr, 'mut_bldr>(
    _fbb: &'mut_bldr mut flatbuffers::FlatBufferBuilder<'bldr>,
    _args: &'args LogicalAndOptionsArgs
  ) -> flatbuffers::WIPOffset<LogicalAndOptions<'bldr>> {
    let mut builder = LogicalAndOptionsBuilder::new(_fbb);
    builder.finish()
  }

  pub fn unpack(&self) -> LogicalAndOptionsT {
    LogicalAndOptionsT {
    }
  }
}

impl flatbuffers::Verifiable for LogicalAndOptions<'_> {
  #[inline]
  fn run_verifier(
    v: &mut flatbuffers::Verifier, pos: usize
  ) -> Result<(), flatbuffers::InvalidFlatbuffer> {
    use self::flatbuffers::Verifiable;
    v.visit_table(pos)?
     .finish();
    Ok(())
  }
}
pub struct LogicalAndOptionsArgs {
}
impl<'a> Default for LogicalAndOptionsArgs {
  #[inline]
  fn default() -> Self {
    LogicalAndOptionsArgs {
    }
  }
}

pub struct LogicalAndOptionsBuilder<'a: 'b, 'b> {
  fbb_: &'b mut flatbuffers::FlatBufferBuilder<'a>,
  start_: flatbuffers::WIPOffset<flatbuffers::TableUnfinishedWIPOffset>,
}
impl<'a: 'b, 'b> LogicalAndOptionsBuilder<'a, 'b> {
  #[inline]
  pub fn new(_fbb: &'b mut flatbuffers::FlatBufferBuilder<'a>) -> LogicalAndOptionsBuilder<'a, 'b> {
    let start = _fbb.start_table();
    LogicalAndOptionsBuilder {
      fbb_: _fbb,
      start_: start,
    }
  }
  #[inline]
  pub fn finish(self) -> flatbuffers::WIPOffset<LogicalAndOptions<'a>> {
    let o = self.fbb_.end_table(self.start_);
    flatbuffers::WIPOffset::new(o.value())
  }
}

impl core::fmt::Debug for LogicalAndOptions<'_> {
  fn fmt(&self, f: &mut core::fmt::Formatter<'_>) -> core::fmt::Result {
    let mut ds = f.debug_struct("LogicalAndOptions");
      ds.finish()
  }
}
#[non_exhaustive]
#[derive(Debug, Clone, PartialEq)]
pub struct LogicalAndOptionsT {
}
impl Default for LogicalAndOptionsT {
  fn default() -> Self {
    Self {
    }
  }
}
impl LogicalAndOptionsT {
  pub fn pack<'b>(
    &self,
    _fbb: &mut flatbuffers::FlatBufferBuilder<'b>
  ) -> flatbuffers::WIPOffset<LogicalAndOptions<'b>> {
    LogicalAndOptions::create(_fbb, &LogicalAndOptionsArgs{
    })
  }
}
pub enum LogicalNotOptionsOffset {}
#[derive(Copy, Clone, PartialEq)]

pub struct LogicalNotOptions<'a> {
  pub _tab: flatbuffers::Table<'a>,
}

impl<'a> flatbuffers::Follow<'a> for LogicalNotOptions<'a> {
  type Inner = LogicalNotOptions<'a>;
  #[inline]
  fn follow(buf: &'a [u8], loc: usize) -> Self::Inner {
    Self { _tab: flatbuffers::Table { buf, loc } }
  }
}

impl<'a> LogicalNotOptions<'a> {

  #[inline]
  pub fn init_from_table(table: flatbuffers::Table<'a>) -> Self {
    LogicalNotOptions { _tab: table }
  }
  #[allow(unused_mut)]
  pub fn create<'bldr: 'args, 'args: 'mut_bldr, 'mut_bldr>(
    _fbb: &'mut_bldr mut flatbuffers::FlatBufferBuilder<'bldr>,
    _args: &'args LogicalNotOptionsArgs
  ) -> flatbuffers::WIPOffset<LogicalNotOptions<'bldr>> {
    let mut builder = LogicalNotOptionsBuilder::new(_fbb);
    builder.finish()
  }

  pub fn unpack(&self) -> LogicalNotOptionsT {
    LogicalNotOptionsT {
    }
  }
}

impl flatbuffers::Verifiable for LogicalNotOptions<'_> {
  #[inline]
  fn run_verifier(
    v: &mut flatbuffers::Verifier, pos: usize
  ) -> Result<(), flatbuffers::InvalidFlatbuffer> {
    use self::flatbuffers::Verifiable;
    v.visit_table(pos)?
     .finish();
    Ok(())
  }
}
pub struct LogicalNotOptionsArgs {
}
impl<'a> Default for LogicalNotOptionsArgs {
  #[inline]
  fn default() -> Self {
    LogicalNotOptionsArgs {
    }
  }
}

pub struct LogicalNotOptionsBuilder<'a: 'b, 'b> {
  fbb_: &'b mut flatbuffers::FlatBufferBuilder<'a>,
  start_: flatbuffers::WIPOffset<flatbuffers::TableUnfinishedWIPOffset>,
}
impl<'a: 'b, 'b> LogicalNotOptionsBuilder<'a, 'b> {
  #[inline]
  pub fn new(_fbb: &'b mut flatbuffers::FlatBufferBuilder<'a>) -> LogicalNotOptionsBuilder<'a, 'b> {
    let start = _fbb.start_table();
    LogicalNotOptionsBuilder {
      fbb_: _fbb,
      start_: start,
    }
  }
  #[inline]
  pub fn finish(self) -> flatbuffers::WIPOffset<LogicalNotOptions<'a>> {
    let o = self.fbb_.end_table(self.start_);
    flatbuffers::WIPOffset::new(o.value())
  }
}

impl core::fmt::Debug for LogicalNotOptions<'_> {
  fn fmt(&self, f: &mut core::fmt::Formatter<'_>) -> core::fmt::Result {
    let mut ds = f.debug_struct("LogicalNotOptions");
      ds.finish()
  }
}
#[non_exhaustive]
#[derive(Debug, Clone, PartialEq)]
pub struct LogicalNotOptionsT {
}
impl Default for LogicalNotOptionsT {
  fn default() -> Self {
    Self {
    }
  }
}
impl LogicalNotOptionsT {
  pub fn pack<'b>(
    &self,
    _fbb: &mut flatbuffers::FlatBufferBuilder<'b>
  ) -> flatbuffers::WIPOffset<LogicalNotOptions<'b>> {
    LogicalNotOptions::create(_fbb, &LogicalNotOptionsArgs{
    })
  }
}
pub enum UnpackOptionsOffset {}
#[derive(Copy, Clone, PartialEq)]

pub struct UnpackOptions<'a> {
  pub _tab: flatbuffers::Table<'a>,
}

impl<'a> flatbuffers::Follow<'a> for UnpackOptions<'a> {
  type Inner = UnpackOptions<'a>;
  #[inline]
  fn follow(buf: &'a [u8], loc: usize) -> Self::Inner {
    Self { _tab: flatbuffers::Table { buf, loc } }
  }
}

impl<'a> UnpackOptions<'a> {
  pub const VT_NUM: flatbuffers::VOffsetT = 4;
  pub const VT_AXIS: flatbuffers::VOffsetT = 6;

  #[inline]
  pub fn init_from_table(table: flatbuffers::Table<'a>) -> Self {
    UnpackOptions { _tab: table }
  }
  #[allow(unused_mut)]
  pub fn create<'bldr: 'args, 'args: 'mut_bldr, 'mut_bldr>(
    _fbb: &'mut_bldr mut flatbuffers::FlatBufferBuilder<'bldr>,
    args: &'args UnpackOptionsArgs
  ) -> flatbuffers::WIPOffset<UnpackOptions<'bldr>> {
    let mut builder = UnpackOptionsBuilder::new(_fbb);
    builder.add_axis(args.axis);
    builder.add_num(args.num);
    builder.finish()
  }

  pub fn unpack(&self) -> UnpackOptionsT {
    let num = self.num();
    let axis = self.axis();
    UnpackOptionsT {
      num,
      axis,
    }
  }

  #[inline]
  pub fn num(&self) -> i32 {
    self._tab.get::<i32>(UnpackOptions::VT_NUM, Some(0)).unwrap()
  }
  #[inline]
  pub fn axis(&self) -> i32 {
    self._tab.get::<i32>(UnpackOptions::VT_AXIS, Some(0)).unwrap()
  }
}

impl flatbuffers::Verifiable for UnpackOptions<'_> {
  #[inline]
  fn run_verifier(
    v: &mut flatbuffers::Verifier, pos: usize
  ) -> Result<(), flatbuffers::InvalidFlatbuffer> {
    use self::flatbuffers::Verifiable;
    v.visit_table(pos)?
     .visit_field::<i32>("num", Self::VT_NUM, false)?
     .visit_field::<i32>("axis", Self::VT_AXIS, false)?
     .finish();
    Ok(())
  }
}
pub struct UnpackOptionsArgs {
    pub num: i32,
    pub axis: i32,
}
impl<'a> Default for UnpackOptionsArgs {
  #[inline]
  fn default() -> Self {
    UnpackOptionsArgs {
      num: 0,
      axis: 0,
    }
  }
}

pub struct UnpackOptionsBuilder<'a: 'b, 'b> {
  fbb_: &'b mut flatbuffers::FlatBufferBuilder<'a>,
  start_: flatbuffers::WIPOffset<flatbuffers::TableUnfinishedWIPOffset>,
}
impl<'a: 'b, 'b> UnpackOptionsBuilder<'a, 'b> {
  #[inline]
  pub fn add_num(&mut self, num: i32) {
    self.fbb_.push_slot::<i32>(UnpackOptions::VT_NUM, num, 0);
  }
  #[inline]
  pub fn add_axis(&mut self, axis: i32) {
    self.fbb_.push_slot::<i32>(UnpackOptions::VT_AXIS, axis, 0);
  }
  #[inline]
  pub fn new(_fbb: &'b mut flatbuffers::FlatBufferBuilder<'a>) -> UnpackOptionsBuilder<'a, 'b> {
    let start = _fbb.start_table();
    UnpackOptionsBuilder {
      fbb_: _fbb,
      start_: start,
    }
  }
  #[inline]
  pub fn finish(self) -> flatbuffers::WIPOffset<UnpackOptions<'a>> {
    let o = self.fbb_.end_table(self.start_);
    flatbuffers::WIPOffset::new(o.value())
  }
}

impl core::fmt::Debug for UnpackOptions<'_> {
  fn fmt(&self, f: &mut core::fmt::Formatter<'_>) -> core::fmt::Result {
    let mut ds = f.debug_struct("UnpackOptions");
      ds.field("num", &self.num());
      ds.field("axis", &self.axis());
      ds.finish()
  }
}
#[non_exhaustive]
#[derive(Debug, Clone, PartialEq)]
pub struct UnpackOptionsT {
  pub num: i32,
  pub axis: i32,
}
impl Default for UnpackOptionsT {
  fn default() -> Self {
    Self {
      num: 0,
      axis: 0,
    }
  }
}
impl UnpackOptionsT {
  pub fn pack<'b>(
    &self,
    _fbb: &mut flatbuffers::FlatBufferBuilder<'b>
  ) -> flatbuffers::WIPOffset<UnpackOptions<'b>> {
    let num = self.num;
    let axis = self.axis;
    UnpackOptions::create(_fbb, &UnpackOptionsArgs{
      num,
      axis,
    })
  }
}
pub enum FloorDivOptionsOffset {}
#[derive(Copy, Clone, PartialEq)]

pub struct FloorDivOptions<'a> {
  pub _tab: flatbuffers::Table<'a>,
}

impl<'a> flatbuffers::Follow<'a> for FloorDivOptions<'a> {
  type Inner = FloorDivOptions<'a>;
  #[inline]
  fn follow(buf: &'a [u8], loc: usize) -> Self::Inner {
    Self { _tab: flatbuffers::Table { buf, loc } }
  }
}

impl<'a> FloorDivOptions<'a> {

  #[inline]
  pub fn init_from_table(table: flatbuffers::Table<'a>) -> Self {
    FloorDivOptions { _tab: table }
  }
  #[allow(unused_mut)]
  pub fn create<'bldr: 'args, 'args: 'mut_bldr, 'mut_bldr>(
    _fbb: &'mut_bldr mut flatbuffers::FlatBufferBuilder<'bldr>,
    _args: &'args FloorDivOptionsArgs
  ) -> flatbuffers::WIPOffset<FloorDivOptions<'bldr>> {
    let mut builder = FloorDivOptionsBuilder::new(_fbb);
    builder.finish()
  }

  pub fn unpack(&self) -> FloorDivOptionsT {
    FloorDivOptionsT {
    }
  }
}

impl flatbuffers::Verifiable for FloorDivOptions<'_> {
  #[inline]
  fn run_verifier(
    v: &mut flatbuffers::Verifier, pos: usize
  ) -> Result<(), flatbuffers::InvalidFlatbuffer> {
    use self::flatbuffers::Verifiable;
    v.visit_table(pos)?
     .finish();
    Ok(())
  }
}
pub struct FloorDivOptionsArgs {
}
impl<'a> Default for FloorDivOptionsArgs {
  #[inline]
  fn default() -> Self {
    FloorDivOptionsArgs {
    }
  }
}

pub struct FloorDivOptionsBuilder<'a: 'b, 'b> {
  fbb_: &'b mut flatbuffers::FlatBufferBuilder<'a>,
  start_: flatbuffers::WIPOffset<flatbuffers::TableUnfinishedWIPOffset>,
}
impl<'a: 'b, 'b> FloorDivOptionsBuilder<'a, 'b> {
  #[inline]
  pub fn new(_fbb: &'b mut flatbuffers::FlatBufferBuilder<'a>) -> FloorDivOptionsBuilder<'a, 'b> {
    let start = _fbb.start_table();
    FloorDivOptionsBuilder {
      fbb_: _fbb,
      start_: start,
    }
  }
  #[inline]
  pub fn finish(self) -> flatbuffers::WIPOffset<FloorDivOptions<'a>> {
    let o = self.fbb_.end_table(self.start_);
    flatbuffers::WIPOffset::new(o.value())
  }
}

impl core::fmt::Debug for FloorDivOptions<'_> {
  fn fmt(&self, f: &mut core::fmt::Formatter<'_>) -> core::fmt::Result {
    let mut ds = f.debug_struct("FloorDivOptions");
      ds.finish()
  }
}
#[non_exhaustive]
#[derive(Debug, Clone, PartialEq)]
pub struct FloorDivOptionsT {
}
impl Default for FloorDivOptionsT {
  fn default() -> Self {
    Self {
    }
  }
}
impl FloorDivOptionsT {
  pub fn pack<'b>(
    &self,
    _fbb: &mut flatbuffers::FlatBufferBuilder<'b>
  ) -> flatbuffers::WIPOffset<FloorDivOptions<'b>> {
    FloorDivOptions::create(_fbb, &FloorDivOptionsArgs{
    })
  }
}
pub enum SquareOptionsOffset {}
#[derive(Copy, Clone, PartialEq)]

pub struct SquareOptions<'a> {
  pub _tab: flatbuffers::Table<'a>,
}

impl<'a> flatbuffers::Follow<'a> for SquareOptions<'a> {
  type Inner = SquareOptions<'a>;
  #[inline]
  fn follow(buf: &'a [u8], loc: usize) -> Self::Inner {
    Self { _tab: flatbuffers::Table { buf, loc } }
  }
}

impl<'a> SquareOptions<'a> {

  #[inline]
  pub fn init_from_table(table: flatbuffers::Table<'a>) -> Self {
    SquareOptions { _tab: table }
  }
  #[allow(unused_mut)]
  pub fn create<'bldr: 'args, 'args: 'mut_bldr, 'mut_bldr>(
    _fbb: &'mut_bldr mut flatbuffers::FlatBufferBuilder<'bldr>,
    _args: &'args SquareOptionsArgs
  ) -> flatbuffers::WIPOffset<SquareOptions<'bldr>> {
    let mut builder = SquareOptionsBuilder::new(_fbb);
    builder.finish()
  }

  pub fn unpack(&self) -> SquareOptionsT {
    SquareOptionsT {
    }
  }
}

impl flatbuffers::Verifiable for SquareOptions<'_> {
  #[inline]
  fn run_verifier(
    v: &mut flatbuffers::Verifier, pos: usize
  ) -> Result<(), flatbuffers::InvalidFlatbuffer> {
    use self::flatbuffers::Verifiable;
    v.visit_table(pos)?
     .finish();
    Ok(())
  }
}
pub struct SquareOptionsArgs {
}
impl<'a> Default for SquareOptionsArgs {
  #[inline]
  fn default() -> Self {
    SquareOptionsArgs {
    }
  }
}

pub struct SquareOptionsBuilder<'a: 'b, 'b> {
  fbb_: &'b mut flatbuffers::FlatBufferBuilder<'a>,
  start_: flatbuffers::WIPOffset<flatbuffers::TableUnfinishedWIPOffset>,
}
impl<'a: 'b, 'b> SquareOptionsBuilder<'a, 'b> {
  #[inline]
  pub fn new(_fbb: &'b mut flatbuffers::FlatBufferBuilder<'a>) -> SquareOptionsBuilder<'a, 'b> {
    let start = _fbb.start_table();
    SquareOptionsBuilder {
      fbb_: _fbb,
      start_: start,
    }
  }
  #[inline]
  pub fn finish(self) -> flatbuffers::WIPOffset<SquareOptions<'a>> {
    let o = self.fbb_.end_table(self.start_);
    flatbuffers::WIPOffset::new(o.value())
  }
}

impl core::fmt::Debug for SquareOptions<'_> {
  fn fmt(&self, f: &mut core::fmt::Formatter<'_>) -> core::fmt::Result {
    let mut ds = f.debug_struct("SquareOptions");
      ds.finish()
  }
}
#[non_exhaustive]
#[derive(Debug, Clone, PartialEq)]
pub struct SquareOptionsT {
}
impl Default for SquareOptionsT {
  fn default() -> Self {
    Self {
    }
  }
}
impl SquareOptionsT {
  pub fn pack<'b>(
    &self,
    _fbb: &mut flatbuffers::FlatBufferBuilder<'b>
  ) -> flatbuffers::WIPOffset<SquareOptions<'b>> {
    SquareOptions::create(_fbb, &SquareOptionsArgs{
    })
  }
}
pub enum ZerosLikeOptionsOffset {}
#[derive(Copy, Clone, PartialEq)]

pub struct ZerosLikeOptions<'a> {
  pub _tab: flatbuffers::Table<'a>,
}

impl<'a> flatbuffers::Follow<'a> for ZerosLikeOptions<'a> {
  type Inner = ZerosLikeOptions<'a>;
  #[inline]
  fn follow(buf: &'a [u8], loc: usize) -> Self::Inner {
    Self { _tab: flatbuffers::Table { buf, loc } }
  }
}

impl<'a> ZerosLikeOptions<'a> {

  #[inline]
  pub fn init_from_table(table: flatbuffers::Table<'a>) -> Self {
    ZerosLikeOptions { _tab: table }
  }
  #[allow(unused_mut)]
  pub fn create<'bldr: 'args, 'args: 'mut_bldr, 'mut_bldr>(
    _fbb: &'mut_bldr mut flatbuffers::FlatBufferBuilder<'bldr>,
    _args: &'args ZerosLikeOptionsArgs
  ) -> flatbuffers::WIPOffset<ZerosLikeOptions<'bldr>> {
    let mut builder = ZerosLikeOptionsBuilder::new(_fbb);
    builder.finish()
  }

  pub fn unpack(&self) -> ZerosLikeOptionsT {
    ZerosLikeOptionsT {
    }
  }
}

impl flatbuffers::Verifiable for ZerosLikeOptions<'_> {
  #[inline]
  fn run_verifier(
    v: &mut flatbuffers::Verifier, pos: usize
  ) -> Result<(), flatbuffers::InvalidFlatbuffer> {
    use self::flatbuffers::Verifiable;
    v.visit_table(pos)?
     .finish();
    Ok(())
  }
}
pub struct ZerosLikeOptionsArgs {
}
impl<'a> Default for ZerosLikeOptionsArgs {
  #[inline]
  fn default() -> Self {
    ZerosLikeOptionsArgs {
    }
  }
}

pub struct ZerosLikeOptionsBuilder<'a: 'b, 'b> {
  fbb_: &'b mut flatbuffers::FlatBufferBuilder<'a>,
  start_: flatbuffers::WIPOffset<flatbuffers::TableUnfinishedWIPOffset>,
}
impl<'a: 'b, 'b> ZerosLikeOptionsBuilder<'a, 'b> {
  #[inline]
  pub fn new(_fbb: &'b mut flatbuffers::FlatBufferBuilder<'a>) -> ZerosLikeOptionsBuilder<'a, 'b> {
    let start = _fbb.start_table();
    ZerosLikeOptionsBuilder {
      fbb_: _fbb,
      start_: start,
    }
  }
  #[inline]
  pub fn finish(self) -> flatbuffers::WIPOffset<ZerosLikeOptions<'a>> {
    let o = self.fbb_.end_table(self.start_);
    flatbuffers::WIPOffset::new(o.value())
  }
}

impl core::fmt::Debug for ZerosLikeOptions<'_> {
  fn fmt(&self, f: &mut core::fmt::Formatter<'_>) -> core::fmt::Result {
    let mut ds = f.debug_struct("ZerosLikeOptions");
      ds.finish()
  }
}
#[non_exhaustive]
#[derive(Debug, Clone, PartialEq)]
pub struct ZerosLikeOptionsT {
}
impl Default for ZerosLikeOptionsT {
  fn default() -> Self {
    Self {
    }
  }
}
impl ZerosLikeOptionsT {
  pub fn pack<'b>(
    &self,
    _fbb: &mut flatbuffers::FlatBufferBuilder<'b>
  ) -> flatbuffers::WIPOffset<ZerosLikeOptions<'b>> {
    ZerosLikeOptions::create(_fbb, &ZerosLikeOptionsArgs{
    })
  }
}
pub enum FillOptionsOffset {}
#[derive(Copy, Clone, PartialEq)]

pub struct FillOptions<'a> {
  pub _tab: flatbuffers::Table<'a>,
}

impl<'a> flatbuffers::Follow<'a> for FillOptions<'a> {
  type Inner = FillOptions<'a>;
  #[inline]
  fn follow(buf: &'a [u8], loc: usize) -> Self::Inner {
    Self { _tab: flatbuffers::Table { buf, loc } }
  }
}

impl<'a> FillOptions<'a> {

  #[inline]
  pub fn init_from_table(table: flatbuffers::Table<'a>) -> Self {
    FillOptions { _tab: table }
  }
  #[allow(unused_mut)]
  pub fn create<'bldr: 'args, 'args: 'mut_bldr, 'mut_bldr>(
    _fbb: &'mut_bldr mut flatbuffers::FlatBufferBuilder<'bldr>,
    _args: &'args FillOptionsArgs
  ) -> flatbuffers::WIPOffset<FillOptions<'bldr>> {
    let mut builder = FillOptionsBuilder::new(_fbb);
    builder.finish()
  }

  pub fn unpack(&self) -> FillOptionsT {
    FillOptionsT {
    }
  }
}

impl flatbuffers::Verifiable for FillOptions<'_> {
  #[inline]
  fn run_verifier(
    v: &mut flatbuffers::Verifier, pos: usize
  ) -> Result<(), flatbuffers::InvalidFlatbuffer> {
    use self::flatbuffers::Verifiable;
    v.visit_table(pos)?
     .finish();
    Ok(())
  }
}
pub struct FillOptionsArgs {
}
impl<'a> Default for FillOptionsArgs {
  #[inline]
  fn default() -> Self {
    FillOptionsArgs {
    }
  }
}

pub struct FillOptionsBuilder<'a: 'b, 'b> {
  fbb_: &'b mut flatbuffers::FlatBufferBuilder<'a>,
  start_: flatbuffers::WIPOffset<flatbuffers::TableUnfinishedWIPOffset>,
}
impl<'a: 'b, 'b> FillOptionsBuilder<'a, 'b> {
  #[inline]
  pub fn new(_fbb: &'b mut flatbuffers::FlatBufferBuilder<'a>) -> FillOptionsBuilder<'a, 'b> {
    let start = _fbb.start_table();
    FillOptionsBuilder {
      fbb_: _fbb,
      start_: start,
    }
  }
  #[inline]
  pub fn finish(self) -> flatbuffers::WIPOffset<FillOptions<'a>> {
    let o = self.fbb_.end_table(self.start_);
    flatbuffers::WIPOffset::new(o.value())
  }
}

impl core::fmt::Debug for FillOptions<'_> {
  fn fmt(&self, f: &mut core::fmt::Formatter<'_>) -> core::fmt::Result {
    let mut ds = f.debug_struct("FillOptions");
      ds.finish()
  }
}
#[non_exhaustive]
#[derive(Debug, Clone, PartialEq)]
pub struct FillOptionsT {
}
impl Default for FillOptionsT {
  fn default() -> Self {
    Self {
    }
  }
}
impl FillOptionsT {
  pub fn pack<'b>(
    &self,
    _fbb: &mut flatbuffers::FlatBufferBuilder<'b>
  ) -> flatbuffers::WIPOffset<FillOptions<'b>> {
    FillOptions::create(_fbb, &FillOptionsArgs{
    })
  }
}
pub enum FloorModOptionsOffset {}
#[derive(Copy, Clone, PartialEq)]

pub struct FloorModOptions<'a> {
  pub _tab: flatbuffers::Table<'a>,
}

impl<'a> flatbuffers::Follow<'a> for FloorModOptions<'a> {
  type Inner = FloorModOptions<'a>;
  #[inline]
  fn follow(buf: &'a [u8], loc: usize) -> Self::Inner {
    Self { _tab: flatbuffers::Table { buf, loc } }
  }
}

impl<'a> FloorModOptions<'a> {

  #[inline]
  pub fn init_from_table(table: flatbuffers::Table<'a>) -> Self {
    FloorModOptions { _tab: table }
  }
  #[allow(unused_mut)]
  pub fn create<'bldr: 'args, 'args: 'mut_bldr, 'mut_bldr>(
    _fbb: &'mut_bldr mut flatbuffers::FlatBufferBuilder<'bldr>,
    _args: &'args FloorModOptionsArgs
  ) -> flatbuffers::WIPOffset<FloorModOptions<'bldr>> {
    let mut builder = FloorModOptionsBuilder::new(_fbb);
    builder.finish()
  }

  pub fn unpack(&self) -> FloorModOptionsT {
    FloorModOptionsT {
    }
  }
}

impl flatbuffers::Verifiable for FloorModOptions<'_> {
  #[inline]
  fn run_verifier(
    v: &mut flatbuffers::Verifier, pos: usize
  ) -> Result<(), flatbuffers::InvalidFlatbuffer> {
    use self::flatbuffers::Verifiable;
    v.visit_table(pos)?
     .finish();
    Ok(())
  }
}
pub struct FloorModOptionsArgs {
}
impl<'a> Default for FloorModOptionsArgs {
  #[inline]
  fn default() -> Self {
    FloorModOptionsArgs {
    }
  }
}

pub struct FloorModOptionsBuilder<'a: 'b, 'b> {
  fbb_: &'b mut flatbuffers::FlatBufferBuilder<'a>,
  start_: flatbuffers::WIPOffset<flatbuffers::TableUnfinishedWIPOffset>,
}
impl<'a: 'b, 'b> FloorModOptionsBuilder<'a, 'b> {
  #[inline]
  pub fn new(_fbb: &'b mut flatbuffers::FlatBufferBuilder<'a>) -> FloorModOptionsBuilder<'a, 'b> {
    let start = _fbb.start_table();
    FloorModOptionsBuilder {
      fbb_: _fbb,
      start_: start,
    }
  }
  #[inline]
  pub fn finish(self) -> flatbuffers::WIPOffset<FloorModOptions<'a>> {
    let o = self.fbb_.end_table(self.start_);
    flatbuffers::WIPOffset::new(o.value())
  }
}

impl core::fmt::Debug for FloorModOptions<'_> {
  fn fmt(&self, f: &mut core::fmt::Formatter<'_>) -> core::fmt::Result {
    let mut ds = f.debug_struct("FloorModOptions");
      ds.finish()
  }
}
#[non_exhaustive]
#[derive(Debug, Clone, PartialEq)]
pub struct FloorModOptionsT {
}
impl Default for FloorModOptionsT {
  fn default() -> Self {
    Self {
    }
  }
}
impl FloorModOptionsT {
  pub fn pack<'b>(
    &self,
    _fbb: &mut flatbuffers::FlatBufferBuilder<'b>
  ) -> flatbuffers::WIPOffset<FloorModOptions<'b>> {
    FloorModOptions::create(_fbb, &FloorModOptionsArgs{
    })
  }
}
pub enum RangeOptionsOffset {}
#[derive(Copy, Clone, PartialEq)]

pub struct RangeOptions<'a> {
  pub _tab: flatbuffers::Table<'a>,
}

impl<'a> flatbuffers::Follow<'a> for RangeOptions<'a> {
  type Inner = RangeOptions<'a>;
  #[inline]
  fn follow(buf: &'a [u8], loc: usize) -> Self::Inner {
    Self { _tab: flatbuffers::Table { buf, loc } }
  }
}

impl<'a> RangeOptions<'a> {

  #[inline]
  pub fn init_from_table(table: flatbuffers::Table<'a>) -> Self {
    RangeOptions { _tab: table }
  }
  #[allow(unused_mut)]
  pub fn create<'bldr: 'args, 'args: 'mut_bldr, 'mut_bldr>(
    _fbb: &'mut_bldr mut flatbuffers::FlatBufferBuilder<'bldr>,
    _args: &'args RangeOptionsArgs
  ) -> flatbuffers::WIPOffset<RangeOptions<'bldr>> {
    let mut builder = RangeOptionsBuilder::new(_fbb);
    builder.finish()
  }

  pub fn unpack(&self) -> RangeOptionsT {
    RangeOptionsT {
    }
  }
}

impl flatbuffers::Verifiable for RangeOptions<'_> {
  #[inline]
  fn run_verifier(
    v: &mut flatbuffers::Verifier, pos: usize
  ) -> Result<(), flatbuffers::InvalidFlatbuffer> {
    use self::flatbuffers::Verifiable;
    v.visit_table(pos)?
     .finish();
    Ok(())
  }
}
pub struct RangeOptionsArgs {
}
impl<'a> Default for RangeOptionsArgs {
  #[inline]
  fn default() -> Self {
    RangeOptionsArgs {
    }
  }
}

pub struct RangeOptionsBuilder<'a: 'b, 'b> {
  fbb_: &'b mut flatbuffers::FlatBufferBuilder<'a>,
  start_: flatbuffers::WIPOffset<flatbuffers::TableUnfinishedWIPOffset>,
}
impl<'a: 'b, 'b> RangeOptionsBuilder<'a, 'b> {
  #[inline]
  pub fn new(_fbb: &'b mut flatbuffers::FlatBufferBuilder<'a>) -> RangeOptionsBuilder<'a, 'b> {
    let start = _fbb.start_table();
    RangeOptionsBuilder {
      fbb_: _fbb,
      start_: start,
    }
  }
  #[inline]
  pub fn finish(self) -> flatbuffers::WIPOffset<RangeOptions<'a>> {
    let o = self.fbb_.end_table(self.start_);
    flatbuffers::WIPOffset::new(o.value())
  }
}

impl core::fmt::Debug for RangeOptions<'_> {
  fn fmt(&self, f: &mut core::fmt::Formatter<'_>) -> core::fmt::Result {
    let mut ds = f.debug_struct("RangeOptions");
      ds.finish()
  }
}
#[non_exhaustive]
#[derive(Debug, Clone, PartialEq)]
pub struct RangeOptionsT {
}
impl Default for RangeOptionsT {
  fn default() -> Self {
    Self {
    }
  }
}
impl RangeOptionsT {
  pub fn pack<'b>(
    &self,
    _fbb: &mut flatbuffers::FlatBufferBuilder<'b>
  ) -> flatbuffers::WIPOffset<RangeOptions<'b>> {
    RangeOptions::create(_fbb, &RangeOptionsArgs{
    })
  }
}
pub enum LeakyReluOptionsOffset {}
#[derive(Copy, Clone, PartialEq)]

pub struct LeakyReluOptions<'a> {
  pub _tab: flatbuffers::Table<'a>,
}

impl<'a> flatbuffers::Follow<'a> for LeakyReluOptions<'a> {
  type Inner = LeakyReluOptions<'a>;
  #[inline]
  fn follow(buf: &'a [u8], loc: usize) -> Self::Inner {
    Self { _tab: flatbuffers::Table { buf, loc } }
  }
}

impl<'a> LeakyReluOptions<'a> {
  pub const VT_ALPHA: flatbuffers::VOffsetT = 4;

  #[inline]
  pub fn init_from_table(table: flatbuffers::Table<'a>) -> Self {
    LeakyReluOptions { _tab: table }
  }
  #[allow(unused_mut)]
  pub fn create<'bldr: 'args, 'args: 'mut_bldr, 'mut_bldr>(
    _fbb: &'mut_bldr mut flatbuffers::FlatBufferBuilder<'bldr>,
    args: &'args LeakyReluOptionsArgs
  ) -> flatbuffers::WIPOffset<LeakyReluOptions<'bldr>> {
    let mut builder = LeakyReluOptionsBuilder::new(_fbb);
    builder.add_alpha(args.alpha);
    builder.finish()
  }

  pub fn unpack(&self) -> LeakyReluOptionsT {
    let alpha = self.alpha();
    LeakyReluOptionsT {
      alpha,
    }
  }

  #[inline]
  pub fn alpha(&self) -> f32 {
    self._tab.get::<f32>(LeakyReluOptions::VT_ALPHA, Some(0.0)).unwrap()
  }
}

impl flatbuffers::Verifiable for LeakyReluOptions<'_> {
  #[inline]
  fn run_verifier(
    v: &mut flatbuffers::Verifier, pos: usize
  ) -> Result<(), flatbuffers::InvalidFlatbuffer> {
    use self::flatbuffers::Verifiable;
    v.visit_table(pos)?
     .visit_field::<f32>("alpha", Self::VT_ALPHA, false)?
     .finish();
    Ok(())
  }
}
pub struct LeakyReluOptionsArgs {
    pub alpha: f32,
}
impl<'a> Default for LeakyReluOptionsArgs {
  #[inline]
  fn default() -> Self {
    LeakyReluOptionsArgs {
      alpha: 0.0,
    }
  }
}

pub struct LeakyReluOptionsBuilder<'a: 'b, 'b> {
  fbb_: &'b mut flatbuffers::FlatBufferBuilder<'a>,
  start_: flatbuffers::WIPOffset<flatbuffers::TableUnfinishedWIPOffset>,
}
impl<'a: 'b, 'b> LeakyReluOptionsBuilder<'a, 'b> {
  #[inline]
  pub fn add_alpha(&mut self, alpha: f32) {
    self.fbb_.push_slot::<f32>(LeakyReluOptions::VT_ALPHA, alpha, 0.0);
  }
  #[inline]
  pub fn new(_fbb: &'b mut flatbuffers::FlatBufferBuilder<'a>) -> LeakyReluOptionsBuilder<'a, 'b> {
    let start = _fbb.start_table();
    LeakyReluOptionsBuilder {
      fbb_: _fbb,
      start_: start,
    }
  }
  #[inline]
  pub fn finish(self) -> flatbuffers::WIPOffset<LeakyReluOptions<'a>> {
    let o = self.fbb_.end_table(self.start_);
    flatbuffers::WIPOffset::new(o.value())
  }
}

impl core::fmt::Debug for LeakyReluOptions<'_> {
  fn fmt(&self, f: &mut core::fmt::Formatter<'_>) -> core::fmt::Result {
    let mut ds = f.debug_struct("LeakyReluOptions");
      ds.field("alpha", &self.alpha());
      ds.finish()
  }
}
#[non_exhaustive]
#[derive(Debug, Clone, PartialEq)]
pub struct LeakyReluOptionsT {
  pub alpha: f32,
}
impl Default for LeakyReluOptionsT {
  fn default() -> Self {
    Self {
      alpha: 0.0,
    }
  }
}
impl LeakyReluOptionsT {
  pub fn pack<'b>(
    &self,
    _fbb: &mut flatbuffers::FlatBufferBuilder<'b>
  ) -> flatbuffers::WIPOffset<LeakyReluOptions<'b>> {
    let alpha = self.alpha;
    LeakyReluOptions::create(_fbb, &LeakyReluOptionsArgs{
      alpha,
    })
  }
}
pub enum SquaredDifferenceOptionsOffset {}
#[derive(Copy, Clone, PartialEq)]

pub struct SquaredDifferenceOptions<'a> {
  pub _tab: flatbuffers::Table<'a>,
}

impl<'a> flatbuffers::Follow<'a> for SquaredDifferenceOptions<'a> {
  type Inner = SquaredDifferenceOptions<'a>;
  #[inline]
  fn follow(buf: &'a [u8], loc: usize) -> Self::Inner {
    Self { _tab: flatbuffers::Table { buf, loc } }
  }
}

impl<'a> SquaredDifferenceOptions<'a> {

  #[inline]
  pub fn init_from_table(table: flatbuffers::Table<'a>) -> Self {
    SquaredDifferenceOptions { _tab: table }
  }
  #[allow(unused_mut)]
  pub fn create<'bldr: 'args, 'args: 'mut_bldr, 'mut_bldr>(
    _fbb: &'mut_bldr mut flatbuffers::FlatBufferBuilder<'bldr>,
    _args: &'args SquaredDifferenceOptionsArgs
  ) -> flatbuffers::WIPOffset<SquaredDifferenceOptions<'bldr>> {
    let mut builder = SquaredDifferenceOptionsBuilder::new(_fbb);
    builder.finish()
  }

  pub fn unpack(&self) -> SquaredDifferenceOptionsT {
    SquaredDifferenceOptionsT {
    }
  }
}

impl flatbuffers::Verifiable for SquaredDifferenceOptions<'_> {
  #[inline]
  fn run_verifier(
    v: &mut flatbuffers::Verifier, pos: usize
  ) -> Result<(), flatbuffers::InvalidFlatbuffer> {
    use self::flatbuffers::Verifiable;
    v.visit_table(pos)?
     .finish();
    Ok(())
  }
}
pub struct SquaredDifferenceOptionsArgs {
}
impl<'a> Default for SquaredDifferenceOptionsArgs {
  #[inline]
  fn default() -> Self {
    SquaredDifferenceOptionsArgs {
    }
  }
}

pub struct SquaredDifferenceOptionsBuilder<'a: 'b, 'b> {
  fbb_: &'b mut flatbuffers::FlatBufferBuilder<'a>,
  start_: flatbuffers::WIPOffset<flatbuffers::TableUnfinishedWIPOffset>,
}
impl<'a: 'b, 'b> SquaredDifferenceOptionsBuilder<'a, 'b> {
  #[inline]
  pub fn new(_fbb: &'b mut flatbuffers::FlatBufferBuilder<'a>) -> SquaredDifferenceOptionsBuilder<'a, 'b> {
    let start = _fbb.start_table();
    SquaredDifferenceOptionsBuilder {
      fbb_: _fbb,
      start_: start,
    }
  }
  #[inline]
  pub fn finish(self) -> flatbuffers::WIPOffset<SquaredDifferenceOptions<'a>> {
    let o = self.fbb_.end_table(self.start_);
    flatbuffers::WIPOffset::new(o.value())
  }
}

impl core::fmt::Debug for SquaredDifferenceOptions<'_> {
  fn fmt(&self, f: &mut core::fmt::Formatter<'_>) -> core::fmt::Result {
    let mut ds = f.debug_struct("SquaredDifferenceOptions");
      ds.finish()
  }
}
#[non_exhaustive]
#[derive(Debug, Clone, PartialEq)]
pub struct SquaredDifferenceOptionsT {
}
impl Default for SquaredDifferenceOptionsT {
  fn default() -> Self {
    Self {
    }
  }
}
impl SquaredDifferenceOptionsT {
  pub fn pack<'b>(
    &self,
    _fbb: &mut flatbuffers::FlatBufferBuilder<'b>
  ) -> flatbuffers::WIPOffset<SquaredDifferenceOptions<'b>> {
    SquaredDifferenceOptions::create(_fbb, &SquaredDifferenceOptionsArgs{
    })
  }
}
pub enum MirrorPadOptionsOffset {}
#[derive(Copy, Clone, PartialEq)]

pub struct MirrorPadOptions<'a> {
  pub _tab: flatbuffers::Table<'a>,
}

impl<'a> flatbuffers::Follow<'a> for MirrorPadOptions<'a> {
  type Inner = MirrorPadOptions<'a>;
  #[inline]
  fn follow(buf: &'a [u8], loc: usize) -> Self::Inner {
    Self { _tab: flatbuffers::Table { buf, loc } }
  }
}

impl<'a> MirrorPadOptions<'a> {
  pub const VT_MODE: flatbuffers::VOffsetT = 4;

  #[inline]
  pub fn init_from_table(table: flatbuffers::Table<'a>) -> Self {
    MirrorPadOptions { _tab: table }
  }
  #[allow(unused_mut)]
  pub fn create<'bldr: 'args, 'args: 'mut_bldr, 'mut_bldr>(
    _fbb: &'mut_bldr mut flatbuffers::FlatBufferBuilder<'bldr>,
    args: &'args MirrorPadOptionsArgs
  ) -> flatbuffers::WIPOffset<MirrorPadOptions<'bldr>> {
    let mut builder = MirrorPadOptionsBuilder::new(_fbb);
    builder.add_mode(args.mode);
    builder.finish()
  }

  pub fn unpack(&self) -> MirrorPadOptionsT {
    let mode = self.mode();
    MirrorPadOptionsT {
      mode,
    }
  }

  #[inline]
  pub fn mode(&self) -> MirrorPadMode {
    self._tab.get::<MirrorPadMode>(MirrorPadOptions::VT_MODE, Some(MirrorPadMode::REFLECT)).unwrap()
  }
}

impl flatbuffers::Verifiable for MirrorPadOptions<'_> {
  #[inline]
  fn run_verifier(
    v: &mut flatbuffers::Verifier, pos: usize
  ) -> Result<(), flatbuffers::InvalidFlatbuffer> {
    use self::flatbuffers::Verifiable;
    v.visit_table(pos)?
     .visit_field::<MirrorPadMode>("mode", Self::VT_MODE, false)?
     .finish();
    Ok(())
  }
}
pub struct MirrorPadOptionsArgs {
    pub mode: MirrorPadMode,
}
impl<'a> Default for MirrorPadOptionsArgs {
  #[inline]
  fn default() -> Self {
    MirrorPadOptionsArgs {
      mode: MirrorPadMode::REFLECT,
    }
  }
}

pub struct MirrorPadOptionsBuilder<'a: 'b, 'b> {
  fbb_: &'b mut flatbuffers::FlatBufferBuilder<'a>,
  start_: flatbuffers::WIPOffset<flatbuffers::TableUnfinishedWIPOffset>,
}
impl<'a: 'b, 'b> MirrorPadOptionsBuilder<'a, 'b> {
  #[inline]
  pub fn add_mode(&mut self, mode: MirrorPadMode) {
    self.fbb_.push_slot::<MirrorPadMode>(MirrorPadOptions::VT_MODE, mode, MirrorPadMode::REFLECT);
  }
  #[inline]
  pub fn new(_fbb: &'b mut flatbuffers::FlatBufferBuilder<'a>) -> MirrorPadOptionsBuilder<'a, 'b> {
    let start = _fbb.start_table();
    MirrorPadOptionsBuilder {
      fbb_: _fbb,
      start_: start,
    }
  }
  #[inline]
  pub fn finish(self) -> flatbuffers::WIPOffset<MirrorPadOptions<'a>> {
    let o = self.fbb_.end_table(self.start_);
    flatbuffers::WIPOffset::new(o.value())
  }
}

impl core::fmt::Debug for MirrorPadOptions<'_> {
  fn fmt(&self, f: &mut core::fmt::Formatter<'_>) -> core::fmt::Result {
    let mut ds = f.debug_struct("MirrorPadOptions");
      ds.field("mode", &self.mode());
      ds.finish()
  }
}
#[non_exhaustive]
#[derive(Debug, Clone, PartialEq)]
pub struct MirrorPadOptionsT {
  pub mode: MirrorPadMode,
}
impl Default for MirrorPadOptionsT {
  fn default() -> Self {
    Self {
      mode: MirrorPadMode::REFLECT,
    }
  }
}
impl MirrorPadOptionsT {
  pub fn pack<'b>(
    &self,
    _fbb: &mut flatbuffers::FlatBufferBuilder<'b>
  ) -> flatbuffers::WIPOffset<MirrorPadOptions<'b>> {
    let mode = self.mode;
    MirrorPadOptions::create(_fbb, &MirrorPadOptionsArgs{
      mode,
    })
  }
}
pub enum UniqueOptionsOffset {}
#[derive(Copy, Clone, PartialEq)]

pub struct UniqueOptions<'a> {
  pub _tab: flatbuffers::Table<'a>,
}

impl<'a> flatbuffers::Follow<'a> for UniqueOptions<'a> {
  type Inner = UniqueOptions<'a>;
  #[inline]
  fn follow(buf: &'a [u8], loc: usize) -> Self::Inner {
    Self { _tab: flatbuffers::Table { buf, loc } }
  }
}

impl<'a> UniqueOptions<'a> {
  pub const VT_IDX_OUT_TYPE: flatbuffers::VOffsetT = 4;

  #[inline]
  pub fn init_from_table(table: flatbuffers::Table<'a>) -> Self {
    UniqueOptions { _tab: table }
  }
  #[allow(unused_mut)]
  pub fn create<'bldr: 'args, 'args: 'mut_bldr, 'mut_bldr>(
    _fbb: &'mut_bldr mut flatbuffers::FlatBufferBuilder<'bldr>,
    args: &'args UniqueOptionsArgs
  ) -> flatbuffers::WIPOffset<UniqueOptions<'bldr>> {
    let mut builder = UniqueOptionsBuilder::new(_fbb);
    builder.add_idx_out_type(args.idx_out_type);
    builder.finish()
  }

  pub fn unpack(&self) -> UniqueOptionsT {
    let idx_out_type = self.idx_out_type();
    UniqueOptionsT {
      idx_out_type,
    }
  }

  #[inline]
  pub fn idx_out_type(&self) -> TensorType {
    self._tab.get::<TensorType>(UniqueOptions::VT_IDX_OUT_TYPE, Some(TensorType::INT32)).unwrap()
  }
}

impl flatbuffers::Verifiable for UniqueOptions<'_> {
  #[inline]
  fn run_verifier(
    v: &mut flatbuffers::Verifier, pos: usize
  ) -> Result<(), flatbuffers::InvalidFlatbuffer> {
    use self::flatbuffers::Verifiable;
    v.visit_table(pos)?
     .visit_field::<TensorType>("idx_out_type", Self::VT_IDX_OUT_TYPE, false)?
     .finish();
    Ok(())
  }
}
pub struct UniqueOptionsArgs {
    pub idx_out_type: TensorType,
}
impl<'a> Default for UniqueOptionsArgs {
  #[inline]
  fn default() -> Self {
    UniqueOptionsArgs {
      idx_out_type: TensorType::INT32,
    }
  }
}

pub struct UniqueOptionsBuilder<'a: 'b, 'b> {
  fbb_: &'b mut flatbuffers::FlatBufferBuilder<'a>,
  start_: flatbuffers::WIPOffset<flatbuffers::TableUnfinishedWIPOffset>,
}
impl<'a: 'b, 'b> UniqueOptionsBuilder<'a, 'b> {
  #[inline]
  pub fn add_idx_out_type(&mut self, idx_out_type: TensorType) {
    self.fbb_.push_slot::<TensorType>(UniqueOptions::VT_IDX_OUT_TYPE, idx_out_type, TensorType::INT32);
  }
  #[inline]
  pub fn new(_fbb: &'b mut flatbuffers::FlatBufferBuilder<'a>) -> UniqueOptionsBuilder<'a, 'b> {
    let start = _fbb.start_table();
    UniqueOptionsBuilder {
      fbb_: _fbb,
      start_: start,
    }
  }
  #[inline]
  pub fn finish(self) -> flatbuffers::WIPOffset<UniqueOptions<'a>> {
    let o = self.fbb_.end_table(self.start_);
    flatbuffers::WIPOffset::new(o.value())
  }
}

impl core::fmt::Debug for UniqueOptions<'_> {
  fn fmt(&self, f: &mut core::fmt::Formatter<'_>) -> core::fmt::Result {
    let mut ds = f.debug_struct("UniqueOptions");
      ds.field("idx_out_type", &self.idx_out_type());
      ds.finish()
  }
}
#[non_exhaustive]
#[derive(Debug, Clone, PartialEq)]
pub struct UniqueOptionsT {
  pub idx_out_type: TensorType,
}
impl Default for UniqueOptionsT {
  fn default() -> Self {
    Self {
      idx_out_type: TensorType::INT32,
    }
  }
}
impl UniqueOptionsT {
  pub fn pack<'b>(
    &self,
    _fbb: &mut flatbuffers::FlatBufferBuilder<'b>
  ) -> flatbuffers::WIPOffset<UniqueOptions<'b>> {
    let idx_out_type = self.idx_out_type;
    UniqueOptions::create(_fbb, &UniqueOptionsArgs{
      idx_out_type,
    })
  }
}
pub enum ReverseV2OptionsOffset {}
#[derive(Copy, Clone, PartialEq)]

pub struct ReverseV2Options<'a> {
  pub _tab: flatbuffers::Table<'a>,
}

impl<'a> flatbuffers::Follow<'a> for ReverseV2Options<'a> {
  type Inner = ReverseV2Options<'a>;
  #[inline]
  fn follow(buf: &'a [u8], loc: usize) -> Self::Inner {
    Self { _tab: flatbuffers::Table { buf, loc } }
  }
}

impl<'a> ReverseV2Options<'a> {

  #[inline]
  pub fn init_from_table(table: flatbuffers::Table<'a>) -> Self {
    ReverseV2Options { _tab: table }
  }
  #[allow(unused_mut)]
  pub fn create<'bldr: 'args, 'args: 'mut_bldr, 'mut_bldr>(
    _fbb: &'mut_bldr mut flatbuffers::FlatBufferBuilder<'bldr>,
    _args: &'args ReverseV2OptionsArgs
  ) -> flatbuffers::WIPOffset<ReverseV2Options<'bldr>> {
    let mut builder = ReverseV2OptionsBuilder::new(_fbb);
    builder.finish()
  }

  pub fn unpack(&self) -> ReverseV2OptionsT {
    ReverseV2OptionsT {
    }
  }
}

impl flatbuffers::Verifiable for ReverseV2Options<'_> {
  #[inline]
  fn run_verifier(
    v: &mut flatbuffers::Verifier, pos: usize
  ) -> Result<(), flatbuffers::InvalidFlatbuffer> {
    use self::flatbuffers::Verifiable;
    v.visit_table(pos)?
     .finish();
    Ok(())
  }
}
pub struct ReverseV2OptionsArgs {
}
impl<'a> Default for ReverseV2OptionsArgs {
  #[inline]
  fn default() -> Self {
    ReverseV2OptionsArgs {
    }
  }
}

pub struct ReverseV2OptionsBuilder<'a: 'b, 'b> {
  fbb_: &'b mut flatbuffers::FlatBufferBuilder<'a>,
  start_: flatbuffers::WIPOffset<flatbuffers::TableUnfinishedWIPOffset>,
}
impl<'a: 'b, 'b> ReverseV2OptionsBuilder<'a, 'b> {
  #[inline]
  pub fn new(_fbb: &'b mut flatbuffers::FlatBufferBuilder<'a>) -> ReverseV2OptionsBuilder<'a, 'b> {
    let start = _fbb.start_table();
    ReverseV2OptionsBuilder {
      fbb_: _fbb,
      start_: start,
    }
  }
  #[inline]
  pub fn finish(self) -> flatbuffers::WIPOffset<ReverseV2Options<'a>> {
    let o = self.fbb_.end_table(self.start_);
    flatbuffers::WIPOffset::new(o.value())
  }
}

impl core::fmt::Debug for ReverseV2Options<'_> {
  fn fmt(&self, f: &mut core::fmt::Formatter<'_>) -> core::fmt::Result {
    let mut ds = f.debug_struct("ReverseV2Options");
      ds.finish()
  }
}
#[non_exhaustive]
#[derive(Debug, Clone, PartialEq)]
pub struct ReverseV2OptionsT {
}
impl Default for ReverseV2OptionsT {
  fn default() -> Self {
    Self {
    }
  }
}
impl ReverseV2OptionsT {
  pub fn pack<'b>(
    &self,
    _fbb: &mut flatbuffers::FlatBufferBuilder<'b>
  ) -> flatbuffers::WIPOffset<ReverseV2Options<'b>> {
    ReverseV2Options::create(_fbb, &ReverseV2OptionsArgs{
    })
  }
}
pub enum AddNOptionsOffset {}
#[derive(Copy, Clone, PartialEq)]

pub struct AddNOptions<'a> {
  pub _tab: flatbuffers::Table<'a>,
}

impl<'a> flatbuffers::Follow<'a> for AddNOptions<'a> {
  type Inner = AddNOptions<'a>;
  #[inline]
  fn follow(buf: &'a [u8], loc: usize) -> Self::Inner {
    Self { _tab: flatbuffers::Table { buf, loc } }
  }
}

impl<'a> AddNOptions<'a> {

  #[inline]
  pub fn init_from_table(table: flatbuffers::Table<'a>) -> Self {
    AddNOptions { _tab: table }
  }
  #[allow(unused_mut)]
  pub fn create<'bldr: 'args, 'args: 'mut_bldr, 'mut_bldr>(
    _fbb: &'mut_bldr mut flatbuffers::FlatBufferBuilder<'bldr>,
    _args: &'args AddNOptionsArgs
  ) -> flatbuffers::WIPOffset<AddNOptions<'bldr>> {
    let mut builder = AddNOptionsBuilder::new(_fbb);
    builder.finish()
  }

  pub fn unpack(&self) -> AddNOptionsT {
    AddNOptionsT {
    }
  }
}

impl flatbuffers::Verifiable for AddNOptions<'_> {
  #[inline]
  fn run_verifier(
    v: &mut flatbuffers::Verifier, pos: usize
  ) -> Result<(), flatbuffers::InvalidFlatbuffer> {
    use self::flatbuffers::Verifiable;
    v.visit_table(pos)?
     .finish();
    Ok(())
  }
}
pub struct AddNOptionsArgs {
}
impl<'a> Default for AddNOptionsArgs {
  #[inline]
  fn default() -> Self {
    AddNOptionsArgs {
    }
  }
}

pub struct AddNOptionsBuilder<'a: 'b, 'b> {
  fbb_: &'b mut flatbuffers::FlatBufferBuilder<'a>,
  start_: flatbuffers::WIPOffset<flatbuffers::TableUnfinishedWIPOffset>,
}
impl<'a: 'b, 'b> AddNOptionsBuilder<'a, 'b> {
  #[inline]
  pub fn new(_fbb: &'b mut flatbuffers::FlatBufferBuilder<'a>) -> AddNOptionsBuilder<'a, 'b> {
    let start = _fbb.start_table();
    AddNOptionsBuilder {
      fbb_: _fbb,
      start_: start,
    }
  }
  #[inline]
  pub fn finish(self) -> flatbuffers::WIPOffset<AddNOptions<'a>> {
    let o = self.fbb_.end_table(self.start_);
    flatbuffers::WIPOffset::new(o.value())
  }
}

impl core::fmt::Debug for AddNOptions<'_> {
  fn fmt(&self, f: &mut core::fmt::Formatter<'_>) -> core::fmt::Result {
    let mut ds = f.debug_struct("AddNOptions");
      ds.finish()
  }
}
#[non_exhaustive]
#[derive(Debug, Clone, PartialEq)]
pub struct AddNOptionsT {
}
impl Default for AddNOptionsT {
  fn default() -> Self {
    Self {
    }
  }
}
impl AddNOptionsT {
  pub fn pack<'b>(
    &self,
    _fbb: &mut flatbuffers::FlatBufferBuilder<'b>
  ) -> flatbuffers::WIPOffset<AddNOptions<'b>> {
    AddNOptions::create(_fbb, &AddNOptionsArgs{
    })
  }
}
pub enum GatherNdOptionsOffset {}
#[derive(Copy, Clone, PartialEq)]

pub struct GatherNdOptions<'a> {
  pub _tab: flatbuffers::Table<'a>,
}

impl<'a> flatbuffers::Follow<'a> for GatherNdOptions<'a> {
  type Inner = GatherNdOptions<'a>;
  #[inline]
  fn follow(buf: &'a [u8], loc: usize) -> Self::Inner {
    Self { _tab: flatbuffers::Table { buf, loc } }
  }
}

impl<'a> GatherNdOptions<'a> {

  #[inline]
  pub fn init_from_table(table: flatbuffers::Table<'a>) -> Self {
    GatherNdOptions { _tab: table }
  }
  #[allow(unused_mut)]
  pub fn create<'bldr: 'args, 'args: 'mut_bldr, 'mut_bldr>(
    _fbb: &'mut_bldr mut flatbuffers::FlatBufferBuilder<'bldr>,
    _args: &'args GatherNdOptionsArgs
  ) -> flatbuffers::WIPOffset<GatherNdOptions<'bldr>> {
    let mut builder = GatherNdOptionsBuilder::new(_fbb);
    builder.finish()
  }

  pub fn unpack(&self) -> GatherNdOptionsT {
    GatherNdOptionsT {
    }
  }
}

impl flatbuffers::Verifiable for GatherNdOptions<'_> {
  #[inline]
  fn run_verifier(
    v: &mut flatbuffers::Verifier, pos: usize
  ) -> Result<(), flatbuffers::InvalidFlatbuffer> {
    use self::flatbuffers::Verifiable;
    v.visit_table(pos)?
     .finish();
    Ok(())
  }
}
pub struct GatherNdOptionsArgs {
}
impl<'a> Default for GatherNdOptionsArgs {
  #[inline]
  fn default() -> Self {
    GatherNdOptionsArgs {
    }
  }
}

pub struct GatherNdOptionsBuilder<'a: 'b, 'b> {
  fbb_: &'b mut flatbuffers::FlatBufferBuilder<'a>,
  start_: flatbuffers::WIPOffset<flatbuffers::TableUnfinishedWIPOffset>,
}
impl<'a: 'b, 'b> GatherNdOptionsBuilder<'a, 'b> {
  #[inline]
  pub fn new(_fbb: &'b mut flatbuffers::FlatBufferBuilder<'a>) -> GatherNdOptionsBuilder<'a, 'b> {
    let start = _fbb.start_table();
    GatherNdOptionsBuilder {
      fbb_: _fbb,
      start_: start,
    }
  }
  #[inline]
  pub fn finish(self) -> flatbuffers::WIPOffset<GatherNdOptions<'a>> {
    let o = self.fbb_.end_table(self.start_);
    flatbuffers::WIPOffset::new(o.value())
  }
}

impl core::fmt::Debug for GatherNdOptions<'_> {
  fn fmt(&self, f: &mut core::fmt::Formatter<'_>) -> core::fmt::Result {
    let mut ds = f.debug_struct("GatherNdOptions");
      ds.finish()
  }
}
#[non_exhaustive]
#[derive(Debug, Clone, PartialEq)]
pub struct GatherNdOptionsT {
}
impl Default for GatherNdOptionsT {
  fn default() -> Self {
    Self {
    }
  }
}
impl GatherNdOptionsT {
  pub fn pack<'b>(
    &self,
    _fbb: &mut flatbuffers::FlatBufferBuilder<'b>
  ) -> flatbuffers::WIPOffset<GatherNdOptions<'b>> {
    GatherNdOptions::create(_fbb, &GatherNdOptionsArgs{
    })
  }
}
pub enum WhereOptionsOffset {}
#[derive(Copy, Clone, PartialEq)]

pub struct WhereOptions<'a> {
  pub _tab: flatbuffers::Table<'a>,
}

impl<'a> flatbuffers::Follow<'a> for WhereOptions<'a> {
  type Inner = WhereOptions<'a>;
  #[inline]
  fn follow(buf: &'a [u8], loc: usize) -> Self::Inner {
    Self { _tab: flatbuffers::Table { buf, loc } }
  }
}

impl<'a> WhereOptions<'a> {

  #[inline]
  pub fn init_from_table(table: flatbuffers::Table<'a>) -> Self {
    WhereOptions { _tab: table }
  }
  #[allow(unused_mut)]
  pub fn create<'bldr: 'args, 'args: 'mut_bldr, 'mut_bldr>(
    _fbb: &'mut_bldr mut flatbuffers::FlatBufferBuilder<'bldr>,
    _args: &'args WhereOptionsArgs
  ) -> flatbuffers::WIPOffset<WhereOptions<'bldr>> {
    let mut builder = WhereOptionsBuilder::new(_fbb);
    builder.finish()
  }

  pub fn unpack(&self) -> WhereOptionsT {
    WhereOptionsT {
    }
  }
}

impl flatbuffers::Verifiable for WhereOptions<'_> {
  #[inline]
  fn run_verifier(
    v: &mut flatbuffers::Verifier, pos: usize
  ) -> Result<(), flatbuffers::InvalidFlatbuffer> {
    use self::flatbuffers::Verifiable;
    v.visit_table(pos)?
     .finish();
    Ok(())
  }
}
pub struct WhereOptionsArgs {
}
impl<'a> Default for WhereOptionsArgs {
  #[inline]
  fn default() -> Self {
    WhereOptionsArgs {
    }
  }
}

pub struct WhereOptionsBuilder<'a: 'b, 'b> {
  fbb_: &'b mut flatbuffers::FlatBufferBuilder<'a>,
  start_: flatbuffers::WIPOffset<flatbuffers::TableUnfinishedWIPOffset>,
}
impl<'a: 'b, 'b> WhereOptionsBuilder<'a, 'b> {
  #[inline]
  pub fn new(_fbb: &'b mut flatbuffers::FlatBufferBuilder<'a>) -> WhereOptionsBuilder<'a, 'b> {
    let start = _fbb.start_table();
    WhereOptionsBuilder {
      fbb_: _fbb,
      start_: start,
    }
  }
  #[inline]
  pub fn finish(self) -> flatbuffers::WIPOffset<WhereOptions<'a>> {
    let o = self.fbb_.end_table(self.start_);
    flatbuffers::WIPOffset::new(o.value())
  }
}

impl core::fmt::Debug for WhereOptions<'_> {
  fn fmt(&self, f: &mut core::fmt::Formatter<'_>) -> core::fmt::Result {
    let mut ds = f.debug_struct("WhereOptions");
      ds.finish()
  }
}
#[non_exhaustive]
#[derive(Debug, Clone, PartialEq)]
pub struct WhereOptionsT {
}
impl Default for WhereOptionsT {
  fn default() -> Self {
    Self {
    }
  }
}
impl WhereOptionsT {
  pub fn pack<'b>(
    &self,
    _fbb: &mut flatbuffers::FlatBufferBuilder<'b>
  ) -> flatbuffers::WIPOffset<WhereOptions<'b>> {
    WhereOptions::create(_fbb, &WhereOptionsArgs{
    })
  }
}
pub enum ReverseSequenceOptionsOffset {}
#[derive(Copy, Clone, PartialEq)]

pub struct ReverseSequenceOptions<'a> {
  pub _tab: flatbuffers::Table<'a>,
}

impl<'a> flatbuffers::Follow<'a> for ReverseSequenceOptions<'a> {
  type Inner = ReverseSequenceOptions<'a>;
  #[inline]
  fn follow(buf: &'a [u8], loc: usize) -> Self::Inner {
    Self { _tab: flatbuffers::Table { buf, loc } }
  }
}

impl<'a> ReverseSequenceOptions<'a> {
  pub const VT_SEQ_DIM: flatbuffers::VOffsetT = 4;
  pub const VT_BATCH_DIM: flatbuffers::VOffsetT = 6;

  #[inline]
  pub fn init_from_table(table: flatbuffers::Table<'a>) -> Self {
    ReverseSequenceOptions { _tab: table }
  }
  #[allow(unused_mut)]
  pub fn create<'bldr: 'args, 'args: 'mut_bldr, 'mut_bldr>(
    _fbb: &'mut_bldr mut flatbuffers::FlatBufferBuilder<'bldr>,
    args: &'args ReverseSequenceOptionsArgs
  ) -> flatbuffers::WIPOffset<ReverseSequenceOptions<'bldr>> {
    let mut builder = ReverseSequenceOptionsBuilder::new(_fbb);
    builder.add_batch_dim(args.batch_dim);
    builder.add_seq_dim(args.seq_dim);
    builder.finish()
  }

  pub fn unpack(&self) -> ReverseSequenceOptionsT {
    let seq_dim = self.seq_dim();
    let batch_dim = self.batch_dim();
    ReverseSequenceOptionsT {
      seq_dim,
      batch_dim,
    }
  }

  #[inline]
  pub fn seq_dim(&self) -> i32 {
    self._tab.get::<i32>(ReverseSequenceOptions::VT_SEQ_DIM, Some(0)).unwrap()
  }
  #[inline]
  pub fn batch_dim(&self) -> i32 {
    self._tab.get::<i32>(ReverseSequenceOptions::VT_BATCH_DIM, Some(0)).unwrap()
  }
}

impl flatbuffers::Verifiable for ReverseSequenceOptions<'_> {
  #[inline]
  fn run_verifier(
    v: &mut flatbuffers::Verifier, pos: usize
  ) -> Result<(), flatbuffers::InvalidFlatbuffer> {
    use self::flatbuffers::Verifiable;
    v.visit_table(pos)?
     .visit_field::<i32>("seq_dim", Self::VT_SEQ_DIM, false)?
     .visit_field::<i32>("batch_dim", Self::VT_BATCH_DIM, false)?
     .finish();
    Ok(())
  }
}
pub struct ReverseSequenceOptionsArgs {
    pub seq_dim: i32,
    pub batch_dim: i32,
}
impl<'a> Default for ReverseSequenceOptionsArgs {
  #[inline]
  fn default() -> Self {
    ReverseSequenceOptionsArgs {
      seq_dim: 0,
      batch_dim: 0,
    }
  }
}

pub struct ReverseSequenceOptionsBuilder<'a: 'b, 'b> {
  fbb_: &'b mut flatbuffers::FlatBufferBuilder<'a>,
  start_: flatbuffers::WIPOffset<flatbuffers::TableUnfinishedWIPOffset>,
}
impl<'a: 'b, 'b> ReverseSequenceOptionsBuilder<'a, 'b> {
  #[inline]
  pub fn add_seq_dim(&mut self, seq_dim: i32) {
    self.fbb_.push_slot::<i32>(ReverseSequenceOptions::VT_SEQ_DIM, seq_dim, 0);
  }
  #[inline]
  pub fn add_batch_dim(&mut self, batch_dim: i32) {
    self.fbb_.push_slot::<i32>(ReverseSequenceOptions::VT_BATCH_DIM, batch_dim, 0);
  }
  #[inline]
  pub fn new(_fbb: &'b mut flatbuffers::FlatBufferBuilder<'a>) -> ReverseSequenceOptionsBuilder<'a, 'b> {
    let start = _fbb.start_table();
    ReverseSequenceOptionsBuilder {
      fbb_: _fbb,
      start_: start,
    }
  }
  #[inline]
  pub fn finish(self) -> flatbuffers::WIPOffset<ReverseSequenceOptions<'a>> {
    let o = self.fbb_.end_table(self.start_);
    flatbuffers::WIPOffset::new(o.value())
  }
}

impl core::fmt::Debug for ReverseSequenceOptions<'_> {
  fn fmt(&self, f: &mut core::fmt::Formatter<'_>) -> core::fmt::Result {
    let mut ds = f.debug_struct("ReverseSequenceOptions");
      ds.field("seq_dim", &self.seq_dim());
      ds.field("batch_dim", &self.batch_dim());
      ds.finish()
  }
}
#[non_exhaustive]
#[derive(Debug, Clone, PartialEq)]
pub struct ReverseSequenceOptionsT {
  pub seq_dim: i32,
  pub batch_dim: i32,
}
impl Default for ReverseSequenceOptionsT {
  fn default() -> Self {
    Self {
      seq_dim: 0,
      batch_dim: 0,
    }
  }
}
impl ReverseSequenceOptionsT {
  pub fn pack<'b>(
    &self,
    _fbb: &mut flatbuffers::FlatBufferBuilder<'b>
  ) -> flatbuffers::WIPOffset<ReverseSequenceOptions<'b>> {
    let seq_dim = self.seq_dim;
    let batch_dim = self.batch_dim;
    ReverseSequenceOptions::create(_fbb, &ReverseSequenceOptionsArgs{
      seq_dim,
      batch_dim,
    })
  }
}
pub enum MatrixDiagOptionsOffset {}
#[derive(Copy, Clone, PartialEq)]

pub struct MatrixDiagOptions<'a> {
  pub _tab: flatbuffers::Table<'a>,
}

impl<'a> flatbuffers::Follow<'a> for MatrixDiagOptions<'a> {
  type Inner = MatrixDiagOptions<'a>;
  #[inline]
  fn follow(buf: &'a [u8], loc: usize) -> Self::Inner {
    Self { _tab: flatbuffers::Table { buf, loc } }
  }
}

impl<'a> MatrixDiagOptions<'a> {

  #[inline]
  pub fn init_from_table(table: flatbuffers::Table<'a>) -> Self {
    MatrixDiagOptions { _tab: table }
  }
  #[allow(unused_mut)]
  pub fn create<'bldr: 'args, 'args: 'mut_bldr, 'mut_bldr>(
    _fbb: &'mut_bldr mut flatbuffers::FlatBufferBuilder<'bldr>,
    _args: &'args MatrixDiagOptionsArgs
  ) -> flatbuffers::WIPOffset<MatrixDiagOptions<'bldr>> {
    let mut builder = MatrixDiagOptionsBuilder::new(_fbb);
    builder.finish()
  }

  pub fn unpack(&self) -> MatrixDiagOptionsT {
    MatrixDiagOptionsT {
    }
  }
}

impl flatbuffers::Verifiable for MatrixDiagOptions<'_> {
  #[inline]
  fn run_verifier(
    v: &mut flatbuffers::Verifier, pos: usize
  ) -> Result<(), flatbuffers::InvalidFlatbuffer> {
    use self::flatbuffers::Verifiable;
    v.visit_table(pos)?
     .finish();
    Ok(())
  }
}
pub struct MatrixDiagOptionsArgs {
}
impl<'a> Default for MatrixDiagOptionsArgs {
  #[inline]
  fn default() -> Self {
    MatrixDiagOptionsArgs {
    }
  }
}

pub struct MatrixDiagOptionsBuilder<'a: 'b, 'b> {
  fbb_: &'b mut flatbuffers::FlatBufferBuilder<'a>,
  start_: flatbuffers::WIPOffset<flatbuffers::TableUnfinishedWIPOffset>,
}
impl<'a: 'b, 'b> MatrixDiagOptionsBuilder<'a, 'b> {
  #[inline]
  pub fn new(_fbb: &'b mut flatbuffers::FlatBufferBuilder<'a>) -> MatrixDiagOptionsBuilder<'a, 'b> {
    let start = _fbb.start_table();
    MatrixDiagOptionsBuilder {
      fbb_: _fbb,
      start_: start,
    }
  }
  #[inline]
  pub fn finish(self) -> flatbuffers::WIPOffset<MatrixDiagOptions<'a>> {
    let o = self.fbb_.end_table(self.start_);
    flatbuffers::WIPOffset::new(o.value())
  }
}

impl core::fmt::Debug for MatrixDiagOptions<'_> {
  fn fmt(&self, f: &mut core::fmt::Formatter<'_>) -> core::fmt::Result {
    let mut ds = f.debug_struct("MatrixDiagOptions");
      ds.finish()
  }
}
#[non_exhaustive]
#[derive(Debug, Clone, PartialEq)]
pub struct MatrixDiagOptionsT {
}
impl Default for MatrixDiagOptionsT {
  fn default() -> Self {
    Self {
    }
  }
}
impl MatrixDiagOptionsT {
  pub fn pack<'b>(
    &self,
    _fbb: &mut flatbuffers::FlatBufferBuilder<'b>
  ) -> flatbuffers::WIPOffset<MatrixDiagOptions<'b>> {
    MatrixDiagOptions::create(_fbb, &MatrixDiagOptionsArgs{
    })
  }
}
pub enum QuantizeOptionsOffset {}
#[derive(Copy, Clone, PartialEq)]

pub struct QuantizeOptions<'a> {
  pub _tab: flatbuffers::Table<'a>,
}

impl<'a> flatbuffers::Follow<'a> for QuantizeOptions<'a> {
  type Inner = QuantizeOptions<'a>;
  #[inline]
  fn follow(buf: &'a [u8], loc: usize) -> Self::Inner {
    Self { _tab: flatbuffers::Table { buf, loc } }
  }
}

impl<'a> QuantizeOptions<'a> {

  #[inline]
  pub fn init_from_table(table: flatbuffers::Table<'a>) -> Self {
    QuantizeOptions { _tab: table }
  }
  #[allow(unused_mut)]
  pub fn create<'bldr: 'args, 'args: 'mut_bldr, 'mut_bldr>(
    _fbb: &'mut_bldr mut flatbuffers::FlatBufferBuilder<'bldr>,
    _args: &'args QuantizeOptionsArgs
  ) -> flatbuffers::WIPOffset<QuantizeOptions<'bldr>> {
    let mut builder = QuantizeOptionsBuilder::new(_fbb);
    builder.finish()
  }

  pub fn unpack(&self) -> QuantizeOptionsT {
    QuantizeOptionsT {
    }
  }
}

impl flatbuffers::Verifiable for QuantizeOptions<'_> {
  #[inline]
  fn run_verifier(
    v: &mut flatbuffers::Verifier, pos: usize
  ) -> Result<(), flatbuffers::InvalidFlatbuffer> {
    use self::flatbuffers::Verifiable;
    v.visit_table(pos)?
     .finish();
    Ok(())
  }
}
pub struct QuantizeOptionsArgs {
}
impl<'a> Default for QuantizeOptionsArgs {
  #[inline]
  fn default() -> Self {
    QuantizeOptionsArgs {
    }
  }
}

pub struct QuantizeOptionsBuilder<'a: 'b, 'b> {
  fbb_: &'b mut flatbuffers::FlatBufferBuilder<'a>,
  start_: flatbuffers::WIPOffset<flatbuffers::TableUnfinishedWIPOffset>,
}
impl<'a: 'b, 'b> QuantizeOptionsBuilder<'a, 'b> {
  #[inline]
  pub fn new(_fbb: &'b mut flatbuffers::FlatBufferBuilder<'a>) -> QuantizeOptionsBuilder<'a, 'b> {
    let start = _fbb.start_table();
    QuantizeOptionsBuilder {
      fbb_: _fbb,
      start_: start,
    }
  }
  #[inline]
  pub fn finish(self) -> flatbuffers::WIPOffset<QuantizeOptions<'a>> {
    let o = self.fbb_.end_table(self.start_);
    flatbuffers::WIPOffset::new(o.value())
  }
}

impl core::fmt::Debug for QuantizeOptions<'_> {
  fn fmt(&self, f: &mut core::fmt::Formatter<'_>) -> core::fmt::Result {
    let mut ds = f.debug_struct("QuantizeOptions");
      ds.finish()
  }
}
#[non_exhaustive]
#[derive(Debug, Clone, PartialEq)]
pub struct QuantizeOptionsT {
}
impl Default for QuantizeOptionsT {
  fn default() -> Self {
    Self {
    }
  }
}
impl QuantizeOptionsT {
  pub fn pack<'b>(
    &self,
    _fbb: &mut flatbuffers::FlatBufferBuilder<'b>
  ) -> flatbuffers::WIPOffset<QuantizeOptions<'b>> {
    QuantizeOptions::create(_fbb, &QuantizeOptionsArgs{
    })
  }
}
pub enum MatrixSetDiagOptionsOffset {}
#[derive(Copy, Clone, PartialEq)]

pub struct MatrixSetDiagOptions<'a> {
  pub _tab: flatbuffers::Table<'a>,
}

impl<'a> flatbuffers::Follow<'a> for MatrixSetDiagOptions<'a> {
  type Inner = MatrixSetDiagOptions<'a>;
  #[inline]
  fn follow(buf: &'a [u8], loc: usize) -> Self::Inner {
    Self { _tab: flatbuffers::Table { buf, loc } }
  }
}

impl<'a> MatrixSetDiagOptions<'a> {

  #[inline]
  pub fn init_from_table(table: flatbuffers::Table<'a>) -> Self {
    MatrixSetDiagOptions { _tab: table }
  }
  #[allow(unused_mut)]
  pub fn create<'bldr: 'args, 'args: 'mut_bldr, 'mut_bldr>(
    _fbb: &'mut_bldr mut flatbuffers::FlatBufferBuilder<'bldr>,
    _args: &'args MatrixSetDiagOptionsArgs
  ) -> flatbuffers::WIPOffset<MatrixSetDiagOptions<'bldr>> {
    let mut builder = MatrixSetDiagOptionsBuilder::new(_fbb);
    builder.finish()
  }

  pub fn unpack(&self) -> MatrixSetDiagOptionsT {
    MatrixSetDiagOptionsT {
    }
  }
}

impl flatbuffers::Verifiable for MatrixSetDiagOptions<'_> {
  #[inline]
  fn run_verifier(
    v: &mut flatbuffers::Verifier, pos: usize
  ) -> Result<(), flatbuffers::InvalidFlatbuffer> {
    use self::flatbuffers::Verifiable;
    v.visit_table(pos)?
     .finish();
    Ok(())
  }
}
pub struct MatrixSetDiagOptionsArgs {
}
impl<'a> Default for MatrixSetDiagOptionsArgs {
  #[inline]
  fn default() -> Self {
    MatrixSetDiagOptionsArgs {
    }
  }
}

pub struct MatrixSetDiagOptionsBuilder<'a: 'b, 'b> {
  fbb_: &'b mut flatbuffers::FlatBufferBuilder<'a>,
  start_: flatbuffers::WIPOffset<flatbuffers::TableUnfinishedWIPOffset>,
}
impl<'a: 'b, 'b> MatrixSetDiagOptionsBuilder<'a, 'b> {
  #[inline]
  pub fn new(_fbb: &'b mut flatbuffers::FlatBufferBuilder<'a>) -> MatrixSetDiagOptionsBuilder<'a, 'b> {
    let start = _fbb.start_table();
    MatrixSetDiagOptionsBuilder {
      fbb_: _fbb,
      start_: start,
    }
  }
  #[inline]
  pub fn finish(self) -> flatbuffers::WIPOffset<MatrixSetDiagOptions<'a>> {
    let o = self.fbb_.end_table(self.start_);
    flatbuffers::WIPOffset::new(o.value())
  }
}

impl core::fmt::Debug for MatrixSetDiagOptions<'_> {
  fn fmt(&self, f: &mut core::fmt::Formatter<'_>) -> core::fmt::Result {
    let mut ds = f.debug_struct("MatrixSetDiagOptions");
      ds.finish()
  }
}
#[non_exhaustive]
#[derive(Debug, Clone, PartialEq)]
pub struct MatrixSetDiagOptionsT {
}
impl Default for MatrixSetDiagOptionsT {
  fn default() -> Self {
    Self {
    }
  }
}
impl MatrixSetDiagOptionsT {
  pub fn pack<'b>(
    &self,
    _fbb: &mut flatbuffers::FlatBufferBuilder<'b>
  ) -> flatbuffers::WIPOffset<MatrixSetDiagOptions<'b>> {
    MatrixSetDiagOptions::create(_fbb, &MatrixSetDiagOptionsArgs{
    })
  }
}
pub enum IfOptionsOffset {}
#[derive(Copy, Clone, PartialEq)]

pub struct IfOptions<'a> {
  pub _tab: flatbuffers::Table<'a>,
}

impl<'a> flatbuffers::Follow<'a> for IfOptions<'a> {
  type Inner = IfOptions<'a>;
  #[inline]
  fn follow(buf: &'a [u8], loc: usize) -> Self::Inner {
    Self { _tab: flatbuffers::Table { buf, loc } }
  }
}

impl<'a> IfOptions<'a> {
  pub const VT_THEN_SUBGRAPH_INDEX: flatbuffers::VOffsetT = 4;
  pub const VT_ELSE_SUBGRAPH_INDEX: flatbuffers::VOffsetT = 6;

  #[inline]
  pub fn init_from_table(table: flatbuffers::Table<'a>) -> Self {
    IfOptions { _tab: table }
  }
  #[allow(unused_mut)]
  pub fn create<'bldr: 'args, 'args: 'mut_bldr, 'mut_bldr>(
    _fbb: &'mut_bldr mut flatbuffers::FlatBufferBuilder<'bldr>,
    args: &'args IfOptionsArgs
  ) -> flatbuffers::WIPOffset<IfOptions<'bldr>> {
    let mut builder = IfOptionsBuilder::new(_fbb);
    builder.add_else_subgraph_index(args.else_subgraph_index);
    builder.add_then_subgraph_index(args.then_subgraph_index);
    builder.finish()
  }

  pub fn unpack(&self) -> IfOptionsT {
    let then_subgraph_index = self.then_subgraph_index();
    let else_subgraph_index = self.else_subgraph_index();
    IfOptionsT {
      then_subgraph_index,
      else_subgraph_index,
    }
  }

  #[inline]
  pub fn then_subgraph_index(&self) -> i32 {
    self._tab.get::<i32>(IfOptions::VT_THEN_SUBGRAPH_INDEX, Some(0)).unwrap()
  }
  #[inline]
  pub fn else_subgraph_index(&self) -> i32 {
    self._tab.get::<i32>(IfOptions::VT_ELSE_SUBGRAPH_INDEX, Some(0)).unwrap()
  }
}

impl flatbuffers::Verifiable for IfOptions<'_> {
  #[inline]
  fn run_verifier(
    v: &mut flatbuffers::Verifier, pos: usize
  ) -> Result<(), flatbuffers::InvalidFlatbuffer> {
    use self::flatbuffers::Verifiable;
    v.visit_table(pos)?
     .visit_field::<i32>("then_subgraph_index", Self::VT_THEN_SUBGRAPH_INDEX, false)?
     .visit_field::<i32>("else_subgraph_index", Self::VT_ELSE_SUBGRAPH_INDEX, false)?
     .finish();
    Ok(())
  }
}
pub struct IfOptionsArgs {
    pub then_subgraph_index: i32,
    pub else_subgraph_index: i32,
}
impl<'a> Default for IfOptionsArgs {
  #[inline]
  fn default() -> Self {
    IfOptionsArgs {
      then_subgraph_index: 0,
      else_subgraph_index: 0,
    }
  }
}

pub struct IfOptionsBuilder<'a: 'b, 'b> {
  fbb_: &'b mut flatbuffers::FlatBufferBuilder<'a>,
  start_: flatbuffers::WIPOffset<flatbuffers::TableUnfinishedWIPOffset>,
}
impl<'a: 'b, 'b> IfOptionsBuilder<'a, 'b> {
  #[inline]
  pub fn add_then_subgraph_index(&mut self, then_subgraph_index: i32) {
    self.fbb_.push_slot::<i32>(IfOptions::VT_THEN_SUBGRAPH_INDEX, then_subgraph_index, 0);
  }
  #[inline]
  pub fn add_else_subgraph_index(&mut self, else_subgraph_index: i32) {
    self.fbb_.push_slot::<i32>(IfOptions::VT_ELSE_SUBGRAPH_INDEX, else_subgraph_index, 0);
  }
  #[inline]
  pub fn new(_fbb: &'b mut flatbuffers::FlatBufferBuilder<'a>) -> IfOptionsBuilder<'a, 'b> {
    let start = _fbb.start_table();
    IfOptionsBuilder {
      fbb_: _fbb,
      start_: start,
    }
  }
  #[inline]
  pub fn finish(self) -> flatbuffers::WIPOffset<IfOptions<'a>> {
    let o = self.fbb_.end_table(self.start_);
    flatbuffers::WIPOffset::new(o.value())
  }
}

impl core::fmt::Debug for IfOptions<'_> {
  fn fmt(&self, f: &mut core::fmt::Formatter<'_>) -> core::fmt::Result {
    let mut ds = f.debug_struct("IfOptions");
      ds.field("then_subgraph_index", &self.then_subgraph_index());
      ds.field("else_subgraph_index", &self.else_subgraph_index());
      ds.finish()
  }
}
#[non_exhaustive]
#[derive(Debug, Clone, PartialEq)]
pub struct IfOptionsT {
  pub then_subgraph_index: i32,
  pub else_subgraph_index: i32,
}
impl Default for IfOptionsT {
  fn default() -> Self {
    Self {
      then_subgraph_index: 0,
      else_subgraph_index: 0,
    }
  }
}
impl IfOptionsT {
  pub fn pack<'b>(
    &self,
    _fbb: &mut flatbuffers::FlatBufferBuilder<'b>
  ) -> flatbuffers::WIPOffset<IfOptions<'b>> {
    let then_subgraph_index = self.then_subgraph_index;
    let else_subgraph_index = self.else_subgraph_index;
    IfOptions::create(_fbb, &IfOptionsArgs{
      then_subgraph_index,
      else_subgraph_index,
    })
  }
}
pub enum WhileOptionsOffset {}
#[derive(Copy, Clone, PartialEq)]

pub struct WhileOptions<'a> {
  pub _tab: flatbuffers::Table<'a>,
}

impl<'a> flatbuffers::Follow<'a> for WhileOptions<'a> {
  type Inner = WhileOptions<'a>;
  #[inline]
  fn follow(buf: &'a [u8], loc: usize) -> Self::Inner {
    Self { _tab: flatbuffers::Table { buf, loc } }
  }
}

impl<'a> WhileOptions<'a> {
  pub const VT_COND_SUBGRAPH_INDEX: flatbuffers::VOffsetT = 4;
  pub const VT_BODY_SUBGRAPH_INDEX: flatbuffers::VOffsetT = 6;

  #[inline]
  pub fn init_from_table(table: flatbuffers::Table<'a>) -> Self {
    WhileOptions { _tab: table }
  }
  #[allow(unused_mut)]
  pub fn create<'bldr: 'args, 'args: 'mut_bldr, 'mut_bldr>(
    _fbb: &'mut_bldr mut flatbuffers::FlatBufferBuilder<'bldr>,
    args: &'args WhileOptionsArgs
  ) -> flatbuffers::WIPOffset<WhileOptions<'bldr>> {
    let mut builder = WhileOptionsBuilder::new(_fbb);
    builder.add_body_subgraph_index(args.body_subgraph_index);
    builder.add_cond_subgraph_index(args.cond_subgraph_index);
    builder.finish()
  }

  pub fn unpack(&self) -> WhileOptionsT {
    let cond_subgraph_index = self.cond_subgraph_index();
    let body_subgraph_index = self.body_subgraph_index();
    WhileOptionsT {
      cond_subgraph_index,
      body_subgraph_index,
    }
  }

  #[inline]
  pub fn cond_subgraph_index(&self) -> i32 {
    self._tab.get::<i32>(WhileOptions::VT_COND_SUBGRAPH_INDEX, Some(0)).unwrap()
  }
  #[inline]
  pub fn body_subgraph_index(&self) -> i32 {
    self._tab.get::<i32>(WhileOptions::VT_BODY_SUBGRAPH_INDEX, Some(0)).unwrap()
  }
}

impl flatbuffers::Verifiable for WhileOptions<'_> {
  #[inline]
  fn run_verifier(
    v: &mut flatbuffers::Verifier, pos: usize
  ) -> Result<(), flatbuffers::InvalidFlatbuffer> {
    use self::flatbuffers::Verifiable;
    v.visit_table(pos)?
     .visit_field::<i32>("cond_subgraph_index", Self::VT_COND_SUBGRAPH_INDEX, false)?
     .visit_field::<i32>("body_subgraph_index", Self::VT_BODY_SUBGRAPH_INDEX, false)?
     .finish();
    Ok(())
  }
}
pub struct WhileOptionsArgs {
    pub cond_subgraph_index: i32,
    pub body_subgraph_index: i32,
}
impl<'a> Default for WhileOptionsArgs {
  #[inline]
  fn default() -> Self {
    WhileOptionsArgs {
      cond_subgraph_index: 0,
      body_subgraph_index: 0,
    }
  }
}

pub struct WhileOptionsBuilder<'a: 'b, 'b> {
  fbb_: &'b mut flatbuffers::FlatBufferBuilder<'a>,
  start_: flatbuffers::WIPOffset<flatbuffers::TableUnfinishedWIPOffset>,
}
impl<'a: 'b, 'b> WhileOptionsBuilder<'a, 'b> {
  #[inline]
  pub fn add_cond_subgraph_index(&mut self, cond_subgraph_index: i32) {
    self.fbb_.push_slot::<i32>(WhileOptions::VT_COND_SUBGRAPH_INDEX, cond_subgraph_index, 0);
  }
  #[inline]
  pub fn add_body_subgraph_index(&mut self, body_subgraph_index: i32) {
    self.fbb_.push_slot::<i32>(WhileOptions::VT_BODY_SUBGRAPH_INDEX, body_subgraph_index, 0);
  }
  #[inline]
  pub fn new(_fbb: &'b mut flatbuffers::FlatBufferBuilder<'a>) -> WhileOptionsBuilder<'a, 'b> {
    let start = _fbb.start_table();
    WhileOptionsBuilder {
      fbb_: _fbb,
      start_: start,
    }
  }
  #[inline]
  pub fn finish(self) -> flatbuffers::WIPOffset<WhileOptions<'a>> {
    let o = self.fbb_.end_table(self.start_);
    flatbuffers::WIPOffset::new(o.value())
  }
}

impl core::fmt::Debug for WhileOptions<'_> {
  fn fmt(&self, f: &mut core::fmt::Formatter<'_>) -> core::fmt::Result {
    let mut ds = f.debug_struct("WhileOptions");
      ds.field("cond_subgraph_index", &self.cond_subgraph_index());
      ds.field("body_subgraph_index", &self.body_subgraph_index());
      ds.finish()
  }
}
#[non_exhaustive]
#[derive(Debug, Clone, PartialEq)]
pub struct WhileOptionsT {
  pub cond_subgraph_index: i32,
  pub body_subgraph_index: i32,
}
impl Default for WhileOptionsT {
  fn default() -> Self {
    Self {
      cond_subgraph_index: 0,
      body_subgraph_index: 0,
    }
  }
}
impl WhileOptionsT {
  pub fn pack<'b>(
    &self,
    _fbb: &mut flatbuffers::FlatBufferBuilder<'b>
  ) -> flatbuffers::WIPOffset<WhileOptions<'b>> {
    let cond_subgraph_index = self.cond_subgraph_index;
    let body_subgraph_index = self.body_subgraph_index;
    WhileOptions::create(_fbb, &WhileOptionsArgs{
      cond_subgraph_index,
      body_subgraph_index,
    })
  }
}
pub enum NonMaxSuppressionV4OptionsOffset {}
#[derive(Copy, Clone, PartialEq)]

pub struct NonMaxSuppressionV4Options<'a> {
  pub _tab: flatbuffers::Table<'a>,
}

impl<'a> flatbuffers::Follow<'a> for NonMaxSuppressionV4Options<'a> {
  type Inner = NonMaxSuppressionV4Options<'a>;
  #[inline]
  fn follow(buf: &'a [u8], loc: usize) -> Self::Inner {
    Self { _tab: flatbuffers::Table { buf, loc } }
  }
}

impl<'a> NonMaxSuppressionV4Options<'a> {

  #[inline]
  pub fn init_from_table(table: flatbuffers::Table<'a>) -> Self {
    NonMaxSuppressionV4Options { _tab: table }
  }
  #[allow(unused_mut)]
  pub fn create<'bldr: 'args, 'args: 'mut_bldr, 'mut_bldr>(
    _fbb: &'mut_bldr mut flatbuffers::FlatBufferBuilder<'bldr>,
    _args: &'args NonMaxSuppressionV4OptionsArgs
  ) -> flatbuffers::WIPOffset<NonMaxSuppressionV4Options<'bldr>> {
    let mut builder = NonMaxSuppressionV4OptionsBuilder::new(_fbb);
    builder.finish()
  }

  pub fn unpack(&self) -> NonMaxSuppressionV4OptionsT {
    NonMaxSuppressionV4OptionsT {
    }
  }
}

impl flatbuffers::Verifiable for NonMaxSuppressionV4Options<'_> {
  #[inline]
  fn run_verifier(
    v: &mut flatbuffers::Verifier, pos: usize
  ) -> Result<(), flatbuffers::InvalidFlatbuffer> {
    use self::flatbuffers::Verifiable;
    v.visit_table(pos)?
     .finish();
    Ok(())
  }
}
pub struct NonMaxSuppressionV4OptionsArgs {
}
impl<'a> Default for NonMaxSuppressionV4OptionsArgs {
  #[inline]
  fn default() -> Self {
    NonMaxSuppressionV4OptionsArgs {
    }
  }
}

pub struct NonMaxSuppressionV4OptionsBuilder<'a: 'b, 'b> {
  fbb_: &'b mut flatbuffers::FlatBufferBuilder<'a>,
  start_: flatbuffers::WIPOffset<flatbuffers::TableUnfinishedWIPOffset>,
}
impl<'a: 'b, 'b> NonMaxSuppressionV4OptionsBuilder<'a, 'b> {
  #[inline]
  pub fn new(_fbb: &'b mut flatbuffers::FlatBufferBuilder<'a>) -> NonMaxSuppressionV4OptionsBuilder<'a, 'b> {
    let start = _fbb.start_table();
    NonMaxSuppressionV4OptionsBuilder {
      fbb_: _fbb,
      start_: start,
    }
  }
  #[inline]
  pub fn finish(self) -> flatbuffers::WIPOffset<NonMaxSuppressionV4Options<'a>> {
    let o = self.fbb_.end_table(self.start_);
    flatbuffers::WIPOffset::new(o.value())
  }
}

impl core::fmt::Debug for NonMaxSuppressionV4Options<'_> {
  fn fmt(&self, f: &mut core::fmt::Formatter<'_>) -> core::fmt::Result {
    let mut ds = f.debug_struct("NonMaxSuppressionV4Options");
      ds.finish()
  }
}
#[non_exhaustive]
#[derive(Debug, Clone, PartialEq)]
pub struct NonMaxSuppressionV4OptionsT {
}
impl Default for NonMaxSuppressionV4OptionsT {
  fn default() -> Self {
    Self {
    }
  }
}
impl NonMaxSuppressionV4OptionsT {
  pub fn pack<'b>(
    &self,
    _fbb: &mut flatbuffers::FlatBufferBuilder<'b>
  ) -> flatbuffers::WIPOffset<NonMaxSuppressionV4Options<'b>> {
    NonMaxSuppressionV4Options::create(_fbb, &NonMaxSuppressionV4OptionsArgs{
    })
  }
}
pub enum NonMaxSuppressionV5OptionsOffset {}
#[derive(Copy, Clone, PartialEq)]

pub struct NonMaxSuppressionV5Options<'a> {
  pub _tab: flatbuffers::Table<'a>,
}

impl<'a> flatbuffers::Follow<'a> for NonMaxSuppressionV5Options<'a> {
  type Inner = NonMaxSuppressionV5Options<'a>;
  #[inline]
  fn follow(buf: &'a [u8], loc: usize) -> Self::Inner {
    Self { _tab: flatbuffers::Table { buf, loc } }
  }
}

impl<'a> NonMaxSuppressionV5Options<'a> {

  #[inline]
  pub fn init_from_table(table: flatbuffers::Table<'a>) -> Self {
    NonMaxSuppressionV5Options { _tab: table }
  }
  #[allow(unused_mut)]
  pub fn create<'bldr: 'args, 'args: 'mut_bldr, 'mut_bldr>(
    _fbb: &'mut_bldr mut flatbuffers::FlatBufferBuilder<'bldr>,
    _args: &'args NonMaxSuppressionV5OptionsArgs
  ) -> flatbuffers::WIPOffset<NonMaxSuppressionV5Options<'bldr>> {
    let mut builder = NonMaxSuppressionV5OptionsBuilder::new(_fbb);
    builder.finish()
  }

  pub fn unpack(&self) -> NonMaxSuppressionV5OptionsT {
    NonMaxSuppressionV5OptionsT {
    }
  }
}

impl flatbuffers::Verifiable for NonMaxSuppressionV5Options<'_> {
  #[inline]
  fn run_verifier(
    v: &mut flatbuffers::Verifier, pos: usize
  ) -> Result<(), flatbuffers::InvalidFlatbuffer> {
    use self::flatbuffers::Verifiable;
    v.visit_table(pos)?
     .finish();
    Ok(())
  }
}
pub struct NonMaxSuppressionV5OptionsArgs {
}
impl<'a> Default for NonMaxSuppressionV5OptionsArgs {
  #[inline]
  fn default() -> Self {
    NonMaxSuppressionV5OptionsArgs {
    }
  }
}

pub struct NonMaxSuppressionV5OptionsBuilder<'a: 'b, 'b> {
  fbb_: &'b mut flatbuffers::FlatBufferBuilder<'a>,
  start_: flatbuffers::WIPOffset<flatbuffers::TableUnfinishedWIPOffset>,
}
impl<'a: 'b, 'b> NonMaxSuppressionV5OptionsBuilder<'a, 'b> {
  #[inline]
  pub fn new(_fbb: &'b mut flatbuffers::FlatBufferBuilder<'a>) -> NonMaxSuppressionV5OptionsBuilder<'a, 'b> {
    let start = _fbb.start_table();
    NonMaxSuppressionV5OptionsBuilder {
      fbb_: _fbb,
      start_: start,
    }
  }
  #[inline]
  pub fn finish(self) -> flatbuffers::WIPOffset<NonMaxSuppressionV5Options<'a>> {
    let o = self.fbb_.end_table(self.start_);
    flatbuffers::WIPOffset::new(o.value())
  }
}

impl core::fmt::Debug for NonMaxSuppressionV5Options<'_> {
  fn fmt(&self, f: &mut core::fmt::Formatter<'_>) -> core::fmt::Result {
    let mut ds = f.debug_struct("NonMaxSuppressionV5Options");
      ds.finish()
  }
}
#[non_exhaustive]
#[derive(Debug, Clone, PartialEq)]
pub struct NonMaxSuppressionV5OptionsT {
}
impl Default for NonMaxSuppressionV5OptionsT {
  fn default() -> Self {
    Self {
    }
  }
}
impl NonMaxSuppressionV5OptionsT {
  pub fn pack<'b>(
    &self,
    _fbb: &mut flatbuffers::FlatBufferBuilder<'b>
  ) -> flatbuffers::WIPOffset<NonMaxSuppressionV5Options<'b>> {
    NonMaxSuppressionV5Options::create(_fbb, &NonMaxSuppressionV5OptionsArgs{
    })
  }
}
pub enum ScatterNdOptionsOffset {}
#[derive(Copy, Clone, PartialEq)]

pub struct ScatterNdOptions<'a> {
  pub _tab: flatbuffers::Table<'a>,
}

impl<'a> flatbuffers::Follow<'a> for ScatterNdOptions<'a> {
  type Inner = ScatterNdOptions<'a>;
  #[inline]
  fn follow(buf: &'a [u8], loc: usize) -> Self::Inner {
    Self { _tab: flatbuffers::Table { buf, loc } }
  }
}

impl<'a> ScatterNdOptions<'a> {

  #[inline]
  pub fn init_from_table(table: flatbuffers::Table<'a>) -> Self {
    ScatterNdOptions { _tab: table }
  }
  #[allow(unused_mut)]
  pub fn create<'bldr: 'args, 'args: 'mut_bldr, 'mut_bldr>(
    _fbb: &'mut_bldr mut flatbuffers::FlatBufferBuilder<'bldr>,
    _args: &'args ScatterNdOptionsArgs
  ) -> flatbuffers::WIPOffset<ScatterNdOptions<'bldr>> {
    let mut builder = ScatterNdOptionsBuilder::new(_fbb);
    builder.finish()
  }

  pub fn unpack(&self) -> ScatterNdOptionsT {
    ScatterNdOptionsT {
    }
  }
}

impl flatbuffers::Verifiable for ScatterNdOptions<'_> {
  #[inline]
  fn run_verifier(
    v: &mut flatbuffers::Verifier, pos: usize
  ) -> Result<(), flatbuffers::InvalidFlatbuffer> {
    use self::flatbuffers::Verifiable;
    v.visit_table(pos)?
     .finish();
    Ok(())
  }
}
pub struct ScatterNdOptionsArgs {
}
impl<'a> Default for ScatterNdOptionsArgs {
  #[inline]
  fn default() -> Self {
    ScatterNdOptionsArgs {
    }
  }
}

pub struct ScatterNdOptionsBuilder<'a: 'b, 'b> {
  fbb_: &'b mut flatbuffers::FlatBufferBuilder<'a>,
  start_: flatbuffers::WIPOffset<flatbuffers::TableUnfinishedWIPOffset>,
}
impl<'a: 'b, 'b> ScatterNdOptionsBuilder<'a, 'b> {
  #[inline]
  pub fn new(_fbb: &'b mut flatbuffers::FlatBufferBuilder<'a>) -> ScatterNdOptionsBuilder<'a, 'b> {
    let start = _fbb.start_table();
    ScatterNdOptionsBuilder {
      fbb_: _fbb,
      start_: start,
    }
  }
  #[inline]
  pub fn finish(self) -> flatbuffers::WIPOffset<ScatterNdOptions<'a>> {
    let o = self.fbb_.end_table(self.start_);
    flatbuffers::WIPOffset::new(o.value())
  }
}

impl core::fmt::Debug for ScatterNdOptions<'_> {
  fn fmt(&self, f: &mut core::fmt::Formatter<'_>) -> core::fmt::Result {
    let mut ds = f.debug_struct("ScatterNdOptions");
      ds.finish()
  }
}
#[non_exhaustive]
#[derive(Debug, Clone, PartialEq)]
pub struct ScatterNdOptionsT {
}
impl Default for ScatterNdOptionsT {
  fn default() -> Self {
    Self {
    }
  }
}
impl ScatterNdOptionsT {
  pub fn pack<'b>(
    &self,
    _fbb: &mut flatbuffers::FlatBufferBuilder<'b>
  ) -> flatbuffers::WIPOffset<ScatterNdOptions<'b>> {
    ScatterNdOptions::create(_fbb, &ScatterNdOptionsArgs{
    })
  }
}
pub enum OperatorCodeOffset {}
#[derive(Copy, Clone, PartialEq)]

pub struct OperatorCode<'a> {
  pub _tab: flatbuffers::Table<'a>,
}

impl<'a> flatbuffers::Follow<'a> for OperatorCode<'a> {
  type Inner = OperatorCode<'a>;
  #[inline]
  fn follow(buf: &'a [u8], loc: usize) -> Self::Inner {
    Self { _tab: flatbuffers::Table { buf, loc } }
  }
}

impl<'a> OperatorCode<'a> {
  pub const VT_BUILTIN_CODE: flatbuffers::VOffsetT = 4;
  pub const VT_CUSTOM_CODE: flatbuffers::VOffsetT = 6;
  pub const VT_VERSION: flatbuffers::VOffsetT = 8;

  #[inline]
  pub fn init_from_table(table: flatbuffers::Table<'a>) -> Self {
    OperatorCode { _tab: table }
  }
  #[allow(unused_mut)]
  pub fn create<'bldr: 'args, 'args: 'mut_bldr, 'mut_bldr>(
    _fbb: &'mut_bldr mut flatbuffers::FlatBufferBuilder<'bldr>,
    args: &'args OperatorCodeArgs<'args>
  ) -> flatbuffers::WIPOffset<OperatorCode<'bldr>> {
    let mut builder = OperatorCodeBuilder::new(_fbb);
    builder.add_version(args.version);
    if let Some(x) = args.custom_code { builder.add_custom_code(x); }
    builder.add_builtin_code(args.builtin_code);
    builder.finish()
  }

  pub fn unpack(&self) -> OperatorCodeT {
    let builtin_code = self.builtin_code();
    let custom_code = self.custom_code().map(|x| {
      x.to_string()
    });
    let version = self.version();
    OperatorCodeT {
      builtin_code,
      custom_code,
      version,
    }
  }

  #[inline]
  pub fn builtin_code(&self) -> BuiltinOperator {
    self._tab.get::<BuiltinOperator>(OperatorCode::VT_BUILTIN_CODE, Some(BuiltinOperator::ADD)).unwrap()
  }
  #[inline]
  pub fn custom_code(&self) -> Option<&'a str> {
    self._tab.get::<flatbuffers::ForwardsUOffset<&str>>(OperatorCode::VT_CUSTOM_CODE, None)
  }
  #[inline]
  pub fn version(&self) -> i32 {
    self._tab.get::<i32>(OperatorCode::VT_VERSION, Some(1)).unwrap()
  }
}

impl flatbuffers::Verifiable for OperatorCode<'_> {
  #[inline]
  fn run_verifier(
    v: &mut flatbuffers::Verifier, pos: usize
  ) -> Result<(), flatbuffers::InvalidFlatbuffer> {
    use self::flatbuffers::Verifiable;
    v.visit_table(pos)?
     .visit_field::<BuiltinOperator>("builtin_code", Self::VT_BUILTIN_CODE, false)?
     .visit_field::<flatbuffers::ForwardsUOffset<&str>>("custom_code", Self::VT_CUSTOM_CODE, false)?
     .visit_field::<i32>("version", Self::VT_VERSION, false)?
     .finish();
    Ok(())
  }
}
pub struct OperatorCodeArgs<'a> {
    pub builtin_code: BuiltinOperator,
    pub custom_code: Option<flatbuffers::WIPOffset<&'a str>>,
    pub version: i32,
}
impl<'a> Default for OperatorCodeArgs<'a> {
  #[inline]
  fn default() -> Self {
    OperatorCodeArgs {
      builtin_code: BuiltinOperator::ADD,
      custom_code: None,
      version: 1,
    }
  }
}

pub struct OperatorCodeBuilder<'a: 'b, 'b> {
  fbb_: &'b mut flatbuffers::FlatBufferBuilder<'a>,
  start_: flatbuffers::WIPOffset<flatbuffers::TableUnfinishedWIPOffset>,
}
impl<'a: 'b, 'b> OperatorCodeBuilder<'a, 'b> {
  #[inline]
  pub fn add_builtin_code(&mut self, builtin_code: BuiltinOperator) {
    self.fbb_.push_slot::<BuiltinOperator>(OperatorCode::VT_BUILTIN_CODE, builtin_code, BuiltinOperator::ADD);
  }
  #[inline]
  pub fn add_custom_code(&mut self, custom_code: flatbuffers::WIPOffset<&'b  str>) {
    self.fbb_.push_slot_always::<flatbuffers::WIPOffset<_>>(OperatorCode::VT_CUSTOM_CODE, custom_code);
  }
  #[inline]
  pub fn add_version(&mut self, version: i32) {
    self.fbb_.push_slot::<i32>(OperatorCode::VT_VERSION, version, 1);
  }
  #[inline]
  pub fn new(_fbb: &'b mut flatbuffers::FlatBufferBuilder<'a>) -> OperatorCodeBuilder<'a, 'b> {
    let start = _fbb.start_table();
    OperatorCodeBuilder {
      fbb_: _fbb,
      start_: start,
    }
  }
  #[inline]
  pub fn finish(self) -> flatbuffers::WIPOffset<OperatorCode<'a>> {
    let o = self.fbb_.end_table(self.start_);
    flatbuffers::WIPOffset::new(o.value())
  }
}

impl core::fmt::Debug for OperatorCode<'_> {
  fn fmt(&self, f: &mut core::fmt::Formatter<'_>) -> core::fmt::Result {
    let mut ds = f.debug_struct("OperatorCode");
      ds.field("builtin_code", &self.builtin_code());
      ds.field("custom_code", &self.custom_code());
      ds.field("version", &self.version());
      ds.finish()
  }
}
#[non_exhaustive]
#[derive(Debug, Clone, PartialEq)]
pub struct OperatorCodeT {
  pub builtin_code: BuiltinOperator,
  pub custom_code: Option<String>,
  pub version: i32,
}
impl Default for OperatorCodeT {
  fn default() -> Self {
    Self {
      builtin_code: BuiltinOperator::ADD,
      custom_code: None,
      version: 1,
    }
  }
}
impl OperatorCodeT {
  pub fn pack<'b>(
    &self,
    _fbb: &mut flatbuffers::FlatBufferBuilder<'b>
  ) -> flatbuffers::WIPOffset<OperatorCode<'b>> {
    let builtin_code = self.builtin_code;
    let custom_code = self.custom_code.as_ref().map(|x|{
      _fbb.create_string(x)
    });
    let version = self.version;
    OperatorCode::create(_fbb, &OperatorCodeArgs{
      builtin_code,
      custom_code,
      version,
    })
  }
}
pub enum OperatorOffset {}
#[derive(Copy, Clone, PartialEq)]

pub struct Operator<'a> {
  pub _tab: flatbuffers::Table<'a>,
}

impl<'a> flatbuffers::Follow<'a> for Operator<'a> {
  type Inner = Operator<'a>;
  #[inline]
  fn follow(buf: &'a [u8], loc: usize) -> Self::Inner {
    Self { _tab: flatbuffers::Table { buf, loc } }
  }
}

impl<'a> Operator<'a> {
  pub const VT_OPCODE_INDEX: flatbuffers::VOffsetT = 4;
  pub const VT_INPUTS: flatbuffers::VOffsetT = 6;
  pub const VT_OUTPUTS: flatbuffers::VOffsetT = 8;
  pub const VT_BUILTIN_OPTIONS_TYPE: flatbuffers::VOffsetT = 10;
  pub const VT_BUILTIN_OPTIONS: flatbuffers::VOffsetT = 12;
  pub const VT_CUSTOM_OPTIONS: flatbuffers::VOffsetT = 14;
  pub const VT_CUSTOM_OPTIONS_FORMAT: flatbuffers::VOffsetT = 16;
  pub const VT_MUTATING_VARIABLE_INPUTS: flatbuffers::VOffsetT = 18;
  pub const VT_INTERMEDIATES: flatbuffers::VOffsetT = 20;

  #[inline]
  pub fn init_from_table(table: flatbuffers::Table<'a>) -> Self {
    Operator { _tab: table }
  }
  #[allow(unused_mut)]
  pub fn create<'bldr: 'args, 'args: 'mut_bldr, 'mut_bldr>(
    _fbb: &'mut_bldr mut flatbuffers::FlatBufferBuilder<'bldr>,
    args: &'args OperatorArgs<'args>
  ) -> flatbuffers::WIPOffset<Operator<'bldr>> {
    let mut builder = OperatorBuilder::new(_fbb);
    if let Some(x) = args.intermediates { builder.add_intermediates(x); }
    if let Some(x) = args.mutating_variable_inputs { builder.add_mutating_variable_inputs(x); }
    if let Some(x) = args.custom_options { builder.add_custom_options(x); }
    if let Some(x) = args.builtin_options { builder.add_builtin_options(x); }
    if let Some(x) = args.outputs { builder.add_outputs(x); }
    if let Some(x) = args.inputs { builder.add_inputs(x); }
    builder.add_opcode_index(args.opcode_index);
    builder.add_custom_options_format(args.custom_options_format);
    builder.add_builtin_options_type(args.builtin_options_type);
    builder.finish()
  }

  pub fn unpack(&self) -> OperatorT {
    let opcode_index = self.opcode_index();
    let inputs = self.inputs().map(|x| {
      x.into_iter().collect()
    });
    let outputs = self.outputs().map(|x| {
      x.into_iter().collect()
    });
    let builtin_options = match self.builtin_options_type() {
      BuiltinOptions::NONE => BuiltinOptionsT::NONE,
      BuiltinOptions::Conv2DOptions => BuiltinOptionsT::Conv2DOptions(Box::new(
        self.builtin_options_as_conv_2_doptions()
            .expect("Invalid union table, expected `BuiltinOptions::Conv2DOptions`.")
            .unpack()
      )),
      BuiltinOptions::DepthwiseConv2DOptions => BuiltinOptionsT::DepthwiseConv2DOptions(Box::new(
        self.builtin_options_as_depthwise_conv_2_doptions()
            .expect("Invalid union table, expected `BuiltinOptions::DepthwiseConv2DOptions`.")
            .unpack()
      )),
      BuiltinOptions::ConcatEmbeddingsOptions => BuiltinOptionsT::ConcatEmbeddingsOptions(Box::new(
        self.builtin_options_as_concat_embeddings_options()
            .expect("Invalid union table, expected `BuiltinOptions::ConcatEmbeddingsOptions`.")
            .unpack()
      )),
      BuiltinOptions::LSHProjectionOptions => BuiltinOptionsT::LSHProjectionOptions(Box::new(
        self.builtin_options_as_lshprojection_options()
            .expect("Invalid union table, expected `BuiltinOptions::LSHProjectionOptions`.")
            .unpack()
      )),
      BuiltinOptions::Pool2DOptions => BuiltinOptionsT::Pool2DOptions(Box::new(
        self.builtin_options_as_pool_2_doptions()
            .expect("Invalid union table, expected `BuiltinOptions::Pool2DOptions`.")
            .unpack()
      )),
      BuiltinOptions::SVDFOptions => BuiltinOptionsT::SVDFOptions(Box::new(
        self.builtin_options_as_svdfoptions()
            .expect("Invalid union table, expected `BuiltinOptions::SVDFOptions`.")
            .unpack()
      )),
      BuiltinOptions::RNNOptions => BuiltinOptionsT::RNNOptions(Box::new(
        self.builtin_options_as_rnnoptions()
            .expect("Invalid union table, expected `BuiltinOptions::RNNOptions`.")
            .unpack()
      )),
      BuiltinOptions::FullyConnectedOptions => BuiltinOptionsT::FullyConnectedOptions(Box::new(
        self.builtin_options_as_fully_connected_options()
            .expect("Invalid union table, expected `BuiltinOptions::FullyConnectedOptions`.")
            .unpack()
      )),
      BuiltinOptions::SoftmaxOptions => BuiltinOptionsT::SoftmaxOptions(Box::new(
        self.builtin_options_as_softmax_options()
            .expect("Invalid union table, expected `BuiltinOptions::SoftmaxOptions`.")
            .unpack()
      )),
      BuiltinOptions::ConcatenationOptions => BuiltinOptionsT::ConcatenationOptions(Box::new(
        self.builtin_options_as_concatenation_options()
            .expect("Invalid union table, expected `BuiltinOptions::ConcatenationOptions`.")
            .unpack()
      )),
      BuiltinOptions::AddOptions => BuiltinOptionsT::AddOptions(Box::new(
        self.builtin_options_as_add_options()
            .expect("Invalid union table, expected `BuiltinOptions::AddOptions`.")
            .unpack()
      )),
      BuiltinOptions::L2NormOptions => BuiltinOptionsT::L2NormOptions(Box::new(
        self.builtin_options_as_l2_norm_options()
            .expect("Invalid union table, expected `BuiltinOptions::L2NormOptions`.")
            .unpack()
      )),
      BuiltinOptions::LocalResponseNormalizationOptions => BuiltinOptionsT::LocalResponseNormalizationOptions(Box::new(
        self.builtin_options_as_local_response_normalization_options()
            .expect("Invalid union table, expected `BuiltinOptions::LocalResponseNormalizationOptions`.")
            .unpack()
      )),
      BuiltinOptions::LSTMOptions => BuiltinOptionsT::LSTMOptions(Box::new(
        self.builtin_options_as_lstmoptions()
            .expect("Invalid union table, expected `BuiltinOptions::LSTMOptions`.")
            .unpack()
      )),
      BuiltinOptions::ResizeBilinearOptions => BuiltinOptionsT::ResizeBilinearOptions(Box::new(
        self.builtin_options_as_resize_bilinear_options()
            .expect("Invalid union table, expected `BuiltinOptions::ResizeBilinearOptions`.")
            .unpack()
      )),
      BuiltinOptions::CallOptions => BuiltinOptionsT::CallOptions(Box::new(
        self.builtin_options_as_call_options()
            .expect("Invalid union table, expected `BuiltinOptions::CallOptions`.")
            .unpack()
      )),
      BuiltinOptions::ReshapeOptions => BuiltinOptionsT::ReshapeOptions(Box::new(
        self.builtin_options_as_reshape_options()
            .expect("Invalid union table, expected `BuiltinOptions::ReshapeOptions`.")
            .unpack()
      )),
      BuiltinOptions::SkipGramOptions => BuiltinOptionsT::SkipGramOptions(Box::new(
        self.builtin_options_as_skip_gram_options()
            .expect("Invalid union table, expected `BuiltinOptions::SkipGramOptions`.")
            .unpack()
      )),
      BuiltinOptions::SpaceToDepthOptions => BuiltinOptionsT::SpaceToDepthOptions(Box::new(
        self.builtin_options_as_space_to_depth_options()
            .expect("Invalid union table, expected `BuiltinOptions::SpaceToDepthOptions`.")
            .unpack()
      )),
      BuiltinOptions::EmbeddingLookupSparseOptions => BuiltinOptionsT::EmbeddingLookupSparseOptions(Box::new(
        self.builtin_options_as_embedding_lookup_sparse_options()
            .expect("Invalid union table, expected `BuiltinOptions::EmbeddingLookupSparseOptions`.")
            .unpack()
      )),
      BuiltinOptions::MulOptions => BuiltinOptionsT::MulOptions(Box::new(
        self.builtin_options_as_mul_options()
            .expect("Invalid union table, expected `BuiltinOptions::MulOptions`.")
            .unpack()
      )),
      BuiltinOptions::PadOptions => BuiltinOptionsT::PadOptions(Box::new(
        self.builtin_options_as_pad_options()
            .expect("Invalid union table, expected `BuiltinOptions::PadOptions`.")
            .unpack()
      )),
      BuiltinOptions::GatherOptions => BuiltinOptionsT::GatherOptions(Box::new(
        self.builtin_options_as_gather_options()
            .expect("Invalid union table, expected `BuiltinOptions::GatherOptions`.")
            .unpack()
      )),
      BuiltinOptions::BatchToSpaceNDOptions => BuiltinOptionsT::BatchToSpaceNDOptions(Box::new(
        self.builtin_options_as_batch_to_space_ndoptions()
            .expect("Invalid union table, expected `BuiltinOptions::BatchToSpaceNDOptions`.")
            .unpack()
      )),
      BuiltinOptions::SpaceToBatchNDOptions => BuiltinOptionsT::SpaceToBatchNDOptions(Box::new(
        self.builtin_options_as_space_to_batch_ndoptions()
            .expect("Invalid union table, expected `BuiltinOptions::SpaceToBatchNDOptions`.")
            .unpack()
      )),
      BuiltinOptions::TransposeOptions => BuiltinOptionsT::TransposeOptions(Box::new(
        self.builtin_options_as_transpose_options()
            .expect("Invalid union table, expected `BuiltinOptions::TransposeOptions`.")
            .unpack()
      )),
      BuiltinOptions::ReducerOptions => BuiltinOptionsT::ReducerOptions(Box::new(
        self.builtin_options_as_reducer_options()
            .expect("Invalid union table, expected `BuiltinOptions::ReducerOptions`.")
            .unpack()
      )),
      BuiltinOptions::SubOptions => BuiltinOptionsT::SubOptions(Box::new(
        self.builtin_options_as_sub_options()
            .expect("Invalid union table, expected `BuiltinOptions::SubOptions`.")
            .unpack()
      )),
      BuiltinOptions::DivOptions => BuiltinOptionsT::DivOptions(Box::new(
        self.builtin_options_as_div_options()
            .expect("Invalid union table, expected `BuiltinOptions::DivOptions`.")
            .unpack()
      )),
      BuiltinOptions::SqueezeOptions => BuiltinOptionsT::SqueezeOptions(Box::new(
        self.builtin_options_as_squeeze_options()
            .expect("Invalid union table, expected `BuiltinOptions::SqueezeOptions`.")
            .unpack()
      )),
      BuiltinOptions::SequenceRNNOptions => BuiltinOptionsT::SequenceRNNOptions(Box::new(
        self.builtin_options_as_sequence_rnnoptions()
            .expect("Invalid union table, expected `BuiltinOptions::SequenceRNNOptions`.")
            .unpack()
      )),
      BuiltinOptions::StridedSliceOptions => BuiltinOptionsT::StridedSliceOptions(Box::new(
        self.builtin_options_as_strided_slice_options()
            .expect("Invalid union table, expected `BuiltinOptions::StridedSliceOptions`.")
            .unpack()
      )),
      BuiltinOptions::ExpOptions => BuiltinOptionsT::ExpOptions(Box::new(
        self.builtin_options_as_exp_options()
            .expect("Invalid union table, expected `BuiltinOptions::ExpOptions`.")
            .unpack()
      )),
      BuiltinOptions::TopKV2Options => BuiltinOptionsT::TopKV2Options(Box::new(
        self.builtin_options_as_top_kv2_options()
            .expect("Invalid union table, expected `BuiltinOptions::TopKV2Options`.")
            .unpack()
      )),
      BuiltinOptions::SplitOptions => BuiltinOptionsT::SplitOptions(Box::new(
        self.builtin_options_as_split_options()
            .expect("Invalid union table, expected `BuiltinOptions::SplitOptions`.")
            .unpack()
      )),
      BuiltinOptions::LogSoftmaxOptions => BuiltinOptionsT::LogSoftmaxOptions(Box::new(
        self.builtin_options_as_log_softmax_options()
            .expect("Invalid union table, expected `BuiltinOptions::LogSoftmaxOptions`.")
            .unpack()
      )),
      BuiltinOptions::CastOptions => BuiltinOptionsT::CastOptions(Box::new(
        self.builtin_options_as_cast_options()
            .expect("Invalid union table, expected `BuiltinOptions::CastOptions`.")
            .unpack()
      )),
      BuiltinOptions::DequantizeOptions => BuiltinOptionsT::DequantizeOptions(Box::new(
        self.builtin_options_as_dequantize_options()
            .expect("Invalid union table, expected `BuiltinOptions::DequantizeOptions`.")
            .unpack()
      )),
      BuiltinOptions::MaximumMinimumOptions => BuiltinOptionsT::MaximumMinimumOptions(Box::new(
        self.builtin_options_as_maximum_minimum_options()
            .expect("Invalid union table, expected `BuiltinOptions::MaximumMinimumOptions`.")
            .unpack()
      )),
      BuiltinOptions::ArgMaxOptions => BuiltinOptionsT::ArgMaxOptions(Box::new(
        self.builtin_options_as_arg_max_options()
            .expect("Invalid union table, expected `BuiltinOptions::ArgMaxOptions`.")
            .unpack()
      )),
      BuiltinOptions::LessOptions => BuiltinOptionsT::LessOptions(Box::new(
        self.builtin_options_as_less_options()
            .expect("Invalid union table, expected `BuiltinOptions::LessOptions`.")
            .unpack()
      )),
      BuiltinOptions::NegOptions => BuiltinOptionsT::NegOptions(Box::new(
        self.builtin_options_as_neg_options()
            .expect("Invalid union table, expected `BuiltinOptions::NegOptions`.")
            .unpack()
      )),
      BuiltinOptions::PadV2Options => BuiltinOptionsT::PadV2Options(Box::new(
        self.builtin_options_as_pad_v2_options()
            .expect("Invalid union table, expected `BuiltinOptions::PadV2Options`.")
            .unpack()
      )),
      BuiltinOptions::GreaterOptions => BuiltinOptionsT::GreaterOptions(Box::new(
        self.builtin_options_as_greater_options()
            .expect("Invalid union table, expected `BuiltinOptions::GreaterOptions`.")
            .unpack()
      )),
      BuiltinOptions::GreaterEqualOptions => BuiltinOptionsT::GreaterEqualOptions(Box::new(
        self.builtin_options_as_greater_equal_options()
            .expect("Invalid union table, expected `BuiltinOptions::GreaterEqualOptions`.")
            .unpack()
      )),
      BuiltinOptions::LessEqualOptions => BuiltinOptionsT::LessEqualOptions(Box::new(
        self.builtin_options_as_less_equal_options()
            .expect("Invalid union table, expected `BuiltinOptions::LessEqualOptions`.")
            .unpack()
      )),
      BuiltinOptions::SelectOptions => BuiltinOptionsT::SelectOptions(Box::new(
        self.builtin_options_as_select_options()
            .expect("Invalid union table, expected `BuiltinOptions::SelectOptions`.")
            .unpack()
      )),
      BuiltinOptions::SliceOptions => BuiltinOptionsT::SliceOptions(Box::new(
        self.builtin_options_as_slice_options()
            .expect("Invalid union table, expected `BuiltinOptions::SliceOptions`.")
            .unpack()
      )),
      BuiltinOptions::TransposeConvOptions => BuiltinOptionsT::TransposeConvOptions(Box::new(
        self.builtin_options_as_transpose_conv_options()
            .expect("Invalid union table, expected `BuiltinOptions::TransposeConvOptions`.")
            .unpack()
      )),
      BuiltinOptions::SparseToDenseOptions => BuiltinOptionsT::SparseToDenseOptions(Box::new(
        self.builtin_options_as_sparse_to_dense_options()
            .expect("Invalid union table, expected `BuiltinOptions::SparseToDenseOptions`.")
            .unpack()
      )),
      BuiltinOptions::TileOptions => BuiltinOptionsT::TileOptions(Box::new(
        self.builtin_options_as_tile_options()
            .expect("Invalid union table, expected `BuiltinOptions::TileOptions`.")
            .unpack()
      )),
      BuiltinOptions::ExpandDimsOptions => BuiltinOptionsT::ExpandDimsOptions(Box::new(
        self.builtin_options_as_expand_dims_options()
            .expect("Invalid union table, expected `BuiltinOptions::ExpandDimsOptions`.")
            .unpack()
      )),
      BuiltinOptions::EqualOptions => BuiltinOptionsT::EqualOptions(Box::new(
        self.builtin_options_as_equal_options()
            .expect("Invalid union table, expected `BuiltinOptions::EqualOptions`.")
            .unpack()
      )),
      BuiltinOptions::NotEqualOptions => BuiltinOptionsT::NotEqualOptions(Box::new(
        self.builtin_options_as_not_equal_options()
            .expect("Invalid union table, expected `BuiltinOptions::NotEqualOptions`.")
            .unpack()
      )),
      BuiltinOptions::ShapeOptions => BuiltinOptionsT::ShapeOptions(Box::new(
        self.builtin_options_as_shape_options()
            .expect("Invalid union table, expected `BuiltinOptions::ShapeOptions`.")
            .unpack()
      )),
      BuiltinOptions::PowOptions => BuiltinOptionsT::PowOptions(Box::new(
        self.builtin_options_as_pow_options()
            .expect("Invalid union table, expected `BuiltinOptions::PowOptions`.")
            .unpack()
      )),
      BuiltinOptions::ArgMinOptions => BuiltinOptionsT::ArgMinOptions(Box::new(
        self.builtin_options_as_arg_min_options()
            .expect("Invalid union table, expected `BuiltinOptions::ArgMinOptions`.")
            .unpack()
      )),
      BuiltinOptions::FakeQuantOptions => BuiltinOptionsT::FakeQuantOptions(Box::new(
        self.builtin_options_as_fake_quant_options()
            .expect("Invalid union table, expected `BuiltinOptions::FakeQuantOptions`.")
            .unpack()
      )),
      BuiltinOptions::PackOptions => BuiltinOptionsT::PackOptions(Box::new(
        self.builtin_options_as_pack_options()
            .expect("Invalid union table, expected `BuiltinOptions::PackOptions`.")
            .unpack()
      )),
      BuiltinOptions::LogicalOrOptions => BuiltinOptionsT::LogicalOrOptions(Box::new(
        self.builtin_options_as_logical_or_options()
            .expect("Invalid union table, expected `BuiltinOptions::LogicalOrOptions`.")
            .unpack()
      )),
      BuiltinOptions::OneHotOptions => BuiltinOptionsT::OneHotOptions(Box::new(
        self.builtin_options_as_one_hot_options()
            .expect("Invalid union table, expected `BuiltinOptions::OneHotOptions`.")
            .unpack()
      )),
      BuiltinOptions::LogicalAndOptions => BuiltinOptionsT::LogicalAndOptions(Box::new(
        self.builtin_options_as_logical_and_options()
            .expect("Invalid union table, expected `BuiltinOptions::LogicalAndOptions`.")
            .unpack()
      )),
      BuiltinOptions::LogicalNotOptions => BuiltinOptionsT::LogicalNotOptions(Box::new(
        self.builtin_options_as_logical_not_options()
            .expect("Invalid union table, expected `BuiltinOptions::LogicalNotOptions`.")
            .unpack()
      )),
      BuiltinOptions::UnpackOptions => BuiltinOptionsT::UnpackOptions(Box::new(
        self.builtin_options_as_unpack_options()
            .expect("Invalid union table, expected `BuiltinOptions::UnpackOptions`.")
            .unpack()
      )),
      BuiltinOptions::FloorDivOptions => BuiltinOptionsT::FloorDivOptions(Box::new(
        self.builtin_options_as_floor_div_options()
            .expect("Invalid union table, expected `BuiltinOptions::FloorDivOptions`.")
            .unpack()
      )),
      BuiltinOptions::SquareOptions => BuiltinOptionsT::SquareOptions(Box::new(
        self.builtin_options_as_square_options()
            .expect("Invalid union table, expected `BuiltinOptions::SquareOptions`.")
            .unpack()
      )),
      BuiltinOptions::ZerosLikeOptions => BuiltinOptionsT::ZerosLikeOptions(Box::new(
        self.builtin_options_as_zeros_like_options()
            .expect("Invalid union table, expected `BuiltinOptions::ZerosLikeOptions`.")
            .unpack()
      )),
      BuiltinOptions::FillOptions => BuiltinOptionsT::FillOptions(Box::new(
        self.builtin_options_as_fill_options()
            .expect("Invalid union table, expected `BuiltinOptions::FillOptions`.")
            .unpack()
      )),
      BuiltinOptions::BidirectionalSequenceLSTMOptions => BuiltinOptionsT::BidirectionalSequenceLSTMOptions(Box::new(
        self.builtin_options_as_bidirectional_sequence_lstmoptions()
            .expect("Invalid union table, expected `BuiltinOptions::BidirectionalSequenceLSTMOptions`.")
            .unpack()
      )),
      BuiltinOptions::BidirectionalSequenceRNNOptions => BuiltinOptionsT::BidirectionalSequenceRNNOptions(Box::new(
        self.builtin_options_as_bidirectional_sequence_rnnoptions()
            .expect("Invalid union table, expected `BuiltinOptions::BidirectionalSequenceRNNOptions`.")
            .unpack()
      )),
      BuiltinOptions::UnidirectionalSequenceLSTMOptions => BuiltinOptionsT::UnidirectionalSequenceLSTMOptions(Box::new(
        self.builtin_options_as_unidirectional_sequence_lstmoptions()
            .expect("Invalid union table, expected `BuiltinOptions::UnidirectionalSequenceLSTMOptions`.")
            .unpack()
      )),
      BuiltinOptions::FloorModOptions => BuiltinOptionsT::FloorModOptions(Box::new(
        self.builtin_options_as_floor_mod_options()
            .expect("Invalid union table, expected `BuiltinOptions::FloorModOptions`.")
            .unpack()
      )),
      BuiltinOptions::RangeOptions => BuiltinOptionsT::RangeOptions(Box::new(
        self.builtin_options_as_range_options()
            .expect("Invalid union table, expected `BuiltinOptions::RangeOptions`.")
            .unpack()
      )),
      BuiltinOptions::ResizeNearestNeighborOptions => BuiltinOptionsT::ResizeNearestNeighborOptions(Box::new(
        self.builtin_options_as_resize_nearest_neighbor_options()
            .expect("Invalid union table, expected `BuiltinOptions::ResizeNearestNeighborOptions`.")
            .unpack()
      )),
      BuiltinOptions::LeakyReluOptions => BuiltinOptionsT::LeakyReluOptions(Box::new(
        self.builtin_options_as_leaky_relu_options()
            .expect("Invalid union table, expected `BuiltinOptions::LeakyReluOptions`.")
            .unpack()
      )),
      BuiltinOptions::SquaredDifferenceOptions => BuiltinOptionsT::SquaredDifferenceOptions(Box::new(
        self.builtin_options_as_squared_difference_options()
            .expect("Invalid union table, expected `BuiltinOptions::SquaredDifferenceOptions`.")
            .unpack()
      )),
      BuiltinOptions::MirrorPadOptions => BuiltinOptionsT::MirrorPadOptions(Box::new(
        self.builtin_options_as_mirror_pad_options()
            .expect("Invalid union table, expected `BuiltinOptions::MirrorPadOptions`.")
            .unpack()
      )),
      BuiltinOptions::AbsOptions => BuiltinOptionsT::AbsOptions(Box::new(
        self.builtin_options_as_abs_options()
            .expect("Invalid union table, expected `BuiltinOptions::AbsOptions`.")
            .unpack()
      )),
      BuiltinOptions::SplitVOptions => BuiltinOptionsT::SplitVOptions(Box::new(
        self.builtin_options_as_split_voptions()
            .expect("Invalid union table, expected `BuiltinOptions::SplitVOptions`.")
            .unpack()
      )),
      BuiltinOptions::UniqueOptions => BuiltinOptionsT::UniqueOptions(Box::new(
        self.builtin_options_as_unique_options()
            .expect("Invalid union table, expected `BuiltinOptions::UniqueOptions`.")
            .unpack()
      )),
      BuiltinOptions::ReverseV2Options => BuiltinOptionsT::ReverseV2Options(Box::new(
        self.builtin_options_as_reverse_v2_options()
            .expect("Invalid union table, expected `BuiltinOptions::ReverseV2Options`.")
            .unpack()
      )),
      BuiltinOptions::AddNOptions => BuiltinOptionsT::AddNOptions(Box::new(
        self.builtin_options_as_add_noptions()
            .expect("Invalid union table, expected `BuiltinOptions::AddNOptions`.")
            .unpack()
      )),
      BuiltinOptions::GatherNdOptions => BuiltinOptionsT::GatherNdOptions(Box::new(
        self.builtin_options_as_gather_nd_options()
            .expect("Invalid union table, expected `BuiltinOptions::GatherNdOptions`.")
            .unpack()
      )),
      BuiltinOptions::CosOptions => BuiltinOptionsT::CosOptions(Box::new(
        self.builtin_options_as_cos_options()
            .expect("Invalid union table, expected `BuiltinOptions::CosOptions`.")
            .unpack()
      )),
      BuiltinOptions::WhereOptions => BuiltinOptionsT::WhereOptions(Box::new(
        self.builtin_options_as_where_options()
            .expect("Invalid union table, expected `BuiltinOptions::WhereOptions`.")
            .unpack()
      )),
      BuiltinOptions::RankOptions => BuiltinOptionsT::RankOptions(Box::new(
        self.builtin_options_as_rank_options()
            .expect("Invalid union table, expected `BuiltinOptions::RankOptions`.")
            .unpack()
      )),
      BuiltinOptions::ReverseSequenceOptions => BuiltinOptionsT::ReverseSequenceOptions(Box::new(
        self.builtin_options_as_reverse_sequence_options()
            .expect("Invalid union table, expected `BuiltinOptions::ReverseSequenceOptions`.")
            .unpack()
      )),
      BuiltinOptions::MatrixDiagOptions => BuiltinOptionsT::MatrixDiagOptions(Box::new(
        self.builtin_options_as_matrix_diag_options()
            .expect("Invalid union table, expected `BuiltinOptions::MatrixDiagOptions`.")
            .unpack()
      )),
      BuiltinOptions::QuantizeOptions => BuiltinOptionsT::QuantizeOptions(Box::new(
        self.builtin_options_as_quantize_options()
            .expect("Invalid union table, expected `BuiltinOptions::QuantizeOptions`.")
            .unpack()
      )),
      BuiltinOptions::MatrixSetDiagOptions => BuiltinOptionsT::MatrixSetDiagOptions(Box::new(
        self.builtin_options_as_matrix_set_diag_options()
            .expect("Invalid union table, expected `BuiltinOptions::MatrixSetDiagOptions`.")
            .unpack()
      )),
      BuiltinOptions::HardSwishOptions => BuiltinOptionsT::HardSwishOptions(Box::new(
        self.builtin_options_as_hard_swish_options()
            .expect("Invalid union table, expected `BuiltinOptions::HardSwishOptions`.")
            .unpack()
      )),
      BuiltinOptions::IfOptions => BuiltinOptionsT::IfOptions(Box::new(
        self.builtin_options_as_if_options()
            .expect("Invalid union table, expected `BuiltinOptions::IfOptions`.")
            .unpack()
      )),
      BuiltinOptions::WhileOptions => BuiltinOptionsT::WhileOptions(Box::new(
        self.builtin_options_as_while_options()
            .expect("Invalid union table, expected `BuiltinOptions::WhileOptions`.")
            .unpack()
      )),
      BuiltinOptions::DepthToSpaceOptions => BuiltinOptionsT::DepthToSpaceOptions(Box::new(
        self.builtin_options_as_depth_to_space_options()
            .expect("Invalid union table, expected `BuiltinOptions::DepthToSpaceOptions`.")
            .unpack()
      )),
      BuiltinOptions::NonMaxSuppressionV4Options => BuiltinOptionsT::NonMaxSuppressionV4Options(Box::new(
        self.builtin_options_as_non_max_suppression_v4_options()
            .expect("Invalid union table, expected `BuiltinOptions::NonMaxSuppressionV4Options`.")
            .unpack()
      )),
      BuiltinOptions::NonMaxSuppressionV5Options => BuiltinOptionsT::NonMaxSuppressionV5Options(Box::new(
        self.builtin_options_as_non_max_suppression_v5_options()
            .expect("Invalid union table, expected `BuiltinOptions::NonMaxSuppressionV5Options`.")
            .unpack()
      )),
      BuiltinOptions::ScatterNdOptions => BuiltinOptionsT::ScatterNdOptions(Box::new(
        self.builtin_options_as_scatter_nd_options()
            .expect("Invalid union table, expected `BuiltinOptions::ScatterNdOptions`.")
            .unpack()
      )),
      _ => BuiltinOptionsT::NONE,
    };
    let custom_options = self.custom_options().map(|x| {
      x.to_vec()
    });
    let custom_options_format = self.custom_options_format();
    let mutating_variable_inputs = self.mutating_variable_inputs().map(|x| {
      x.to_vec()
    });
    let intermediates = self.intermediates().map(|x| {
      x.into_iter().collect()
    });
    OperatorT {
      opcode_index,
      inputs,
      outputs,
      builtin_options,
      custom_options,
      custom_options_format,
      mutating_variable_inputs,
      intermediates,
    }
  }

  #[inline]
  pub fn opcode_index(&self) -> u32 {
    self._tab.get::<u32>(Operator::VT_OPCODE_INDEX, Some(0)).unwrap()
  }
  #[inline]
  pub fn inputs(&self) -> Option<flatbuffers::Vector<'a, i32>> {
    self._tab.get::<flatbuffers::ForwardsUOffset<flatbuffers::Vector<'a, i32>>>(Operator::VT_INPUTS, None)
  }
  #[inline]
  pub fn outputs(&self) -> Option<flatbuffers::Vector<'a, i32>> {
    self._tab.get::<flatbuffers::ForwardsUOffset<flatbuffers::Vector<'a, i32>>>(Operator::VT_OUTPUTS, None)
  }
  #[inline]
  pub fn builtin_options_type(&self) -> BuiltinOptions {
    self._tab.get::<BuiltinOptions>(Operator::VT_BUILTIN_OPTIONS_TYPE, Some(BuiltinOptions::NONE)).unwrap()
  }
  #[inline]
  pub fn builtin_options(&self) -> Option<flatbuffers::Table<'a>> {
    self._tab.get::<flatbuffers::ForwardsUOffset<flatbuffers::Table<'a>>>(Operator::VT_BUILTIN_OPTIONS, None)
  }
  #[inline]
  pub fn custom_options(&self) -> Option<&'a [u8]> {
    self._tab.get::<flatbuffers::ForwardsUOffset<flatbuffers::Vector<'a, u8>>>(Operator::VT_CUSTOM_OPTIONS, None).map(|v| v.safe_slice())
  }
  #[inline]
  pub fn custom_options_format(&self) -> CustomOptionsFormat {
    self._tab.get::<CustomOptionsFormat>(Operator::VT_CUSTOM_OPTIONS_FORMAT, Some(CustomOptionsFormat::FLEXBUFFERS)).unwrap()
  }
  #[inline]
  pub fn mutating_variable_inputs(&self) -> Option<&'a [bool]> {
    self._tab.get::<flatbuffers::ForwardsUOffset<flatbuffers::Vector<'a, bool>>>(Operator::VT_MUTATING_VARIABLE_INPUTS, None).map(|v| v.safe_slice())
  }
  #[inline]
  pub fn intermediates(&self) -> Option<flatbuffers::Vector<'a, i32>> {
    self._tab.get::<flatbuffers::ForwardsUOffset<flatbuffers::Vector<'a, i32>>>(Operator::VT_INTERMEDIATES, None)
  }
  #[inline]
  #[allow(non_snake_case)]
  pub fn builtin_options_as_conv_2_doptions(&self) -> Option<Conv2DOptions<'a>> {
    if self.builtin_options_type() == BuiltinOptions::Conv2DOptions {
      self.builtin_options().map(Conv2DOptions::init_from_table)
    } else {
      None
    }
  }

  #[inline]
  #[allow(non_snake_case)]
  pub fn builtin_options_as_depthwise_conv_2_doptions(&self) -> Option<DepthwiseConv2DOptions<'a>> {
    if self.builtin_options_type() == BuiltinOptions::DepthwiseConv2DOptions {
      self.builtin_options().map(DepthwiseConv2DOptions::init_from_table)
    } else {
      None
    }
  }

  #[inline]
  #[allow(non_snake_case)]
  pub fn builtin_options_as_concat_embeddings_options(&self) -> Option<ConcatEmbeddingsOptions<'a>> {
    if self.builtin_options_type() == BuiltinOptions::ConcatEmbeddingsOptions {
      self.builtin_options().map(ConcatEmbeddingsOptions::init_from_table)
    } else {
      None
    }
  }

  #[inline]
  #[allow(non_snake_case)]
  pub fn builtin_options_as_lshprojection_options(&self) -> Option<LSHProjectionOptions<'a>> {
    if self.builtin_options_type() == BuiltinOptions::LSHProjectionOptions {
      self.builtin_options().map(LSHProjectionOptions::init_from_table)
    } else {
      None
    }
  }

  #[inline]
  #[allow(non_snake_case)]
  pub fn builtin_options_as_pool_2_doptions(&self) -> Option<Pool2DOptions<'a>> {
    if self.builtin_options_type() == BuiltinOptions::Pool2DOptions {
      self.builtin_options().map(Pool2DOptions::init_from_table)
    } else {
      None
    }
  }

  #[inline]
  #[allow(non_snake_case)]
  pub fn builtin_options_as_svdfoptions(&self) -> Option<SVDFOptions<'a>> {
    if self.builtin_options_type() == BuiltinOptions::SVDFOptions {
      self.builtin_options().map(SVDFOptions::init_from_table)
    } else {
      None
    }
  }

  #[inline]
  #[allow(non_snake_case)]
  pub fn builtin_options_as_rnnoptions(&self) -> Option<RNNOptions<'a>> {
    if self.builtin_options_type() == BuiltinOptions::RNNOptions {
      self.builtin_options().map(RNNOptions::init_from_table)
    } else {
      None
    }
  }

  #[inline]
  #[allow(non_snake_case)]
  pub fn builtin_options_as_fully_connected_options(&self) -> Option<FullyConnectedOptions<'a>> {
    if self.builtin_options_type() == BuiltinOptions::FullyConnectedOptions {
      self.builtin_options().map(FullyConnectedOptions::init_from_table)
    } else {
      None
    }
  }

  #[inline]
  #[allow(non_snake_case)]
  pub fn builtin_options_as_softmax_options(&self) -> Option<SoftmaxOptions<'a>> {
    if self.builtin_options_type() == BuiltinOptions::SoftmaxOptions {
      self.builtin_options().map(SoftmaxOptions::init_from_table)
    } else {
      None
    }
  }

  #[inline]
  #[allow(non_snake_case)]
  pub fn builtin_options_as_concatenation_options(&self) -> Option<ConcatenationOptions<'a>> {
    if self.builtin_options_type() == BuiltinOptions::ConcatenationOptions {
      self.builtin_options().map(ConcatenationOptions::init_from_table)
    } else {
      None
    }
  }

  #[inline]
  #[allow(non_snake_case)]
  pub fn builtin_options_as_add_options(&self) -> Option<AddOptions<'a>> {
    if self.builtin_options_type() == BuiltinOptions::AddOptions {
      self.builtin_options().map(AddOptions::init_from_table)
    } else {
      None
    }
  }

  #[inline]
  #[allow(non_snake_case)]
  pub fn builtin_options_as_l2_norm_options(&self) -> Option<L2NormOptions<'a>> {
    if self.builtin_options_type() == BuiltinOptions::L2NormOptions {
      self.builtin_options().map(L2NormOptions::init_from_table)
    } else {
      None
    }
  }

  #[inline]
  #[allow(non_snake_case)]
  pub fn builtin_options_as_local_response_normalization_options(&self) -> Option<LocalResponseNormalizationOptions<'a>> {
    if self.builtin_options_type() == BuiltinOptions::LocalResponseNormalizationOptions {
      self.builtin_options().map(LocalResponseNormalizationOptions::init_from_table)
    } else {
      None
    }
  }

  #[inline]
  #[allow(non_snake_case)]
  pub fn builtin_options_as_lstmoptions(&self) -> Option<LSTMOptions<'a>> {
    if self.builtin_options_type() == BuiltinOptions::LSTMOptions {
      self.builtin_options().map(LSTMOptions::init_from_table)
    } else {
      None
    }
  }

  #[inline]
  #[allow(non_snake_case)]
  pub fn builtin_options_as_resize_bilinear_options(&self) -> Option<ResizeBilinearOptions<'a>> {
    if self.builtin_options_type() == BuiltinOptions::ResizeBilinearOptions {
      self.builtin_options().map(ResizeBilinearOptions::init_from_table)
    } else {
      None
    }
  }

  #[inline]
  #[allow(non_snake_case)]
  pub fn builtin_options_as_call_options(&self) -> Option<CallOptions<'a>> {
    if self.builtin_options_type() == BuiltinOptions::CallOptions {
      self.builtin_options().map(CallOptions::init_from_table)
    } else {
      None
    }
  }

  #[inline]
  #[allow(non_snake_case)]
  pub fn builtin_options_as_reshape_options(&self) -> Option<ReshapeOptions<'a>> {
    if self.builtin_options_type() == BuiltinOptions::ReshapeOptions {
      self.builtin_options().map(ReshapeOptions::init_from_table)
    } else {
      None
    }
  }

  #[inline]
  #[allow(non_snake_case)]
  pub fn builtin_options_as_skip_gram_options(&self) -> Option<SkipGramOptions<'a>> {
    if self.builtin_options_type() == BuiltinOptions::SkipGramOptions {
      self.builtin_options().map(SkipGramOptions::init_from_table)
    } else {
      None
    }
  }

  #[inline]
  #[allow(non_snake_case)]
  pub fn builtin_options_as_space_to_depth_options(&self) -> Option<SpaceToDepthOptions<'a>> {
    if self.builtin_options_type() == BuiltinOptions::SpaceToDepthOptions {
      self.builtin_options().map(SpaceToDepthOptions::init_from_table)
    } else {
      None
    }
  }

  #[inline]
  #[allow(non_snake_case)]
  pub fn builtin_options_as_embedding_lookup_sparse_options(&self) -> Option<EmbeddingLookupSparseOptions<'a>> {
    if self.builtin_options_type() == BuiltinOptions::EmbeddingLookupSparseOptions {
      self.builtin_options().map(EmbeddingLookupSparseOptions::init_from_table)
    } else {
      None
    }
  }

  #[inline]
  #[allow(non_snake_case)]
  pub fn builtin_options_as_mul_options(&self) -> Option<MulOptions<'a>> {
    if self.builtin_options_type() == BuiltinOptions::MulOptions {
      self.builtin_options().map(MulOptions::init_from_table)
    } else {
      None
    }
  }

  #[inline]
  #[allow(non_snake_case)]
  pub fn builtin_options_as_pad_options(&self) -> Option<PadOptions<'a>> {
    if self.builtin_options_type() == BuiltinOptions::PadOptions {
      self.builtin_options().map(PadOptions::init_from_table)
    } else {
      None
    }
  }

  #[inline]
  #[allow(non_snake_case)]
  pub fn builtin_options_as_gather_options(&self) -> Option<GatherOptions<'a>> {
    if self.builtin_options_type() == BuiltinOptions::GatherOptions {
      self.builtin_options().map(GatherOptions::init_from_table)
    } else {
      None
    }
  }

  #[inline]
  #[allow(non_snake_case)]
  pub fn builtin_options_as_batch_to_space_ndoptions(&self) -> Option<BatchToSpaceNDOptions<'a>> {
    if self.builtin_options_type() == BuiltinOptions::BatchToSpaceNDOptions {
      self.builtin_options().map(BatchToSpaceNDOptions::init_from_table)
    } else {
      None
    }
  }

  #[inline]
  #[allow(non_snake_case)]
  pub fn builtin_options_as_space_to_batch_ndoptions(&self) -> Option<SpaceToBatchNDOptions<'a>> {
    if self.builtin_options_type() == BuiltinOptions::SpaceToBatchNDOptions {
      self.builtin_options().map(SpaceToBatchNDOptions::init_from_table)
    } else {
      None
    }
  }

  #[inline]
  #[allow(non_snake_case)]
  pub fn builtin_options_as_transpose_options(&self) -> Option<TransposeOptions<'a>> {
    if self.builtin_options_type() == BuiltinOptions::TransposeOptions {
      self.builtin_options().map(TransposeOptions::init_from_table)
    } else {
      None
    }
  }

  #[inline]
  #[allow(non_snake_case)]
  pub fn builtin_options_as_reducer_options(&self) -> Option<ReducerOptions<'a>> {
    if self.builtin_options_type() == BuiltinOptions::ReducerOptions {
      self.builtin_options().map(ReducerOptions::init_from_table)
    } else {
      None
    }
  }

  #[inline]
  #[allow(non_snake_case)]
  pub fn builtin_options_as_sub_options(&self) -> Option<SubOptions<'a>> {
    if self.builtin_options_type() == BuiltinOptions::SubOptions {
      self.builtin_options().map(SubOptions::init_from_table)
    } else {
      None
    }
  }

  #[inline]
  #[allow(non_snake_case)]
  pub fn builtin_options_as_div_options(&self) -> Option<DivOptions<'a>> {
    if self.builtin_options_type() == BuiltinOptions::DivOptions {
      self.builtin_options().map(DivOptions::init_from_table)
    } else {
      None
    }
  }

  #[inline]
  #[allow(non_snake_case)]
  pub fn builtin_options_as_squeeze_options(&self) -> Option<SqueezeOptions<'a>> {
    if self.builtin_options_type() == BuiltinOptions::SqueezeOptions {
      self.builtin_options().map(SqueezeOptions::init_from_table)
    } else {
      None
    }
  }

  #[inline]
  #[allow(non_snake_case)]
  pub fn builtin_options_as_sequence_rnnoptions(&self) -> Option<SequenceRNNOptions<'a>> {
    if self.builtin_options_type() == BuiltinOptions::SequenceRNNOptions {
      self.builtin_options().map(SequenceRNNOptions::init_from_table)
    } else {
      None
    }
  }

  #[inline]
  #[allow(non_snake_case)]
  pub fn builtin_options_as_strided_slice_options(&self) -> Option<StridedSliceOptions<'a>> {
    if self.builtin_options_type() == BuiltinOptions::StridedSliceOptions {
      self.builtin_options().map(StridedSliceOptions::init_from_table)
    } else {
      None
    }
  }

  #[inline]
  #[allow(non_snake_case)]
  pub fn builtin_options_as_exp_options(&self) -> Option<ExpOptions<'a>> {
    if self.builtin_options_type() == BuiltinOptions::ExpOptions {
      self.builtin_options().map(ExpOptions::init_from_table)
    } else {
      None
    }
  }

  #[inline]
  #[allow(non_snake_case)]
  pub fn builtin_options_as_top_kv2_options(&self) -> Option<TopKV2Options<'a>> {
    if self.builtin_options_type() == BuiltinOptions::TopKV2Options {
      self.builtin_options().map(TopKV2Options::init_from_table)
    } else {
      None
    }
  }

  #[inline]
  #[allow(non_snake_case)]
  pub fn builtin_options_as_split_options(&self) -> Option<SplitOptions<'a>> {
    if self.builtin_options_type() == BuiltinOptions::SplitOptions {
      self.builtin_options().map(SplitOptions::init_from_table)
    } else {
      None
    }
  }

  #[inline]
  #[allow(non_snake_case)]
  pub fn builtin_options_as_log_softmax_options(&self) -> Option<LogSoftmaxOptions<'a>> {
    if self.builtin_options_type() == BuiltinOptions::LogSoftmaxOptions {
      self.builtin_options().map(LogSoftmaxOptions::init_from_table)
    } else {
      None
    }
  }

  #[inline]
  #[allow(non_snake_case)]
  pub fn builtin_options_as_cast_options(&self) -> Option<CastOptions<'a>> {
    if self.builtin_options_type() == BuiltinOptions::CastOptions {
      self.builtin_options().map(CastOptions::init_from_table)
    } else {
      None
    }
  }

  #[inline]
  #[allow(non_snake_case)]
  pub fn builtin_options_as_dequantize_options(&self) -> Option<DequantizeOptions<'a>> {
    if self.builtin_options_type() == BuiltinOptions::DequantizeOptions {
      self.builtin_options().map(DequantizeOptions::init_from_table)
    } else {
      None
    }
  }

  #[inline]
  #[allow(non_snake_case)]
  pub fn builtin_options_as_maximum_minimum_options(&self) -> Option<MaximumMinimumOptions<'a>> {
    if self.builtin_options_type() == BuiltinOptions::MaximumMinimumOptions {
      self.builtin_options().map(MaximumMinimumOptions::init_from_table)
    } else {
      None
    }
  }

  #[inline]
  #[allow(non_snake_case)]
  pub fn builtin_options_as_arg_max_options(&self) -> Option<ArgMaxOptions<'a>> {
    if self.builtin_options_type() == BuiltinOptions::ArgMaxOptions {
      self.builtin_options().map(ArgMaxOptions::init_from_table)
    } else {
      None
    }
  }

  #[inline]
  #[allow(non_snake_case)]
  pub fn builtin_options_as_less_options(&self) -> Option<LessOptions<'a>> {
    if self.builtin_options_type() == BuiltinOptions::LessOptions {
      self.builtin_options().map(LessOptions::init_from_table)
    } else {
      None
    }
  }

  #[inline]
  #[allow(non_snake_case)]
  pub fn builtin_options_as_neg_options(&self) -> Option<NegOptions<'a>> {
    if self.builtin_options_type() == BuiltinOptions::NegOptions {
      self.builtin_options().map(NegOptions::init_from_table)
    } else {
      None
    }
  }

  #[inline]
  #[allow(non_snake_case)]
  pub fn builtin_options_as_pad_v2_options(&self) -> Option<PadV2Options<'a>> {
    if self.builtin_options_type() == BuiltinOptions::PadV2Options {
      self.builtin_options().map(PadV2Options::init_from_table)
    } else {
      None
    }
  }

  #[inline]
  #[allow(non_snake_case)]
  pub fn builtin_options_as_greater_options(&self) -> Option<GreaterOptions<'a>> {
    if self.builtin_options_type() == BuiltinOptions::GreaterOptions {
      self.builtin_options().map(GreaterOptions::init_from_table)
    } else {
      None
    }
  }

  #[inline]
  #[allow(non_snake_case)]
  pub fn builtin_options_as_greater_equal_options(&self) -> Option<GreaterEqualOptions<'a>> {
    if self.builtin_options_type() == BuiltinOptions::GreaterEqualOptions {
      self.builtin_options().map(GreaterEqualOptions::init_from_table)
    } else {
      None
    }
  }

  #[inline]
  #[allow(non_snake_case)]
  pub fn builtin_options_as_less_equal_options(&self) -> Option<LessEqualOptions<'a>> {
    if self.builtin_options_type() == BuiltinOptions::LessEqualOptions {
      self.builtin_options().map(LessEqualOptions::init_from_table)
    } else {
      None
    }
  }

  #[inline]
  #[allow(non_snake_case)]
  pub fn builtin_options_as_select_options(&self) -> Option<SelectOptions<'a>> {
    if self.builtin_options_type() == BuiltinOptions::SelectOptions {
      self.builtin_options().map(SelectOptions::init_from_table)
    } else {
      None
    }
  }

  #[inline]
  #[allow(non_snake_case)]
  pub fn builtin_options_as_slice_options(&self) -> Option<SliceOptions<'a>> {
    if self.builtin_options_type() == BuiltinOptions::SliceOptions {
      self.builtin_options().map(SliceOptions::init_from_table)
    } else {
      None
    }
  }

  #[inline]
  #[allow(non_snake_case)]
  pub fn builtin_options_as_transpose_conv_options(&self) -> Option<TransposeConvOptions<'a>> {
    if self.builtin_options_type() == BuiltinOptions::TransposeConvOptions {
      self.builtin_options().map(TransposeConvOptions::init_from_table)
    } else {
      None
    }
  }

  #[inline]
  #[allow(non_snake_case)]
  pub fn builtin_options_as_sparse_to_dense_options(&self) -> Option<SparseToDenseOptions<'a>> {
    if self.builtin_options_type() == BuiltinOptions::SparseToDenseOptions {
      self.builtin_options().map(SparseToDenseOptions::init_from_table)
    } else {
      None
    }
  }

  #[inline]
  #[allow(non_snake_case)]
  pub fn builtin_options_as_tile_options(&self) -> Option<TileOptions<'a>> {
    if self.builtin_options_type() == BuiltinOptions::TileOptions {
      self.builtin_options().map(TileOptions::init_from_table)
    } else {
      None
    }
  }

  #[inline]
  #[allow(non_snake_case)]
  pub fn builtin_options_as_expand_dims_options(&self) -> Option<ExpandDimsOptions<'a>> {
    if self.builtin_options_type() == BuiltinOptions::ExpandDimsOptions {
      self.builtin_options().map(ExpandDimsOptions::init_from_table)
    } else {
      None
    }
  }

  #[inline]
  #[allow(non_snake_case)]
  pub fn builtin_options_as_equal_options(&self) -> Option<EqualOptions<'a>> {
    if self.builtin_options_type() == BuiltinOptions::EqualOptions {
      self.builtin_options().map(EqualOptions::init_from_table)
    } else {
      None
    }
  }

  #[inline]
  #[allow(non_snake_case)]
  pub fn builtin_options_as_not_equal_options(&self) -> Option<NotEqualOptions<'a>> {
    if self.builtin_options_type() == BuiltinOptions::NotEqualOptions {
      self.builtin_options().map(NotEqualOptions::init_from_table)
    } else {
      None
    }
  }

  #[inline]
  #[allow(non_snake_case)]
  pub fn builtin_options_as_shape_options(&self) -> Option<ShapeOptions<'a>> {
    if self.builtin_options_type() == BuiltinOptions::ShapeOptions {
      self.builtin_options().map(ShapeOptions::init_from_table)
    } else {
      None
    }
  }

  #[inline]
  #[allow(non_snake_case)]
  pub fn builtin_options_as_pow_options(&self) -> Option<PowOptions<'a>> {
    if self.builtin_options_type() == BuiltinOptions::PowOptions {
      self.builtin_options().map(PowOptions::init_from_table)
    } else {
      None
    }
  }

  #[inline]
  #[allow(non_snake_case)]
  pub fn builtin_options_as_arg_min_options(&self) -> Option<ArgMinOptions<'a>> {
    if self.builtin_options_type() == BuiltinOptions::ArgMinOptions {
      self.builtin_options().map(ArgMinOptions::init_from_table)
    } else {
      None
    }
  }

  #[inline]
  #[allow(non_snake_case)]
  pub fn builtin_options_as_fake_quant_options(&self) -> Option<FakeQuantOptions<'a>> {
    if self.builtin_options_type() == BuiltinOptions::FakeQuantOptions {
      self.builtin_options().map(FakeQuantOptions::init_from_table)
    } else {
      None
    }
  }

  #[inline]
  #[allow(non_snake_case)]
  pub fn builtin_options_as_pack_options(&self) -> Option<PackOptions<'a>> {
    if self.builtin_options_type() == BuiltinOptions::PackOptions {
      self.builtin_options().map(PackOptions::init_from_table)
    } else {
      None
    }
  }

  #[inline]
  #[allow(non_snake_case)]
  pub fn builtin_options_as_logical_or_options(&self) -> Option<LogicalOrOptions<'a>> {
    if self.builtin_options_type() == BuiltinOptions::LogicalOrOptions {
      self.builtin_options().map(LogicalOrOptions::init_from_table)
    } else {
      None
    }
  }

  #[inline]
  #[allow(non_snake_case)]
  pub fn builtin_options_as_one_hot_options(&self) -> Option<OneHotOptions<'a>> {
    if self.builtin_options_type() == BuiltinOptions::OneHotOptions {
      self.builtin_options().map(OneHotOptions::init_from_table)
    } else {
      None
    }
  }

  #[inline]
  #[allow(non_snake_case)]
  pub fn builtin_options_as_logical_and_options(&self) -> Option<LogicalAndOptions<'a>> {
    if self.builtin_options_type() == BuiltinOptions::LogicalAndOptions {
      self.builtin_options().map(LogicalAndOptions::init_from_table)
    } else {
      None
    }
  }

  #[inline]
  #[allow(non_snake_case)]
  pub fn builtin_options_as_logical_not_options(&self) -> Option<LogicalNotOptions<'a>> {
    if self.builtin_options_type() == BuiltinOptions::LogicalNotOptions {
      self.builtin_options().map(LogicalNotOptions::init_from_table)
    } else {
      None
    }
  }

  #[inline]
  #[allow(non_snake_case)]
  pub fn builtin_options_as_unpack_options(&self) -> Option<UnpackOptions<'a>> {
    if self.builtin_options_type() == BuiltinOptions::UnpackOptions {
      self.builtin_options().map(UnpackOptions::init_from_table)
    } else {
      None
    }
  }

  #[inline]
  #[allow(non_snake_case)]
  pub fn builtin_options_as_floor_div_options(&self) -> Option<FloorDivOptions<'a>> {
    if self.builtin_options_type() == BuiltinOptions::FloorDivOptions {
      self.builtin_options().map(FloorDivOptions::init_from_table)
    } else {
      None
    }
  }

  #[inline]
  #[allow(non_snake_case)]
  pub fn builtin_options_as_square_options(&self) -> Option<SquareOptions<'a>> {
    if self.builtin_options_type() == BuiltinOptions::SquareOptions {
      self.builtin_options().map(SquareOptions::init_from_table)
    } else {
      None
    }
  }

  #[inline]
  #[allow(non_snake_case)]
  pub fn builtin_options_as_zeros_like_options(&self) -> Option<ZerosLikeOptions<'a>> {
    if self.builtin_options_type() == BuiltinOptions::ZerosLikeOptions {
      self.builtin_options().map(ZerosLikeOptions::init_from_table)
    } else {
      None
    }
  }

  #[inline]
  #[allow(non_snake_case)]
  pub fn builtin_options_as_fill_options(&self) -> Option<FillOptions<'a>> {
    if self.builtin_options_type() == BuiltinOptions::FillOptions {
      self.builtin_options().map(FillOptions::init_from_table)
    } else {
      None
    }
  }

  #[inline]
  #[allow(non_snake_case)]
  pub fn builtin_options_as_bidirectional_sequence_lstmoptions(&self) -> Option<BidirectionalSequenceLSTMOptions<'a>> {
    if self.builtin_options_type() == BuiltinOptions::BidirectionalSequenceLSTMOptions {
      self.builtin_options().map(BidirectionalSequenceLSTMOptions::init_from_table)
    } else {
      None
    }
  }

  #[inline]
  #[allow(non_snake_case)]
  pub fn builtin_options_as_bidirectional_sequence_rnnoptions(&self) -> Option<BidirectionalSequenceRNNOptions<'a>> {
    if self.builtin_options_type() == BuiltinOptions::BidirectionalSequenceRNNOptions {
      self.builtin_options().map(BidirectionalSequenceRNNOptions::init_from_table)
    } else {
      None
    }
  }

  #[inline]
  #[allow(non_snake_case)]
  pub fn builtin_options_as_unidirectional_sequence_lstmoptions(&self) -> Option<UnidirectionalSequenceLSTMOptions<'a>> {
    if self.builtin_options_type() == BuiltinOptions::UnidirectionalSequenceLSTMOptions {
      self.builtin_options().map(UnidirectionalSequenceLSTMOptions::init_from_table)
    } else {
      None
    }
  }

  #[inline]
  #[allow(non_snake_case)]
  pub fn builtin_options_as_floor_mod_options(&self) -> Option<FloorModOptions<'a>> {
    if self.builtin_options_type() == BuiltinOptions::FloorModOptions {
      self.builtin_options().map(FloorModOptions::init_from_table)
    } else {
      None
    }
  }

  #[inline]
  #[allow(non_snake_case)]
  pub fn builtin_options_as_range_options(&self) -> Option<RangeOptions<'a>> {
    if self.builtin_options_type() == BuiltinOptions::RangeOptions {
      self.builtin_options().map(RangeOptions::init_from_table)
    } else {
      None
    }
  }

  #[inline]
  #[allow(non_snake_case)]
  pub fn builtin_options_as_resize_nearest_neighbor_options(&self) -> Option<ResizeNearestNeighborOptions<'a>> {
    if self.builtin_options_type() == BuiltinOptions::ResizeNearestNeighborOptions {
      self.builtin_options().map(ResizeNearestNeighborOptions::init_from_table)
    } else {
      None
    }
  }

  #[inline]
  #[allow(non_snake_case)]
  pub fn builtin_options_as_leaky_relu_options(&self) -> Option<LeakyReluOptions<'a>> {
    if self.builtin_options_type() == BuiltinOptions::LeakyReluOptions {
      self.builtin_options().map(LeakyReluOptions::init_from_table)
    } else {
      None
    }
  }

  #[inline]
  #[allow(non_snake_case)]
  pub fn builtin_options_as_squared_difference_options(&self) -> Option<SquaredDifferenceOptions<'a>> {
    if self.builtin_options_type() == BuiltinOptions::SquaredDifferenceOptions {
      self.builtin_options().map(SquaredDifferenceOptions::init_from_table)
    } else {
      None
    }
  }

  #[inline]
  #[allow(non_snake_case)]
  pub fn builtin_options_as_mirror_pad_options(&self) -> Option<MirrorPadOptions<'a>> {
    if self.builtin_options_type() == BuiltinOptions::MirrorPadOptions {
      self.builtin_options().map(MirrorPadOptions::init_from_table)
    } else {
      None
    }
  }

  #[inline]
  #[allow(non_snake_case)]
  pub fn builtin_options_as_abs_options(&self) -> Option<AbsOptions<'a>> {
    if self.builtin_options_type() == BuiltinOptions::AbsOptions {
      self.builtin_options().map(AbsOptions::init_from_table)
    } else {
      None
    }
  }

  #[inline]
  #[allow(non_snake_case)]
  pub fn builtin_options_as_split_voptions(&self) -> Option<SplitVOptions<'a>> {
    if self.builtin_options_type() == BuiltinOptions::SplitVOptions {
      self.builtin_options().map(SplitVOptions::init_from_table)
    } else {
      None
    }
  }

  #[inline]
  #[allow(non_snake_case)]
  pub fn builtin_options_as_unique_options(&self) -> Option<UniqueOptions<'a>> {
    if self.builtin_options_type() == BuiltinOptions::UniqueOptions {
      self.builtin_options().map(UniqueOptions::init_from_table)
    } else {
      None
    }
  }

  #[inline]
  #[allow(non_snake_case)]
  pub fn builtin_options_as_reverse_v2_options(&self) -> Option<ReverseV2Options<'a>> {
    if self.builtin_options_type() == BuiltinOptions::ReverseV2Options {
      self.builtin_options().map(ReverseV2Options::init_from_table)
    } else {
      None
    }
  }

  #[inline]
  #[allow(non_snake_case)]
  pub fn builtin_options_as_add_noptions(&self) -> Option<AddNOptions<'a>> {
    if self.builtin_options_type() == BuiltinOptions::AddNOptions {
      self.builtin_options().map(AddNOptions::init_from_table)
    } else {
      None
    }
  }

  #[inline]
  #[allow(non_snake_case)]
  pub fn builtin_options_as_gather_nd_options(&self) -> Option<GatherNdOptions<'a>> {
    if self.builtin_options_type() == BuiltinOptions::GatherNdOptions {
      self.builtin_options().map(GatherNdOptions::init_from_table)
    } else {
      None
    }
  }

  #[inline]
  #[allow(non_snake_case)]
  pub fn builtin_options_as_cos_options(&self) -> Option<CosOptions<'a>> {
    if self.builtin_options_type() == BuiltinOptions::CosOptions {
      self.builtin_options().map(CosOptions::init_from_table)
    } else {
      None
    }
  }

  #[inline]
  #[allow(non_snake_case)]
  pub fn builtin_options_as_where_options(&self) -> Option<WhereOptions<'a>> {
    if self.builtin_options_type() == BuiltinOptions::WhereOptions {
      self.builtin_options().map(WhereOptions::init_from_table)
    } else {
      None
    }
  }

  #[inline]
  #[allow(non_snake_case)]
  pub fn builtin_options_as_rank_options(&self) -> Option<RankOptions<'a>> {
    if self.builtin_options_type() == BuiltinOptions::RankOptions {
      self.builtin_options().map(RankOptions::init_from_table)
    } else {
      None
    }
  }

  #[inline]
  #[allow(non_snake_case)]
  pub fn builtin_options_as_reverse_sequence_options(&self) -> Option<ReverseSequenceOptions<'a>> {
    if self.builtin_options_type() == BuiltinOptions::ReverseSequenceOptions {
      self.builtin_options().map(ReverseSequenceOptions::init_from_table)
    } else {
      None
    }
  }

  #[inline]
  #[allow(non_snake_case)]
  pub fn builtin_options_as_matrix_diag_options(&self) -> Option<MatrixDiagOptions<'a>> {
    if self.builtin_options_type() == BuiltinOptions::MatrixDiagOptions {
      self.builtin_options().map(MatrixDiagOptions::init_from_table)
    } else {
      None
    }
  }

  #[inline]
  #[allow(non_snake_case)]
  pub fn builtin_options_as_quantize_options(&self) -> Option<QuantizeOptions<'a>> {
    if self.builtin_options_type() == BuiltinOptions::QuantizeOptions {
      self.builtin_options().map(QuantizeOptions::init_from_table)
    } else {
      None
    }
  }

  #[inline]
  #[allow(non_snake_case)]
  pub fn builtin_options_as_matrix_set_diag_options(&self) -> Option<MatrixSetDiagOptions<'a>> {
    if self.builtin_options_type() == BuiltinOptions::MatrixSetDiagOptions {
      self.builtin_options().map(MatrixSetDiagOptions::init_from_table)
    } else {
      None
    }
  }

  #[inline]
  #[allow(non_snake_case)]
  pub fn builtin_options_as_hard_swish_options(&self) -> Option<HardSwishOptions<'a>> {
    if self.builtin_options_type() == BuiltinOptions::HardSwishOptions {
      self.builtin_options().map(HardSwishOptions::init_from_table)
    } else {
      None
    }
  }

  #[inline]
  #[allow(non_snake_case)]
  pub fn builtin_options_as_if_options(&self) -> Option<IfOptions<'a>> {
    if self.builtin_options_type() == BuiltinOptions::IfOptions {
      self.builtin_options().map(IfOptions::init_from_table)
    } else {
      None
    }
  }

  #[inline]
  #[allow(non_snake_case)]
  pub fn builtin_options_as_while_options(&self) -> Option<WhileOptions<'a>> {
    if self.builtin_options_type() == BuiltinOptions::WhileOptions {
      self.builtin_options().map(WhileOptions::init_from_table)
    } else {
      None
    }
  }

  #[inline]
  #[allow(non_snake_case)]
  pub fn builtin_options_as_depth_to_space_options(&self) -> Option<DepthToSpaceOptions<'a>> {
    if self.builtin_options_type() == BuiltinOptions::DepthToSpaceOptions {
      self.builtin_options().map(DepthToSpaceOptions::init_from_table)
    } else {
      None
    }
  }

  #[inline]
  #[allow(non_snake_case)]
  pub fn builtin_options_as_non_max_suppression_v4_options(&self) -> Option<NonMaxSuppressionV4Options<'a>> {
    if self.builtin_options_type() == BuiltinOptions::NonMaxSuppressionV4Options {
      self.builtin_options().map(NonMaxSuppressionV4Options::init_from_table)
    } else {
      None
    }
  }

  #[inline]
  #[allow(non_snake_case)]
  pub fn builtin_options_as_non_max_suppression_v5_options(&self) -> Option<NonMaxSuppressionV5Options<'a>> {
    if self.builtin_options_type() == BuiltinOptions::NonMaxSuppressionV5Options {
      self.builtin_options().map(NonMaxSuppressionV5Options::init_from_table)
    } else {
      None
    }
  }

  #[inline]
  #[allow(non_snake_case)]
  pub fn builtin_options_as_scatter_nd_options(&self) -> Option<ScatterNdOptions<'a>> {
    if self.builtin_options_type() == BuiltinOptions::ScatterNdOptions {
      self.builtin_options().map(ScatterNdOptions::init_from_table)
    } else {
      None
    }
  }

}

impl flatbuffers::Verifiable for Operator<'_> {
  #[inline]
  fn run_verifier(
    v: &mut flatbuffers::Verifier, pos: usize
  ) -> Result<(), flatbuffers::InvalidFlatbuffer> {
    use self::flatbuffers::Verifiable;
    v.visit_table(pos)?
     .visit_field::<u32>("opcode_index", Self::VT_OPCODE_INDEX, false)?
     .visit_field::<flatbuffers::ForwardsUOffset<flatbuffers::Vector<'_, i32>>>("inputs", Self::VT_INPUTS, false)?
     .visit_field::<flatbuffers::ForwardsUOffset<flatbuffers::Vector<'_, i32>>>("outputs", Self::VT_OUTPUTS, false)?
     .visit_union::<BuiltinOptions, _>("builtin_options_type", Self::VT_BUILTIN_OPTIONS_TYPE, "builtin_options", Self::VT_BUILTIN_OPTIONS, false, |key, v, pos| {
        match key {
          BuiltinOptions::Conv2DOptions => v.verify_union_variant::<flatbuffers::ForwardsUOffset<Conv2DOptions>>("BuiltinOptions::Conv2DOptions", pos),
          BuiltinOptions::DepthwiseConv2DOptions => v.verify_union_variant::<flatbuffers::ForwardsUOffset<DepthwiseConv2DOptions>>("BuiltinOptions::DepthwiseConv2DOptions", pos),
          BuiltinOptions::ConcatEmbeddingsOptions => v.verify_union_variant::<flatbuffers::ForwardsUOffset<ConcatEmbeddingsOptions>>("BuiltinOptions::ConcatEmbeddingsOptions", pos),
          BuiltinOptions::LSHProjectionOptions => v.verify_union_variant::<flatbuffers::ForwardsUOffset<LSHProjectionOptions>>("BuiltinOptions::LSHProjectionOptions", pos),
          BuiltinOptions::Pool2DOptions => v.verify_union_variant::<flatbuffers::ForwardsUOffset<Pool2DOptions>>("BuiltinOptions::Pool2DOptions", pos),
          BuiltinOptions::SVDFOptions => v.verify_union_variant::<flatbuffers::ForwardsUOffset<SVDFOptions>>("BuiltinOptions::SVDFOptions", pos),
          BuiltinOptions::RNNOptions => v.verify_union_variant::<flatbuffers::ForwardsUOffset<RNNOptions>>("BuiltinOptions::RNNOptions", pos),
          BuiltinOptions::FullyConnectedOptions => v.verify_union_variant::<flatbuffers::ForwardsUOffset<FullyConnectedOptions>>("BuiltinOptions::FullyConnectedOptions", pos),
          BuiltinOptions::SoftmaxOptions => v.verify_union_variant::<flatbuffers::ForwardsUOffset<SoftmaxOptions>>("BuiltinOptions::SoftmaxOptions", pos),
          BuiltinOptions::ConcatenationOptions => v.verify_union_variant::<flatbuffers::ForwardsUOffset<ConcatenationOptions>>("BuiltinOptions::ConcatenationOptions", pos),
          BuiltinOptions::AddOptions => v.verify_union_variant::<flatbuffers::ForwardsUOffset<AddOptions>>("BuiltinOptions::AddOptions", pos),
          BuiltinOptions::L2NormOptions => v.verify_union_variant::<flatbuffers::ForwardsUOffset<L2NormOptions>>("BuiltinOptions::L2NormOptions", pos),
          BuiltinOptions::LocalResponseNormalizationOptions => v.verify_union_variant::<flatbuffers::ForwardsUOffset<LocalResponseNormalizationOptions>>("BuiltinOptions::LocalResponseNormalizationOptions", pos),
          BuiltinOptions::LSTMOptions => v.verify_union_variant::<flatbuffers::ForwardsUOffset<LSTMOptions>>("BuiltinOptions::LSTMOptions", pos),
          BuiltinOptions::ResizeBilinearOptions => v.verify_union_variant::<flatbuffers::ForwardsUOffset<ResizeBilinearOptions>>("BuiltinOptions::ResizeBilinearOptions", pos),
          BuiltinOptions::CallOptions => v.verify_union_variant::<flatbuffers::ForwardsUOffset<CallOptions>>("BuiltinOptions::CallOptions", pos),
          BuiltinOptions::ReshapeOptions => v.verify_union_variant::<flatbuffers::ForwardsUOffset<ReshapeOptions>>("BuiltinOptions::ReshapeOptions", pos),
          BuiltinOptions::SkipGramOptions => v.verify_union_variant::<flatbuffers::ForwardsUOffset<SkipGramOptions>>("BuiltinOptions::SkipGramOptions", pos),
          BuiltinOptions::SpaceToDepthOptions => v.verify_union_variant::<flatbuffers::ForwardsUOffset<SpaceToDepthOptions>>("BuiltinOptions::SpaceToDepthOptions", pos),
          BuiltinOptions::EmbeddingLookupSparseOptions => v.verify_union_variant::<flatbuffers::ForwardsUOffset<EmbeddingLookupSparseOptions>>("BuiltinOptions::EmbeddingLookupSparseOptions", pos),
          BuiltinOptions::MulOptions => v.verify_union_variant::<flatbuffers::ForwardsUOffset<MulOptions>>("BuiltinOptions::MulOptions", pos),
          BuiltinOptions::PadOptions => v.verify_union_variant::<flatbuffers::ForwardsUOffset<PadOptions>>("BuiltinOptions::PadOptions", pos),
          BuiltinOptions::GatherOptions => v.verify_union_variant::<flatbuffers::ForwardsUOffset<GatherOptions>>("BuiltinOptions::GatherOptions", pos),
          BuiltinOptions::BatchToSpaceNDOptions => v.verify_union_variant::<flatbuffers::ForwardsUOffset<BatchToSpaceNDOptions>>("BuiltinOptions::BatchToSpaceNDOptions", pos),
          BuiltinOptions::SpaceToBatchNDOptions => v.verify_union_variant::<flatbuffers::ForwardsUOffset<SpaceToBatchNDOptions>>("BuiltinOptions::SpaceToBatchNDOptions", pos),
          BuiltinOptions::TransposeOptions => v.verify_union_variant::<flatbuffers::ForwardsUOffset<TransposeOptions>>("BuiltinOptions::TransposeOptions", pos),
          BuiltinOptions::ReducerOptions => v.verify_union_variant::<flatbuffers::ForwardsUOffset<ReducerOptions>>("BuiltinOptions::ReducerOptions", pos),
          BuiltinOptions::SubOptions => v.verify_union_variant::<flatbuffers::ForwardsUOffset<SubOptions>>("BuiltinOptions::SubOptions", pos),
          BuiltinOptions::DivOptions => v.verify_union_variant::<flatbuffers::ForwardsUOffset<DivOptions>>("BuiltinOptions::DivOptions", pos),
          BuiltinOptions::SqueezeOptions => v.verify_union_variant::<flatbuffers::ForwardsUOffset<SqueezeOptions>>("BuiltinOptions::SqueezeOptions", pos),
          BuiltinOptions::SequenceRNNOptions => v.verify_union_variant::<flatbuffers::ForwardsUOffset<SequenceRNNOptions>>("BuiltinOptions::SequenceRNNOptions", pos),
          BuiltinOptions::StridedSliceOptions => v.verify_union_variant::<flatbuffers::ForwardsUOffset<StridedSliceOptions>>("BuiltinOptions::StridedSliceOptions", pos),
          BuiltinOptions::ExpOptions => v.verify_union_variant::<flatbuffers::ForwardsUOffset<ExpOptions>>("BuiltinOptions::ExpOptions", pos),
          BuiltinOptions::TopKV2Options => v.verify_union_variant::<flatbuffers::ForwardsUOffset<TopKV2Options>>("BuiltinOptions::TopKV2Options", pos),
          BuiltinOptions::SplitOptions => v.verify_union_variant::<flatbuffers::ForwardsUOffset<SplitOptions>>("BuiltinOptions::SplitOptions", pos),
          BuiltinOptions::LogSoftmaxOptions => v.verify_union_variant::<flatbuffers::ForwardsUOffset<LogSoftmaxOptions>>("BuiltinOptions::LogSoftmaxOptions", pos),
          BuiltinOptions::CastOptions => v.verify_union_variant::<flatbuffers::ForwardsUOffset<CastOptions>>("BuiltinOptions::CastOptions", pos),
          BuiltinOptions::DequantizeOptions => v.verify_union_variant::<flatbuffers::ForwardsUOffset<DequantizeOptions>>("BuiltinOptions::DequantizeOptions", pos),
          BuiltinOptions::MaximumMinimumOptions => v.verify_union_variant::<flatbuffers::ForwardsUOffset<MaximumMinimumOptions>>("BuiltinOptions::MaximumMinimumOptions", pos),
          BuiltinOptions::ArgMaxOptions => v.verify_union_variant::<flatbuffers::ForwardsUOffset<ArgMaxOptions>>("BuiltinOptions::ArgMaxOptions", pos),
          BuiltinOptions::LessOptions => v.verify_union_variant::<flatbuffers::ForwardsUOffset<LessOptions>>("BuiltinOptions::LessOptions", pos),
          BuiltinOptions::NegOptions => v.verify_union_variant::<flatbuffers::ForwardsUOffset<NegOptions>>("BuiltinOptions::NegOptions", pos),
          BuiltinOptions::PadV2Options => v.verify_union_variant::<flatbuffers::ForwardsUOffset<PadV2Options>>("BuiltinOptions::PadV2Options", pos),
          BuiltinOptions::GreaterOptions => v.verify_union_variant::<flatbuffers::ForwardsUOffset<GreaterOptions>>("BuiltinOptions::GreaterOptions", pos),
          BuiltinOptions::GreaterEqualOptions => v.verify_union_variant::<flatbuffers::ForwardsUOffset<GreaterEqualOptions>>("BuiltinOptions::GreaterEqualOptions", pos),
          BuiltinOptions::LessEqualOptions => v.verify_union_variant::<flatbuffers::ForwardsUOffset<LessEqualOptions>>("BuiltinOptions::LessEqualOptions", pos),
          BuiltinOptions::SelectOptions => v.verify_union_variant::<flatbuffers::ForwardsUOffset<SelectOptions>>("BuiltinOptions::SelectOptions", pos),
          BuiltinOptions::SliceOptions => v.verify_union_variant::<flatbuffers::ForwardsUOffset<SliceOptions>>("BuiltinOptions::SliceOptions", pos),
          BuiltinOptions::TransposeConvOptions => v.verify_union_variant::<flatbuffers::ForwardsUOffset<TransposeConvOptions>>("BuiltinOptions::TransposeConvOptions", pos),
          BuiltinOptions::SparseToDenseOptions => v.verify_union_variant::<flatbuffers::ForwardsUOffset<SparseToDenseOptions>>("BuiltinOptions::SparseToDenseOptions", pos),
          BuiltinOptions::TileOptions => v.verify_union_variant::<flatbuffers::ForwardsUOffset<TileOptions>>("BuiltinOptions::TileOptions", pos),
          BuiltinOptions::ExpandDimsOptions => v.verify_union_variant::<flatbuffers::ForwardsUOffset<ExpandDimsOptions>>("BuiltinOptions::ExpandDimsOptions", pos),
          BuiltinOptions::EqualOptions => v.verify_union_variant::<flatbuffers::ForwardsUOffset<EqualOptions>>("BuiltinOptions::EqualOptions", pos),
          BuiltinOptions::NotEqualOptions => v.verify_union_variant::<flatbuffers::ForwardsUOffset<NotEqualOptions>>("BuiltinOptions::NotEqualOptions", pos),
          BuiltinOptions::ShapeOptions => v.verify_union_variant::<flatbuffers::ForwardsUOffset<ShapeOptions>>("BuiltinOptions::ShapeOptions", pos),
          BuiltinOptions::PowOptions => v.verify_union_variant::<flatbuffers::ForwardsUOffset<PowOptions>>("BuiltinOptions::PowOptions", pos),
          BuiltinOptions::ArgMinOptions => v.verify_union_variant::<flatbuffers::ForwardsUOffset<ArgMinOptions>>("BuiltinOptions::ArgMinOptions", pos),
          BuiltinOptions::FakeQuantOptions => v.verify_union_variant::<flatbuffers::ForwardsUOffset<FakeQuantOptions>>("BuiltinOptions::FakeQuantOptions", pos),
          BuiltinOptions::PackOptions => v.verify_union_variant::<flatbuffers::ForwardsUOffset<PackOptions>>("BuiltinOptions::PackOptions", pos),
          BuiltinOptions::LogicalOrOptions => v.verify_union_variant::<flatbuffers::ForwardsUOffset<LogicalOrOptions>>("BuiltinOptions::LogicalOrOptions", pos),
          BuiltinOptions::OneHotOptions => v.verify_union_variant::<flatbuffers::ForwardsUOffset<OneHotOptions>>("BuiltinOptions::OneHotOptions", pos),
          BuiltinOptions::LogicalAndOptions => v.verify_union_variant::<flatbuffers::ForwardsUOffset<LogicalAndOptions>>("BuiltinOptions::LogicalAndOptions", pos),
          BuiltinOptions::LogicalNotOptions => v.verify_union_variant::<flatbuffers::ForwardsUOffset<LogicalNotOptions>>("BuiltinOptions::LogicalNotOptions", pos),
          BuiltinOptions::UnpackOptions => v.verify_union_variant::<flatbuffers::ForwardsUOffset<UnpackOptions>>("BuiltinOptions::UnpackOptions", pos),
          BuiltinOptions::FloorDivOptions => v.verify_union_variant::<flatbuffers::ForwardsUOffset<FloorDivOptions>>("BuiltinOptions::FloorDivOptions", pos),
          BuiltinOptions::SquareOptions => v.verify_union_variant::<flatbuffers::ForwardsUOffset<SquareOptions>>("BuiltinOptions::SquareOptions", pos),
          BuiltinOptions::ZerosLikeOptions => v.verify_union_variant::<flatbuffers::ForwardsUOffset<ZerosLikeOptions>>("BuiltinOptions::ZerosLikeOptions", pos),
          BuiltinOptions::FillOptions => v.verify_union_variant::<flatbuffers::ForwardsUOffset<FillOptions>>("BuiltinOptions::FillOptions", pos),
          BuiltinOptions::BidirectionalSequenceLSTMOptions => v.verify_union_variant::<flatbuffers::ForwardsUOffset<BidirectionalSequenceLSTMOptions>>("BuiltinOptions::BidirectionalSequenceLSTMOptions", pos),
          BuiltinOptions::BidirectionalSequenceRNNOptions => v.verify_union_variant::<flatbuffers::ForwardsUOffset<BidirectionalSequenceRNNOptions>>("BuiltinOptions::BidirectionalSequenceRNNOptions", pos),
          BuiltinOptions::UnidirectionalSequenceLSTMOptions => v.verify_union_variant::<flatbuffers::ForwardsUOffset<UnidirectionalSequenceLSTMOptions>>("BuiltinOptions::UnidirectionalSequenceLSTMOptions", pos),
          BuiltinOptions::FloorModOptions => v.verify_union_variant::<flatbuffers::ForwardsUOffset<FloorModOptions>>("BuiltinOptions::FloorModOptions", pos),
          BuiltinOptions::RangeOptions => v.verify_union_variant::<flatbuffers::ForwardsUOffset<RangeOptions>>("BuiltinOptions::RangeOptions", pos),
          BuiltinOptions::ResizeNearestNeighborOptions => v.verify_union_variant::<flatbuffers::ForwardsUOffset<ResizeNearestNeighborOptions>>("BuiltinOptions::ResizeNearestNeighborOptions", pos),
          BuiltinOptions::LeakyReluOptions => v.verify_union_variant::<flatbuffers::ForwardsUOffset<LeakyReluOptions>>("BuiltinOptions::LeakyReluOptions", pos),
          BuiltinOptions::SquaredDifferenceOptions => v.verify_union_variant::<flatbuffers::ForwardsUOffset<SquaredDifferenceOptions>>("BuiltinOptions::SquaredDifferenceOptions", pos),
          BuiltinOptions::MirrorPadOptions => v.verify_union_variant::<flatbuffers::ForwardsUOffset<MirrorPadOptions>>("BuiltinOptions::MirrorPadOptions", pos),
          BuiltinOptions::AbsOptions => v.verify_union_variant::<flatbuffers::ForwardsUOffset<AbsOptions>>("BuiltinOptions::AbsOptions", pos),
          BuiltinOptions::SplitVOptions => v.verify_union_variant::<flatbuffers::ForwardsUOffset<SplitVOptions>>("BuiltinOptions::SplitVOptions", pos),
          BuiltinOptions::UniqueOptions => v.verify_union_variant::<flatbuffers::ForwardsUOffset<UniqueOptions>>("BuiltinOptions::UniqueOptions", pos),
          BuiltinOptions::ReverseV2Options => v.verify_union_variant::<flatbuffers::ForwardsUOffset<ReverseV2Options>>("BuiltinOptions::ReverseV2Options", pos),
          BuiltinOptions::AddNOptions => v.verify_union_variant::<flatbuffers::ForwardsUOffset<AddNOptions>>("BuiltinOptions::AddNOptions", pos),
          BuiltinOptions::GatherNdOptions => v.verify_union_variant::<flatbuffers::ForwardsUOffset<GatherNdOptions>>("BuiltinOptions::GatherNdOptions", pos),
          BuiltinOptions::CosOptions => v.verify_union_variant::<flatbuffers::ForwardsUOffset<CosOptions>>("BuiltinOptions::CosOptions", pos),
          BuiltinOptions::WhereOptions => v.verify_union_variant::<flatbuffers::ForwardsUOffset<WhereOptions>>("BuiltinOptions::WhereOptions", pos),
          BuiltinOptions::RankOptions => v.verify_union_variant::<flatbuffers::ForwardsUOffset<RankOptions>>("BuiltinOptions::RankOptions", pos),
          BuiltinOptions::ReverseSequenceOptions => v.verify_union_variant::<flatbuffers::ForwardsUOffset<ReverseSequenceOptions>>("BuiltinOptions::ReverseSequenceOptions", pos),
          BuiltinOptions::MatrixDiagOptions => v.verify_union_variant::<flatbuffers::ForwardsUOffset<MatrixDiagOptions>>("BuiltinOptions::MatrixDiagOptions", pos),
          BuiltinOptions::QuantizeOptions => v.verify_union_variant::<flatbuffers::ForwardsUOffset<QuantizeOptions>>("BuiltinOptions::QuantizeOptions", pos),
          BuiltinOptions::MatrixSetDiagOptions => v.verify_union_variant::<flatbuffers::ForwardsUOffset<MatrixSetDiagOptions>>("BuiltinOptions::MatrixSetDiagOptions", pos),
          BuiltinOptions::HardSwishOptions => v.verify_union_variant::<flatbuffers::ForwardsUOffset<HardSwishOptions>>("BuiltinOptions::HardSwishOptions", pos),
          BuiltinOptions::IfOptions => v.verify_union_variant::<flatbuffers::ForwardsUOffset<IfOptions>>("BuiltinOptions::IfOptions", pos),
          BuiltinOptions::WhileOptions => v.verify_union_variant::<flatbuffers::ForwardsUOffset<WhileOptions>>("BuiltinOptions::WhileOptions", pos),
          BuiltinOptions::DepthToSpaceOptions => v.verify_union_variant::<flatbuffers::ForwardsUOffset<DepthToSpaceOptions>>("BuiltinOptions::DepthToSpaceOptions", pos),
          BuiltinOptions::NonMaxSuppressionV4Options => v.verify_union_variant::<flatbuffers::ForwardsUOffset<NonMaxSuppressionV4Options>>("BuiltinOptions::NonMaxSuppressionV4Options", pos),
          BuiltinOptions::NonMaxSuppressionV5Options => v.verify_union_variant::<flatbuffers::ForwardsUOffset<NonMaxSuppressionV5Options>>("BuiltinOptions::NonMaxSuppressionV5Options", pos),
          BuiltinOptions::ScatterNdOptions => v.verify_union_variant::<flatbuffers::ForwardsUOffset<ScatterNdOptions>>("BuiltinOptions::ScatterNdOptions", pos),
          _ => Ok(()),
        }
     })?
     .visit_field::<flatbuffers::ForwardsUOffset<flatbuffers::Vector<'_, u8>>>("custom_options", Self::VT_CUSTOM_OPTIONS, false)?
     .visit_field::<CustomOptionsFormat>("custom_options_format", Self::VT_CUSTOM_OPTIONS_FORMAT, false)?
     .visit_field::<flatbuffers::ForwardsUOffset<flatbuffers::Vector<'_, bool>>>("mutating_variable_inputs", Self::VT_MUTATING_VARIABLE_INPUTS, false)?
     .visit_field::<flatbuffers::ForwardsUOffset<flatbuffers::Vector<'_, i32>>>("intermediates", Self::VT_INTERMEDIATES, false)?
     .finish();
    Ok(())
  }
}
pub struct OperatorArgs<'a> {
    pub opcode_index: u32,
    pub inputs: Option<flatbuffers::WIPOffset<flatbuffers::Vector<'a, i32>>>,
    pub outputs: Option<flatbuffers::WIPOffset<flatbuffers::Vector<'a, i32>>>,
    pub builtin_options_type: BuiltinOptions,
    pub builtin_options: Option<flatbuffers::WIPOffset<flatbuffers::UnionWIPOffset>>,
    pub custom_options: Option<flatbuffers::WIPOffset<flatbuffers::Vector<'a, u8>>>,
    pub custom_options_format: CustomOptionsFormat,
    pub mutating_variable_inputs: Option<flatbuffers::WIPOffset<flatbuffers::Vector<'a, bool>>>,
    pub intermediates: Option<flatbuffers::WIPOffset<flatbuffers::Vector<'a, i32>>>,
}
impl<'a> Default for OperatorArgs<'a> {
  #[inline]
  fn default() -> Self {
    OperatorArgs {
      opcode_index: 0,
      inputs: None,
      outputs: None,
      builtin_options_type: BuiltinOptions::NONE,
      builtin_options: None,
      custom_options: None,
      custom_options_format: CustomOptionsFormat::FLEXBUFFERS,
      mutating_variable_inputs: None,
      intermediates: None,
    }
  }
}

pub struct OperatorBuilder<'a: 'b, 'b> {
  fbb_: &'b mut flatbuffers::FlatBufferBuilder<'a>,
  start_: flatbuffers::WIPOffset<flatbuffers::TableUnfinishedWIPOffset>,
}
impl<'a: 'b, 'b> OperatorBuilder<'a, 'b> {
  #[inline]
  pub fn add_opcode_index(&mut self, opcode_index: u32) {
    self.fbb_.push_slot::<u32>(Operator::VT_OPCODE_INDEX, opcode_index, 0);
  }
  #[inline]
  pub fn add_inputs(&mut self, inputs: flatbuffers::WIPOffset<flatbuffers::Vector<'b , i32>>) {
    self.fbb_.push_slot_always::<flatbuffers::WIPOffset<_>>(Operator::VT_INPUTS, inputs);
  }
  #[inline]
  pub fn add_outputs(&mut self, outputs: flatbuffers::WIPOffset<flatbuffers::Vector<'b , i32>>) {
    self.fbb_.push_slot_always::<flatbuffers::WIPOffset<_>>(Operator::VT_OUTPUTS, outputs);
  }
  #[inline]
  pub fn add_builtin_options_type(&mut self, builtin_options_type: BuiltinOptions) {
    self.fbb_.push_slot::<BuiltinOptions>(Operator::VT_BUILTIN_OPTIONS_TYPE, builtin_options_type, BuiltinOptions::NONE);
  }
  #[inline]
  pub fn add_builtin_options(&mut self, builtin_options: flatbuffers::WIPOffset<flatbuffers::UnionWIPOffset>) {
    self.fbb_.push_slot_always::<flatbuffers::WIPOffset<_>>(Operator::VT_BUILTIN_OPTIONS, builtin_options);
  }
  #[inline]
  pub fn add_custom_options(&mut self, custom_options: flatbuffers::WIPOffset<flatbuffers::Vector<'b , u8>>) {
    self.fbb_.push_slot_always::<flatbuffers::WIPOffset<_>>(Operator::VT_CUSTOM_OPTIONS, custom_options);
  }
  #[inline]
  pub fn add_custom_options_format(&mut self, custom_options_format: CustomOptionsFormat) {
    self.fbb_.push_slot::<CustomOptionsFormat>(Operator::VT_CUSTOM_OPTIONS_FORMAT, custom_options_format, CustomOptionsFormat::FLEXBUFFERS);
  }
  #[inline]
  pub fn add_mutating_variable_inputs(&mut self, mutating_variable_inputs: flatbuffers::WIPOffset<flatbuffers::Vector<'b , bool>>) {
    self.fbb_.push_slot_always::<flatbuffers::WIPOffset<_>>(Operator::VT_MUTATING_VARIABLE_INPUTS, mutating_variable_inputs);
  }
  #[inline]
  pub fn add_intermediates(&mut self, intermediates: flatbuffers::WIPOffset<flatbuffers::Vector<'b , i32>>) {
    self.fbb_.push_slot_always::<flatbuffers::WIPOffset<_>>(Operator::VT_INTERMEDIATES, intermediates);
  }
  #[inline]
  pub fn new(_fbb: &'b mut flatbuffers::FlatBufferBuilder<'a>) -> OperatorBuilder<'a, 'b> {
    let start = _fbb.start_table();
    OperatorBuilder {
      fbb_: _fbb,
      start_: start,
    }
  }
  #[inline]
  pub fn finish(self) -> flatbuffers::WIPOffset<Operator<'a>> {
    let o = self.fbb_.end_table(self.start_);
    flatbuffers::WIPOffset::new(o.value())
  }
}

impl core::fmt::Debug for Operator<'_> {
  fn fmt(&self, f: &mut core::fmt::Formatter<'_>) -> core::fmt::Result {
    let mut ds = f.debug_struct("Operator");
      ds.field("opcode_index", &self.opcode_index());
      ds.field("inputs", &self.inputs());
      ds.field("outputs", &self.outputs());
      ds.field("builtin_options_type", &self.builtin_options_type());
      match self.builtin_options_type() {
        BuiltinOptions::Conv2DOptions => {
          if let Some(x) = self.builtin_options_as_conv_2_doptions() {
            ds.field("builtin_options", &x)
          } else {
            ds.field("builtin_options", &"InvalidFlatbuffer: Union discriminant does not match value.")
          }
        },
        BuiltinOptions::DepthwiseConv2DOptions => {
          if let Some(x) = self.builtin_options_as_depthwise_conv_2_doptions() {
            ds.field("builtin_options", &x)
          } else {
            ds.field("builtin_options", &"InvalidFlatbuffer: Union discriminant does not match value.")
          }
        },
        BuiltinOptions::ConcatEmbeddingsOptions => {
          if let Some(x) = self.builtin_options_as_concat_embeddings_options() {
            ds.field("builtin_options", &x)
          } else {
            ds.field("builtin_options", &"InvalidFlatbuffer: Union discriminant does not match value.")
          }
        },
        BuiltinOptions::LSHProjectionOptions => {
          if let Some(x) = self.builtin_options_as_lshprojection_options() {
            ds.field("builtin_options", &x)
          } else {
            ds.field("builtin_options", &"InvalidFlatbuffer: Union discriminant does not match value.")
          }
        },
        BuiltinOptions::Pool2DOptions => {
          if let Some(x) = self.builtin_options_as_pool_2_doptions() {
            ds.field("builtin_options", &x)
          } else {
            ds.field("builtin_options", &"InvalidFlatbuffer: Union discriminant does not match value.")
          }
        },
        BuiltinOptions::SVDFOptions => {
          if let Some(x) = self.builtin_options_as_svdfoptions() {
            ds.field("builtin_options", &x)
          } else {
            ds.field("builtin_options", &"InvalidFlatbuffer: Union discriminant does not match value.")
          }
        },
        BuiltinOptions::RNNOptions => {
          if let Some(x) = self.builtin_options_as_rnnoptions() {
            ds.field("builtin_options", &x)
          } else {
            ds.field("builtin_options", &"InvalidFlatbuffer: Union discriminant does not match value.")
          }
        },
        BuiltinOptions::FullyConnectedOptions => {
          if let Some(x) = self.builtin_options_as_fully_connected_options() {
            ds.field("builtin_options", &x)
          } else {
            ds.field("builtin_options", &"InvalidFlatbuffer: Union discriminant does not match value.")
          }
        },
        BuiltinOptions::SoftmaxOptions => {
          if let Some(x) = self.builtin_options_as_softmax_options() {
            ds.field("builtin_options", &x)
          } else {
            ds.field("builtin_options", &"InvalidFlatbuffer: Union discriminant does not match value.")
          }
        },
        BuiltinOptions::ConcatenationOptions => {
          if let Some(x) = self.builtin_options_as_concatenation_options() {
            ds.field("builtin_options", &x)
          } else {
            ds.field("builtin_options", &"InvalidFlatbuffer: Union discriminant does not match value.")
          }
        },
        BuiltinOptions::AddOptions => {
          if let Some(x) = self.builtin_options_as_add_options() {
            ds.field("builtin_options", &x)
          } else {
            ds.field("builtin_options", &"InvalidFlatbuffer: Union discriminant does not match value.")
          }
        },
        BuiltinOptions::L2NormOptions => {
          if let Some(x) = self.builtin_options_as_l2_norm_options() {
            ds.field("builtin_options", &x)
          } else {
            ds.field("builtin_options", &"InvalidFlatbuffer: Union discriminant does not match value.")
          }
        },
        BuiltinOptions::LocalResponseNormalizationOptions => {
          if let Some(x) = self.builtin_options_as_local_response_normalization_options() {
            ds.field("builtin_options", &x)
          } else {
            ds.field("builtin_options", &"InvalidFlatbuffer: Union discriminant does not match value.")
          }
        },
        BuiltinOptions::LSTMOptions => {
          if let Some(x) = self.builtin_options_as_lstmoptions() {
            ds.field("builtin_options", &x)
          } else {
            ds.field("builtin_options", &"InvalidFlatbuffer: Union discriminant does not match value.")
          }
        },
        BuiltinOptions::ResizeBilinearOptions => {
          if let Some(x) = self.builtin_options_as_resize_bilinear_options() {
            ds.field("builtin_options", &x)
          } else {
            ds.field("builtin_options", &"InvalidFlatbuffer: Union discriminant does not match value.")
          }
        },
        BuiltinOptions::CallOptions => {
          if let Some(x) = self.builtin_options_as_call_options() {
            ds.field("builtin_options", &x)
          } else {
            ds.field("builtin_options", &"InvalidFlatbuffer: Union discriminant does not match value.")
          }
        },
        BuiltinOptions::ReshapeOptions => {
          if let Some(x) = self.builtin_options_as_reshape_options() {
            ds.field("builtin_options", &x)
          } else {
            ds.field("builtin_options", &"InvalidFlatbuffer: Union discriminant does not match value.")
          }
        },
        BuiltinOptions::SkipGramOptions => {
          if let Some(x) = self.builtin_options_as_skip_gram_options() {
            ds.field("builtin_options", &x)
          } else {
            ds.field("builtin_options", &"InvalidFlatbuffer: Union discriminant does not match value.")
          }
        },
        BuiltinOptions::SpaceToDepthOptions => {
          if let Some(x) = self.builtin_options_as_space_to_depth_options() {
            ds.field("builtin_options", &x)
          } else {
            ds.field("builtin_options", &"InvalidFlatbuffer: Union discriminant does not match value.")
          }
        },
        BuiltinOptions::EmbeddingLookupSparseOptions => {
          if let Some(x) = self.builtin_options_as_embedding_lookup_sparse_options() {
            ds.field("builtin_options", &x)
          } else {
            ds.field("builtin_options", &"InvalidFlatbuffer: Union discriminant does not match value.")
          }
        },
        BuiltinOptions::MulOptions => {
          if let Some(x) = self.builtin_options_as_mul_options() {
            ds.field("builtin_options", &x)
          } else {
            ds.field("builtin_options", &"InvalidFlatbuffer: Union discriminant does not match value.")
          }
        },
        BuiltinOptions::PadOptions => {
          if let Some(x) = self.builtin_options_as_pad_options() {
            ds.field("builtin_options", &x)
          } else {
            ds.field("builtin_options", &"InvalidFlatbuffer: Union discriminant does not match value.")
          }
        },
        BuiltinOptions::GatherOptions => {
          if let Some(x) = self.builtin_options_as_gather_options() {
            ds.field("builtin_options", &x)
          } else {
            ds.field("builtin_options", &"InvalidFlatbuffer: Union discriminant does not match value.")
          }
        },
        BuiltinOptions::BatchToSpaceNDOptions => {
          if let Some(x) = self.builtin_options_as_batch_to_space_ndoptions() {
            ds.field("builtin_options", &x)
          } else {
            ds.field("builtin_options", &"InvalidFlatbuffer: Union discriminant does not match value.")
          }
        },
        BuiltinOptions::SpaceToBatchNDOptions => {
          if let Some(x) = self.builtin_options_as_space_to_batch_ndoptions() {
            ds.field("builtin_options", &x)
          } else {
            ds.field("builtin_options", &"InvalidFlatbuffer: Union discriminant does not match value.")
          }
        },
        BuiltinOptions::TransposeOptions => {
          if let Some(x) = self.builtin_options_as_transpose_options() {
            ds.field("builtin_options", &x)
          } else {
            ds.field("builtin_options", &"InvalidFlatbuffer: Union discriminant does not match value.")
          }
        },
        BuiltinOptions::ReducerOptions => {
          if let Some(x) = self.builtin_options_as_reducer_options() {
            ds.field("builtin_options", &x)
          } else {
            ds.field("builtin_options", &"InvalidFlatbuffer: Union discriminant does not match value.")
          }
        },
        BuiltinOptions::SubOptions => {
          if let Some(x) = self.builtin_options_as_sub_options() {
            ds.field("builtin_options", &x)
          } else {
            ds.field("builtin_options", &"InvalidFlatbuffer: Union discriminant does not match value.")
          }
        },
        BuiltinOptions::DivOptions => {
          if let Some(x) = self.builtin_options_as_div_options() {
            ds.field("builtin_options", &x)
          } else {
            ds.field("builtin_options", &"InvalidFlatbuffer: Union discriminant does not match value.")
          }
        },
        BuiltinOptions::SqueezeOptions => {
          if let Some(x) = self.builtin_options_as_squeeze_options() {
            ds.field("builtin_options", &x)
          } else {
            ds.field("builtin_options", &"InvalidFlatbuffer: Union discriminant does not match value.")
          }
        },
        BuiltinOptions::SequenceRNNOptions => {
          if let Some(x) = self.builtin_options_as_sequence_rnnoptions() {
            ds.field("builtin_options", &x)
          } else {
            ds.field("builtin_options", &"InvalidFlatbuffer: Union discriminant does not match value.")
          }
        },
        BuiltinOptions::StridedSliceOptions => {
          if let Some(x) = self.builtin_options_as_strided_slice_options() {
            ds.field("builtin_options", &x)
          } else {
            ds.field("builtin_options", &"InvalidFlatbuffer: Union discriminant does not match value.")
          }
        },
        BuiltinOptions::ExpOptions => {
          if let Some(x) = self.builtin_options_as_exp_options() {
            ds.field("builtin_options", &x)
          } else {
            ds.field("builtin_options", &"InvalidFlatbuffer: Union discriminant does not match value.")
          }
        },
        BuiltinOptions::TopKV2Options => {
          if let Some(x) = self.builtin_options_as_top_kv2_options() {
            ds.field("builtin_options", &x)
          } else {
            ds.field("builtin_options", &"InvalidFlatbuffer: Union discriminant does not match value.")
          }
        },
        BuiltinOptions::SplitOptions => {
          if let Some(x) = self.builtin_options_as_split_options() {
            ds.field("builtin_options", &x)
          } else {
            ds.field("builtin_options", &"InvalidFlatbuffer: Union discriminant does not match value.")
          }
        },
        BuiltinOptions::LogSoftmaxOptions => {
          if let Some(x) = self.builtin_options_as_log_softmax_options() {
            ds.field("builtin_options", &x)
          } else {
            ds.field("builtin_options", &"InvalidFlatbuffer: Union discriminant does not match value.")
          }
        },
        BuiltinOptions::CastOptions => {
          if let Some(x) = self.builtin_options_as_cast_options() {
            ds.field("builtin_options", &x)
          } else {
            ds.field("builtin_options", &"InvalidFlatbuffer: Union discriminant does not match value.")
          }
        },
        BuiltinOptions::DequantizeOptions => {
          if let Some(x) = self.builtin_options_as_dequantize_options() {
            ds.field("builtin_options", &x)
          } else {
            ds.field("builtin_options", &"InvalidFlatbuffer: Union discriminant does not match value.")
          }
        },
        BuiltinOptions::MaximumMinimumOptions => {
          if let Some(x) = self.builtin_options_as_maximum_minimum_options() {
            ds.field("builtin_options", &x)
          } else {
            ds.field("builtin_options", &"InvalidFlatbuffer: Union discriminant does not match value.")
          }
        },
        BuiltinOptions::ArgMaxOptions => {
          if let Some(x) = self.builtin_options_as_arg_max_options() {
            ds.field("builtin_options", &x)
          } else {
            ds.field("builtin_options", &"InvalidFlatbuffer: Union discriminant does not match value.")
          }
        },
        BuiltinOptions::LessOptions => {
          if let Some(x) = self.builtin_options_as_less_options() {
            ds.field("builtin_options", &x)
          } else {
            ds.field("builtin_options", &"InvalidFlatbuffer: Union discriminant does not match value.")
          }
        },
        BuiltinOptions::NegOptions => {
          if let Some(x) = self.builtin_options_as_neg_options() {
            ds.field("builtin_options", &x)
          } else {
            ds.field("builtin_options", &"InvalidFlatbuffer: Union discriminant does not match value.")
          }
        },
        BuiltinOptions::PadV2Options => {
          if let Some(x) = self.builtin_options_as_pad_v2_options() {
            ds.field("builtin_options", &x)
          } else {
            ds.field("builtin_options", &"InvalidFlatbuffer: Union discriminant does not match value.")
          }
        },
        BuiltinOptions::GreaterOptions => {
          if let Some(x) = self.builtin_options_as_greater_options() {
            ds.field("builtin_options", &x)
          } else {
            ds.field("builtin_options", &"InvalidFlatbuffer: Union discriminant does not match value.")
          }
        },
        BuiltinOptions::GreaterEqualOptions => {
          if let Some(x) = self.builtin_options_as_greater_equal_options() {
            ds.field("builtin_options", &x)
          } else {
            ds.field("builtin_options", &"InvalidFlatbuffer: Union discriminant does not match value.")
          }
        },
        BuiltinOptions::LessEqualOptions => {
          if let Some(x) = self.builtin_options_as_less_equal_options() {
            ds.field("builtin_options", &x)
          } else {
            ds.field("builtin_options", &"InvalidFlatbuffer: Union discriminant does not match value.")
          }
        },
        BuiltinOptions::SelectOptions => {
          if let Some(x) = self.builtin_options_as_select_options() {
            ds.field("builtin_options", &x)
          } else {
            ds.field("builtin_options", &"InvalidFlatbuffer: Union discriminant does not match value.")
          }
        },
        BuiltinOptions::SliceOptions => {
          if let Some(x) = self.builtin_options_as_slice_options() {
            ds.field("builtin_options", &x)
          } else {
            ds.field("builtin_options", &"InvalidFlatbuffer: Union discriminant does not match value.")
          }
        },
        BuiltinOptions::TransposeConvOptions => {
          if let Some(x) = self.builtin_options_as_transpose_conv_options() {
            ds.field("builtin_options", &x)
          } else {
            ds.field("builtin_options", &"InvalidFlatbuffer: Union discriminant does not match value.")
          }
        },
        BuiltinOptions::SparseToDenseOptions => {
          if let Some(x) = self.builtin_options_as_sparse_to_dense_options() {
            ds.field("builtin_options", &x)
          } else {
            ds.field("builtin_options", &"InvalidFlatbuffer: Union discriminant does not match value.")
          }
        },
        BuiltinOptions::TileOptions => {
          if let Some(x) = self.builtin_options_as_tile_options() {
            ds.field("builtin_options", &x)
          } else {
            ds.field("builtin_options", &"InvalidFlatbuffer: Union discriminant does not match value.")
          }
        },
        BuiltinOptions::ExpandDimsOptions => {
          if let Some(x) = self.builtin_options_as_expand_dims_options() {
            ds.field("builtin_options", &x)
          } else {
            ds.field("builtin_options", &"InvalidFlatbuffer: Union discriminant does not match value.")
          }
        },
        BuiltinOptions::EqualOptions => {
          if let Some(x) = self.builtin_options_as_equal_options() {
            ds.field("builtin_options", &x)
          } else {
            ds.field("builtin_options", &"InvalidFlatbuffer: Union discriminant does not match value.")
          }
        },
        BuiltinOptions::NotEqualOptions => {
          if let Some(x) = self.builtin_options_as_not_equal_options() {
            ds.field("builtin_options", &x)
          } else {
            ds.field("builtin_options", &"InvalidFlatbuffer: Union discriminant does not match value.")
          }
        },
        BuiltinOptions::ShapeOptions => {
          if let Some(x) = self.builtin_options_as_shape_options() {
            ds.field("builtin_options", &x)
          } else {
            ds.field("builtin_options", &"InvalidFlatbuffer: Union discriminant does not match value.")
          }
        },
        BuiltinOptions::PowOptions => {
          if let Some(x) = self.builtin_options_as_pow_options() {
            ds.field("builtin_options", &x)
          } else {
            ds.field("builtin_options", &"InvalidFlatbuffer: Union discriminant does not match value.")
          }
        },
        BuiltinOptions::ArgMinOptions => {
          if let Some(x) = self.builtin_options_as_arg_min_options() {
            ds.field("builtin_options", &x)
          } else {
            ds.field("builtin_options", &"InvalidFlatbuffer: Union discriminant does not match value.")
          }
        },
        BuiltinOptions::FakeQuantOptions => {
          if let Some(x) = self.builtin_options_as_fake_quant_options() {
            ds.field("builtin_options", &x)
          } else {
            ds.field("builtin_options", &"InvalidFlatbuffer: Union discriminant does not match value.")
          }
        },
        BuiltinOptions::PackOptions => {
          if let Some(x) = self.builtin_options_as_pack_options() {
            ds.field("builtin_options", &x)
          } else {
            ds.field("builtin_options", &"InvalidFlatbuffer: Union discriminant does not match value.")
          }
        },
        BuiltinOptions::LogicalOrOptions => {
          if let Some(x) = self.builtin_options_as_logical_or_options() {
            ds.field("builtin_options", &x)
          } else {
            ds.field("builtin_options", &"InvalidFlatbuffer: Union discriminant does not match value.")
          }
        },
        BuiltinOptions::OneHotOptions => {
          if let Some(x) = self.builtin_options_as_one_hot_options() {
            ds.field("builtin_options", &x)
          } else {
            ds.field("builtin_options", &"InvalidFlatbuffer: Union discriminant does not match value.")
          }
        },
        BuiltinOptions::LogicalAndOptions => {
          if let Some(x) = self.builtin_options_as_logical_and_options() {
            ds.field("builtin_options", &x)
          } else {
            ds.field("builtin_options", &"InvalidFlatbuffer: Union discriminant does not match value.")
          }
        },
        BuiltinOptions::LogicalNotOptions => {
          if let Some(x) = self.builtin_options_as_logical_not_options() {
            ds.field("builtin_options", &x)
          } else {
            ds.field("builtin_options", &"InvalidFlatbuffer: Union discriminant does not match value.")
          }
        },
        BuiltinOptions::UnpackOptions => {
          if let Some(x) = self.builtin_options_as_unpack_options() {
            ds.field("builtin_options", &x)
          } else {
            ds.field("builtin_options", &"InvalidFlatbuffer: Union discriminant does not match value.")
          }
        },
        BuiltinOptions::FloorDivOptions => {
          if let Some(x) = self.builtin_options_as_floor_div_options() {
            ds.field("builtin_options", &x)
          } else {
            ds.field("builtin_options", &"InvalidFlatbuffer: Union discriminant does not match value.")
          }
        },
        BuiltinOptions::SquareOptions => {
          if let Some(x) = self.builtin_options_as_square_options() {
            ds.field("builtin_options", &x)
          } else {
            ds.field("builtin_options", &"InvalidFlatbuffer: Union discriminant does not match value.")
          }
        },
        BuiltinOptions::ZerosLikeOptions => {
          if let Some(x) = self.builtin_options_as_zeros_like_options() {
            ds.field("builtin_options", &x)
          } else {
            ds.field("builtin_options", &"InvalidFlatbuffer: Union discriminant does not match value.")
          }
        },
        BuiltinOptions::FillOptions => {
          if let Some(x) = self.builtin_options_as_fill_options() {
            ds.field("builtin_options", &x)
          } else {
            ds.field("builtin_options", &"InvalidFlatbuffer: Union discriminant does not match value.")
          }
        },
        BuiltinOptions::BidirectionalSequenceLSTMOptions => {
          if let Some(x) = self.builtin_options_as_bidirectional_sequence_lstmoptions() {
            ds.field("builtin_options", &x)
          } else {
            ds.field("builtin_options", &"InvalidFlatbuffer: Union discriminant does not match value.")
          }
        },
        BuiltinOptions::BidirectionalSequenceRNNOptions => {
          if let Some(x) = self.builtin_options_as_bidirectional_sequence_rnnoptions() {
            ds.field("builtin_options", &x)
          } else {
            ds.field("builtin_options", &"InvalidFlatbuffer: Union discriminant does not match value.")
          }
        },
        BuiltinOptions::UnidirectionalSequenceLSTMOptions => {
          if let Some(x) = self.builtin_options_as_unidirectional_sequence_lstmoptions() {
            ds.field("builtin_options", &x)
          } else {
            ds.field("builtin_options", &"InvalidFlatbuffer: Union discriminant does not match value.")
          }
        },
        BuiltinOptions::FloorModOptions => {
          if let Some(x) = self.builtin_options_as_floor_mod_options() {
            ds.field("builtin_options", &x)
          } else {
            ds.field("builtin_options", &"InvalidFlatbuffer: Union discriminant does not match value.")
          }
        },
        BuiltinOptions::RangeOptions => {
          if let Some(x) = self.builtin_options_as_range_options() {
            ds.field("builtin_options", &x)
          } else {
            ds.field("builtin_options", &"InvalidFlatbuffer: Union discriminant does not match value.")
          }
        },
        BuiltinOptions::ResizeNearestNeighborOptions => {
          if let Some(x) = self.builtin_options_as_resize_nearest_neighbor_options() {
            ds.field("builtin_options", &x)
          } else {
            ds.field("builtin_options", &"InvalidFlatbuffer: Union discriminant does not match value.")
          }
        },
        BuiltinOptions::LeakyReluOptions => {
          if let Some(x) = self.builtin_options_as_leaky_relu_options() {
            ds.field("builtin_options", &x)
          } else {
            ds.field("builtin_options", &"InvalidFlatbuffer: Union discriminant does not match value.")
          }
        },
        BuiltinOptions::SquaredDifferenceOptions => {
          if let Some(x) = self.builtin_options_as_squared_difference_options() {
            ds.field("builtin_options", &x)
          } else {
            ds.field("builtin_options", &"InvalidFlatbuffer: Union discriminant does not match value.")
          }
        },
        BuiltinOptions::MirrorPadOptions => {
          if let Some(x) = self.builtin_options_as_mirror_pad_options() {
            ds.field("builtin_options", &x)
          } else {
            ds.field("builtin_options", &"InvalidFlatbuffer: Union discriminant does not match value.")
          }
        },
        BuiltinOptions::AbsOptions => {
          if let Some(x) = self.builtin_options_as_abs_options() {
            ds.field("builtin_options", &x)
          } else {
            ds.field("builtin_options", &"InvalidFlatbuffer: Union discriminant does not match value.")
          }
        },
        BuiltinOptions::SplitVOptions => {
          if let Some(x) = self.builtin_options_as_split_voptions() {
            ds.field("builtin_options", &x)
          } else {
            ds.field("builtin_options", &"InvalidFlatbuffer: Union discriminant does not match value.")
          }
        },
        BuiltinOptions::UniqueOptions => {
          if let Some(x) = self.builtin_options_as_unique_options() {
            ds.field("builtin_options", &x)
          } else {
            ds.field("builtin_options", &"InvalidFlatbuffer: Union discriminant does not match value.")
          }
        },
        BuiltinOptions::ReverseV2Options => {
          if let Some(x) = self.builtin_options_as_reverse_v2_options() {
            ds.field("builtin_options", &x)
          } else {
            ds.field("builtin_options", &"InvalidFlatbuffer: Union discriminant does not match value.")
          }
        },
        BuiltinOptions::AddNOptions => {
          if let Some(x) = self.builtin_options_as_add_noptions() {
            ds.field("builtin_options", &x)
          } else {
            ds.field("builtin_options", &"InvalidFlatbuffer: Union discriminant does not match value.")
          }
        },
        BuiltinOptions::GatherNdOptions => {
          if let Some(x) = self.builtin_options_as_gather_nd_options() {
            ds.field("builtin_options", &x)
          } else {
            ds.field("builtin_options", &"InvalidFlatbuffer: Union discriminant does not match value.")
          }
        },
        BuiltinOptions::CosOptions => {
          if let Some(x) = self.builtin_options_as_cos_options() {
            ds.field("builtin_options", &x)
          } else {
            ds.field("builtin_options", &"InvalidFlatbuffer: Union discriminant does not match value.")
          }
        },
        BuiltinOptions::WhereOptions => {
          if let Some(x) = self.builtin_options_as_where_options() {
            ds.field("builtin_options", &x)
          } else {
            ds.field("builtin_options", &"InvalidFlatbuffer: Union discriminant does not match value.")
          }
        },
        BuiltinOptions::RankOptions => {
          if let Some(x) = self.builtin_options_as_rank_options() {
            ds.field("builtin_options", &x)
          } else {
            ds.field("builtin_options", &"InvalidFlatbuffer: Union discriminant does not match value.")
          }
        },
        BuiltinOptions::ReverseSequenceOptions => {
          if let Some(x) = self.builtin_options_as_reverse_sequence_options() {
            ds.field("builtin_options", &x)
          } else {
            ds.field("builtin_options", &"InvalidFlatbuffer: Union discriminant does not match value.")
          }
        },
        BuiltinOptions::MatrixDiagOptions => {
          if let Some(x) = self.builtin_options_as_matrix_diag_options() {
            ds.field("builtin_options", &x)
          } else {
            ds.field("builtin_options", &"InvalidFlatbuffer: Union discriminant does not match value.")
          }
        },
        BuiltinOptions::QuantizeOptions => {
          if let Some(x) = self.builtin_options_as_quantize_options() {
            ds.field("builtin_options", &x)
          } else {
            ds.field("builtin_options", &"InvalidFlatbuffer: Union discriminant does not match value.")
          }
        },
        BuiltinOptions::MatrixSetDiagOptions => {
          if let Some(x) = self.builtin_options_as_matrix_set_diag_options() {
            ds.field("builtin_options", &x)
          } else {
            ds.field("builtin_options", &"InvalidFlatbuffer: Union discriminant does not match value.")
          }
        },
        BuiltinOptions::HardSwishOptions => {
          if let Some(x) = self.builtin_options_as_hard_swish_options() {
            ds.field("builtin_options", &x)
          } else {
            ds.field("builtin_options", &"InvalidFlatbuffer: Union discriminant does not match value.")
          }
        },
        BuiltinOptions::IfOptions => {
          if let Some(x) = self.builtin_options_as_if_options() {
            ds.field("builtin_options", &x)
          } else {
            ds.field("builtin_options", &"InvalidFlatbuffer: Union discriminant does not match value.")
          }
        },
        BuiltinOptions::WhileOptions => {
          if let Some(x) = self.builtin_options_as_while_options() {
            ds.field("builtin_options", &x)
          } else {
            ds.field("builtin_options", &"InvalidFlatbuffer: Union discriminant does not match value.")
          }
        },
        BuiltinOptions::DepthToSpaceOptions => {
          if let Some(x) = self.builtin_options_as_depth_to_space_options() {
            ds.field("builtin_options", &x)
          } else {
            ds.field("builtin_options", &"InvalidFlatbuffer: Union discriminant does not match value.")
          }
        },
        BuiltinOptions::NonMaxSuppressionV4Options => {
          if let Some(x) = self.builtin_options_as_non_max_suppression_v4_options() {
            ds.field("builtin_options", &x)
          } else {
            ds.field("builtin_options", &"InvalidFlatbuffer: Union discriminant does not match value.")
          }
        },
        BuiltinOptions::NonMaxSuppressionV5Options => {
          if let Some(x) = self.builtin_options_as_non_max_suppression_v5_options() {
            ds.field("builtin_options", &x)
          } else {
            ds.field("builtin_options", &"InvalidFlatbuffer: Union discriminant does not match value.")
          }
        },
        BuiltinOptions::ScatterNdOptions => {
          if let Some(x) = self.builtin_options_as_scatter_nd_options() {
            ds.field("builtin_options", &x)
          } else {
            ds.field("builtin_options", &"InvalidFlatbuffer: Union discriminant does not match value.")
          }
        },
        _ => {
          let x: Option<()> = None;
          ds.field("builtin_options", &x)
        },
      };
      ds.field("custom_options", &self.custom_options());
      ds.field("custom_options_format", &self.custom_options_format());
      ds.field("mutating_variable_inputs", &self.mutating_variable_inputs());
      ds.field("intermediates", &self.intermediates());
      ds.finish()
  }
}
#[non_exhaustive]
#[derive(Debug, Clone, PartialEq)]
pub struct OperatorT {
  pub opcode_index: u32,
  pub inputs: Option<Vec<i32>>,
  pub outputs: Option<Vec<i32>>,
  pub builtin_options: BuiltinOptionsT,
  pub custom_options: Option<Vec<u8>>,
  pub custom_options_format: CustomOptionsFormat,
  pub mutating_variable_inputs: Option<Vec<bool>>,
  pub intermediates: Option<Vec<i32>>,
}
impl Default for OperatorT {
  fn default() -> Self {
    Self {
      opcode_index: 0,
      inputs: None,
      outputs: None,
      builtin_options: BuiltinOptionsT::NONE,
      custom_options: None,
      custom_options_format: CustomOptionsFormat::FLEXBUFFERS,
      mutating_variable_inputs: None,
      intermediates: None,
    }
  }
}
impl OperatorT {
  pub fn pack<'b>(
    &self,
    _fbb: &mut flatbuffers::FlatBufferBuilder<'b>
  ) -> flatbuffers::WIPOffset<Operator<'b>> {
    let opcode_index = self.opcode_index;
    let inputs = self.inputs.as_ref().map(|x|{
      _fbb.create_vector(x)
    });
    let outputs = self.outputs.as_ref().map(|x|{
      _fbb.create_vector(x)
    });
    let builtin_options_type = self.builtin_options.builtin_options_type();
    let builtin_options = self.builtin_options.pack(_fbb);
    let custom_options = self.custom_options.as_ref().map(|x|{
      _fbb.create_vector(x)
    });
    let custom_options_format = self.custom_options_format;
    let mutating_variable_inputs = self.mutating_variable_inputs.as_ref().map(|x|{
      _fbb.create_vector(x)
    });
    let intermediates = self.intermediates.as_ref().map(|x|{
      _fbb.create_vector(x)
    });
    Operator::create(_fbb, &OperatorArgs{
      opcode_index,
      inputs,
      outputs,
      builtin_options_type,
      builtin_options,
      custom_options,
      custom_options_format,
      mutating_variable_inputs,
      intermediates,
    })
  }
}
pub enum SubGraphOffset {}
#[derive(Copy, Clone, PartialEq)]

pub struct SubGraph<'a> {
  pub _tab: flatbuffers::Table<'a>,
}

impl<'a> flatbuffers::Follow<'a> for SubGraph<'a> {
  type Inner = SubGraph<'a>;
  #[inline]
  fn follow(buf: &'a [u8], loc: usize) -> Self::Inner {
    Self { _tab: flatbuffers::Table { buf, loc } }
  }
}

impl<'a> SubGraph<'a> {
  pub const VT_TENSORS: flatbuffers::VOffsetT = 4;
  pub const VT_INPUTS: flatbuffers::VOffsetT = 6;
  pub const VT_OUTPUTS: flatbuffers::VOffsetT = 8;
  pub const VT_OPERATORS: flatbuffers::VOffsetT = 10;
  pub const VT_NAME: flatbuffers::VOffsetT = 12;

  #[inline]
  pub fn init_from_table(table: flatbuffers::Table<'a>) -> Self {
    SubGraph { _tab: table }
  }
  #[allow(unused_mut)]
  pub fn create<'bldr: 'args, 'args: 'mut_bldr, 'mut_bldr>(
    _fbb: &'mut_bldr mut flatbuffers::FlatBufferBuilder<'bldr>,
    args: &'args SubGraphArgs<'args>
  ) -> flatbuffers::WIPOffset<SubGraph<'bldr>> {
    let mut builder = SubGraphBuilder::new(_fbb);
    if let Some(x) = args.name { builder.add_name(x); }
    if let Some(x) = args.operators { builder.add_operators(x); }
    if let Some(x) = args.outputs { builder.add_outputs(x); }
    if let Some(x) = args.inputs { builder.add_inputs(x); }
    if let Some(x) = args.tensors { builder.add_tensors(x); }
    builder.finish()
  }

  pub fn unpack(&self) -> SubGraphT {
    let tensors = self.tensors().map(|x| {
      x.iter().map(|t| t.unpack()).collect()
    });
    let inputs = self.inputs().map(|x| {
      x.into_iter().collect()
    });
    let outputs = self.outputs().map(|x| {
      x.into_iter().collect()
    });
    let operators = self.operators().map(|x| {
      x.iter().map(|t| t.unpack()).collect()
    });
    let name = self.name().map(|x| {
      x.to_string()
    });
    SubGraphT {
      tensors,
      inputs,
      outputs,
      operators,
      name,
    }
  }

  #[inline]
  pub fn tensors(&self) -> Option<flatbuffers::Vector<'a, flatbuffers::ForwardsUOffset<Tensor<'a>>>> {
    self._tab.get::<flatbuffers::ForwardsUOffset<flatbuffers::Vector<'a, flatbuffers::ForwardsUOffset<Tensor>>>>(SubGraph::VT_TENSORS, None)
  }
  #[inline]
  pub fn inputs(&self) -> Option<flatbuffers::Vector<'a, i32>> {
    self._tab.get::<flatbuffers::ForwardsUOffset<flatbuffers::Vector<'a, i32>>>(SubGraph::VT_INPUTS, None)
  }
  #[inline]
  pub fn outputs(&self) -> Option<flatbuffers::Vector<'a, i32>> {
    self._tab.get::<flatbuffers::ForwardsUOffset<flatbuffers::Vector<'a, i32>>>(SubGraph::VT_OUTPUTS, None)
  }
  #[inline]
  pub fn operators(&self) -> Option<flatbuffers::Vector<'a, flatbuffers::ForwardsUOffset<Operator<'a>>>> {
    self._tab.get::<flatbuffers::ForwardsUOffset<flatbuffers::Vector<'a, flatbuffers::ForwardsUOffset<Operator>>>>(SubGraph::VT_OPERATORS, None)
  }
  #[inline]
  pub fn name(&self) -> Option<&'a str> {
    self._tab.get::<flatbuffers::ForwardsUOffset<&str>>(SubGraph::VT_NAME, None)
  }
}

impl flatbuffers::Verifiable for SubGraph<'_> {
  #[inline]
  fn run_verifier(
    v: &mut flatbuffers::Verifier, pos: usize
  ) -> Result<(), flatbuffers::InvalidFlatbuffer> {
    use self::flatbuffers::Verifiable;
    v.visit_table(pos)?
     .visit_field::<flatbuffers::ForwardsUOffset<flatbuffers::Vector<'_, flatbuffers::ForwardsUOffset<Tensor>>>>("tensors", Self::VT_TENSORS, false)?
     .visit_field::<flatbuffers::ForwardsUOffset<flatbuffers::Vector<'_, i32>>>("inputs", Self::VT_INPUTS, false)?
     .visit_field::<flatbuffers::ForwardsUOffset<flatbuffers::Vector<'_, i32>>>("outputs", Self::VT_OUTPUTS, false)?
     .visit_field::<flatbuffers::ForwardsUOffset<flatbuffers::Vector<'_, flatbuffers::ForwardsUOffset<Operator>>>>("operators", Self::VT_OPERATORS, false)?
     .visit_field::<flatbuffers::ForwardsUOffset<&str>>("name", Self::VT_NAME, false)?
     .finish();
    Ok(())
  }
}
pub struct SubGraphArgs<'a> {
    pub tensors: Option<flatbuffers::WIPOffset<flatbuffers::Vector<'a, flatbuffers::ForwardsUOffset<Tensor<'a>>>>>,
    pub inputs: Option<flatbuffers::WIPOffset<flatbuffers::Vector<'a, i32>>>,
    pub outputs: Option<flatbuffers::WIPOffset<flatbuffers::Vector<'a, i32>>>,
    pub operators: Option<flatbuffers::WIPOffset<flatbuffers::Vector<'a, flatbuffers::ForwardsUOffset<Operator<'a>>>>>,
    pub name: Option<flatbuffers::WIPOffset<&'a str>>,
}
impl<'a> Default for SubGraphArgs<'a> {
  #[inline]
  fn default() -> Self {
    SubGraphArgs {
      tensors: None,
      inputs: None,
      outputs: None,
      operators: None,
      name: None,
    }
  }
}

pub struct SubGraphBuilder<'a: 'b, 'b> {
  fbb_: &'b mut flatbuffers::FlatBufferBuilder<'a>,
  start_: flatbuffers::WIPOffset<flatbuffers::TableUnfinishedWIPOffset>,
}
impl<'a: 'b, 'b> SubGraphBuilder<'a, 'b> {
  #[inline]
  pub fn add_tensors(&mut self, tensors: flatbuffers::WIPOffset<flatbuffers::Vector<'b , flatbuffers::ForwardsUOffset<Tensor<'b >>>>) {
    self.fbb_.push_slot_always::<flatbuffers::WIPOffset<_>>(SubGraph::VT_TENSORS, tensors);
  }
  #[inline]
  pub fn add_inputs(&mut self, inputs: flatbuffers::WIPOffset<flatbuffers::Vector<'b , i32>>) {
    self.fbb_.push_slot_always::<flatbuffers::WIPOffset<_>>(SubGraph::VT_INPUTS, inputs);
  }
  #[inline]
  pub fn add_outputs(&mut self, outputs: flatbuffers::WIPOffset<flatbuffers::Vector<'b , i32>>) {
    self.fbb_.push_slot_always::<flatbuffers::WIPOffset<_>>(SubGraph::VT_OUTPUTS, outputs);
  }
  #[inline]
  pub fn add_operators(&mut self, operators: flatbuffers::WIPOffset<flatbuffers::Vector<'b , flatbuffers::ForwardsUOffset<Operator<'b >>>>) {
    self.fbb_.push_slot_always::<flatbuffers::WIPOffset<_>>(SubGraph::VT_OPERATORS, operators);
  }
  #[inline]
  pub fn add_name(&mut self, name: flatbuffers::WIPOffset<&'b  str>) {
    self.fbb_.push_slot_always::<flatbuffers::WIPOffset<_>>(SubGraph::VT_NAME, name);
  }
  #[inline]
  pub fn new(_fbb: &'b mut flatbuffers::FlatBufferBuilder<'a>) -> SubGraphBuilder<'a, 'b> {
    let start = _fbb.start_table();
    SubGraphBuilder {
      fbb_: _fbb,
      start_: start,
    }
  }
  #[inline]
  pub fn finish(self) -> flatbuffers::WIPOffset<SubGraph<'a>> {
    let o = self.fbb_.end_table(self.start_);
    flatbuffers::WIPOffset::new(o.value())
  }
}

impl core::fmt::Debug for SubGraph<'_> {
  fn fmt(&self, f: &mut core::fmt::Formatter<'_>) -> core::fmt::Result {
    let mut ds = f.debug_struct("SubGraph");
      ds.field("tensors", &self.tensors());
      ds.field("inputs", &self.inputs());
      ds.field("outputs", &self.outputs());
      ds.field("operators", &self.operators());
      ds.field("name", &self.name());
      ds.finish()
  }
}
#[non_exhaustive]
#[derive(Debug, Clone, PartialEq)]
pub struct SubGraphT {
  pub tensors: Option<Vec<TensorT>>,
  pub inputs: Option<Vec<i32>>,
  pub outputs: Option<Vec<i32>>,
  pub operators: Option<Vec<OperatorT>>,
  pub name: Option<String>,
}
impl Default for SubGraphT {
  fn default() -> Self {
    Self {
      tensors: None,
      inputs: None,
      outputs: None,
      operators: None,
      name: None,
    }
  }
}
impl SubGraphT {
  pub fn pack<'b>(
    &self,
    _fbb: &mut flatbuffers::FlatBufferBuilder<'b>
  ) -> flatbuffers::WIPOffset<SubGraph<'b>> {
    let tensors = self.tensors.as_ref().map(|x|{
      let w: Vec<_> = x.iter().map(|t| t.pack(_fbb)).collect();_fbb.create_vector(&w)
    });
    let inputs = self.inputs.as_ref().map(|x|{
      _fbb.create_vector(x)
    });
    let outputs = self.outputs.as_ref().map(|x|{
      _fbb.create_vector(x)
    });
    let operators = self.operators.as_ref().map(|x|{
      let w: Vec<_> = x.iter().map(|t| t.pack(_fbb)).collect();_fbb.create_vector(&w)
    });
    let name = self.name.as_ref().map(|x|{
      _fbb.create_string(x)
    });
    SubGraph::create(_fbb, &SubGraphArgs{
      tensors,
      inputs,
      outputs,
      operators,
      name,
    })
  }
}
pub enum BufferOffset {}
#[derive(Copy, Clone, PartialEq)]

pub struct Buffer<'a> {
  pub _tab: flatbuffers::Table<'a>,
}

impl<'a> flatbuffers::Follow<'a> for Buffer<'a> {
  type Inner = Buffer<'a>;
  #[inline]
  fn follow(buf: &'a [u8], loc: usize) -> Self::Inner {
    Self { _tab: flatbuffers::Table { buf, loc } }
  }
}

impl<'a> Buffer<'a> {
  pub const VT_DATA: flatbuffers::VOffsetT = 4;

  #[inline]
  pub fn init_from_table(table: flatbuffers::Table<'a>) -> Self {
    Buffer { _tab: table }
  }
  #[allow(unused_mut)]
  pub fn create<'bldr: 'args, 'args: 'mut_bldr, 'mut_bldr>(
    _fbb: &'mut_bldr mut flatbuffers::FlatBufferBuilder<'bldr>,
    args: &'args BufferArgs<'args>
  ) -> flatbuffers::WIPOffset<Buffer<'bldr>> {
    let mut builder = BufferBuilder::new(_fbb);
    if let Some(x) = args.data { builder.add_data(x); }
    builder.finish()
  }

  pub fn unpack(&self) -> BufferT {
    let data = self.data().map(|x| {
      x.to_vec()
    });
    BufferT {
      data,
    }
  }

  #[inline]
  pub fn data(&self) -> Option<&'a [u8]> {
    self._tab.get::<flatbuffers::ForwardsUOffset<flatbuffers::Vector<'a, u8>>>(Buffer::VT_DATA, None).map(|v| v.safe_slice())
  }
}

impl flatbuffers::Verifiable for Buffer<'_> {
  #[inline]
  fn run_verifier(
    v: &mut flatbuffers::Verifier, pos: usize
  ) -> Result<(), flatbuffers::InvalidFlatbuffer> {
    use self::flatbuffers::Verifiable;
    v.visit_table(pos)?
     .visit_field::<flatbuffers::ForwardsUOffset<flatbuffers::Vector<'_, u8>>>("data", Self::VT_DATA, false)?
     .finish();
    Ok(())
  }
}
pub struct BufferArgs<'a> {
    pub data: Option<flatbuffers::WIPOffset<flatbuffers::Vector<'a, u8>>>,
}
impl<'a> Default for BufferArgs<'a> {
  #[inline]
  fn default() -> Self {
    BufferArgs {
      data: None,
    }
  }
}

pub struct BufferBuilder<'a: 'b, 'b> {
  fbb_: &'b mut flatbuffers::FlatBufferBuilder<'a>,
  start_: flatbuffers::WIPOffset<flatbuffers::TableUnfinishedWIPOffset>,
}
impl<'a: 'b, 'b> BufferBuilder<'a, 'b> {
  #[inline]
  pub fn add_data(&mut self, data: flatbuffers::WIPOffset<flatbuffers::Vector<'b , u8>>) {
    self.fbb_.push_slot_always::<flatbuffers::WIPOffset<_>>(Buffer::VT_DATA, data);
  }
  #[inline]
  pub fn new(_fbb: &'b mut flatbuffers::FlatBufferBuilder<'a>) -> BufferBuilder<'a, 'b> {
    let start = _fbb.start_table();
    BufferBuilder {
      fbb_: _fbb,
      start_: start,
    }
  }
  #[inline]
  pub fn finish(self) -> flatbuffers::WIPOffset<Buffer<'a>> {
    let o = self.fbb_.end_table(self.start_);
    flatbuffers::WIPOffset::new(o.value())
  }
}

impl core::fmt::Debug for Buffer<'_> {
  fn fmt(&self, f: &mut core::fmt::Formatter<'_>) -> core::fmt::Result {
    let mut ds = f.debug_struct("Buffer");
      ds.field("data", &self.data());
      ds.finish()
  }
}
#[non_exhaustive]
#[derive(Debug, Clone, PartialEq)]
pub struct BufferT {
  pub data: Option<Vec<u8>>,
}
impl Default for BufferT {
  fn default() -> Self {
    Self {
      data: None,
    }
  }
}
impl BufferT {
  pub fn pack<'b>(
    &self,
    _fbb: &mut flatbuffers::FlatBufferBuilder<'b>
  ) -> flatbuffers::WIPOffset<Buffer<'b>> {
    let data = self.data.as_ref().map(|x|{
      _fbb.create_vector(x)
    });
    Buffer::create(_fbb, &BufferArgs{
      data,
    })
  }
}
pub enum MetadataOffset {}
#[derive(Copy, Clone, PartialEq)]

pub struct Metadata<'a> {
  pub _tab: flatbuffers::Table<'a>,
}

impl<'a> flatbuffers::Follow<'a> for Metadata<'a> {
  type Inner = Metadata<'a>;
  #[inline]
  fn follow(buf: &'a [u8], loc: usize) -> Self::Inner {
    Self { _tab: flatbuffers::Table { buf, loc } }
  }
}

impl<'a> Metadata<'a> {
  pub const VT_NAME: flatbuffers::VOffsetT = 4;
  pub const VT_BUFFER: flatbuffers::VOffsetT = 6;

  #[inline]
  pub fn init_from_table(table: flatbuffers::Table<'a>) -> Self {
    Metadata { _tab: table }
  }
  #[allow(unused_mut)]
  pub fn create<'bldr: 'args, 'args: 'mut_bldr, 'mut_bldr>(
    _fbb: &'mut_bldr mut flatbuffers::FlatBufferBuilder<'bldr>,
    args: &'args MetadataArgs<'args>
  ) -> flatbuffers::WIPOffset<Metadata<'bldr>> {
    let mut builder = MetadataBuilder::new(_fbb);
    builder.add_buffer(args.buffer);
    if let Some(x) = args.name { builder.add_name(x); }
    builder.finish()
  }

  pub fn unpack(&self) -> MetadataT {
    let name = self.name().map(|x| {
      x.to_string()
    });
    let buffer = self.buffer();
    MetadataT {
      name,
      buffer,
    }
  }

  #[inline]
  pub fn name(&self) -> Option<&'a str> {
    self._tab.get::<flatbuffers::ForwardsUOffset<&str>>(Metadata::VT_NAME, None)
  }
  #[inline]
  pub fn buffer(&self) -> u32 {
    self._tab.get::<u32>(Metadata::VT_BUFFER, Some(0)).unwrap()
  }
}

impl flatbuffers::Verifiable for Metadata<'_> {
  #[inline]
  fn run_verifier(
    v: &mut flatbuffers::Verifier, pos: usize
  ) -> Result<(), flatbuffers::InvalidFlatbuffer> {
    use self::flatbuffers::Verifiable;
    v.visit_table(pos)?
     .visit_field::<flatbuffers::ForwardsUOffset<&str>>("name", Self::VT_NAME, false)?
     .visit_field::<u32>("buffer", Self::VT_BUFFER, false)?
     .finish();
    Ok(())
  }
}
pub struct MetadataArgs<'a> {
    pub name: Option<flatbuffers::WIPOffset<&'a str>>,
    pub buffer: u32,
}
impl<'a> Default for MetadataArgs<'a> {
  #[inline]
  fn default() -> Self {
    MetadataArgs {
      name: None,
      buffer: 0,
    }
  }
}

pub struct MetadataBuilder<'a: 'b, 'b> {
  fbb_: &'b mut flatbuffers::FlatBufferBuilder<'a>,
  start_: flatbuffers::WIPOffset<flatbuffers::TableUnfinishedWIPOffset>,
}
impl<'a: 'b, 'b> MetadataBuilder<'a, 'b> {
  #[inline]
  pub fn add_name(&mut self, name: flatbuffers::WIPOffset<&'b  str>) {
    self.fbb_.push_slot_always::<flatbuffers::WIPOffset<_>>(Metadata::VT_NAME, name);
  }
  #[inline]
  pub fn add_buffer(&mut self, buffer: u32) {
    self.fbb_.push_slot::<u32>(Metadata::VT_BUFFER, buffer, 0);
  }
  #[inline]
  pub fn new(_fbb: &'b mut flatbuffers::FlatBufferBuilder<'a>) -> MetadataBuilder<'a, 'b> {
    let start = _fbb.start_table();
    MetadataBuilder {
      fbb_: _fbb,
      start_: start,
    }
  }
  #[inline]
  pub fn finish(self) -> flatbuffers::WIPOffset<Metadata<'a>> {
    let o = self.fbb_.end_table(self.start_);
    flatbuffers::WIPOffset::new(o.value())
  }
}

impl core::fmt::Debug for Metadata<'_> {
  fn fmt(&self, f: &mut core::fmt::Formatter<'_>) -> core::fmt::Result {
    let mut ds = f.debug_struct("Metadata");
      ds.field("name", &self.name());
      ds.field("buffer", &self.buffer());
      ds.finish()
  }
}
#[non_exhaustive]
#[derive(Debug, Clone, PartialEq)]
pub struct MetadataT {
  pub name: Option<String>,
  pub buffer: u32,
}
impl Default for MetadataT {
  fn default() -> Self {
    Self {
      name: None,
      buffer: 0,
    }
  }
}
impl MetadataT {
  pub fn pack<'b>(
    &self,
    _fbb: &mut flatbuffers::FlatBufferBuilder<'b>
  ) -> flatbuffers::WIPOffset<Metadata<'b>> {
    let name = self.name.as_ref().map(|x|{
      _fbb.create_string(x)
    });
    let buffer = self.buffer;
    Metadata::create(_fbb, &MetadataArgs{
      name,
      buffer,
    })
  }
}
pub enum ModelOffset {}
#[derive(Copy, Clone, PartialEq)]

pub struct Model<'a> {
  pub _tab: flatbuffers::Table<'a>,
}

impl<'a> flatbuffers::Follow<'a> for Model<'a> {
  type Inner = Model<'a>;
  #[inline]
  fn follow(buf: &'a [u8], loc: usize) -> Self::Inner {
    Self { _tab: flatbuffers::Table { buf, loc } }
  }
}

impl<'a> Model<'a> {
  pub const VT_VERSION: flatbuffers::VOffsetT = 4;
  pub const VT_OPERATOR_CODES: flatbuffers::VOffsetT = 6;
  pub const VT_SUBGRAPHS: flatbuffers::VOffsetT = 8;
  pub const VT_DESCRIPTION: flatbuffers::VOffsetT = 10;
  pub const VT_BUFFERS: flatbuffers::VOffsetT = 12;
  pub const VT_METADATA_BUFFER: flatbuffers::VOffsetT = 14;
  pub const VT_METADATA: flatbuffers::VOffsetT = 16;

  #[inline]
  pub fn init_from_table(table: flatbuffers::Table<'a>) -> Self {
    Model { _tab: table }
  }
  #[allow(unused_mut)]
  pub fn create<'bldr: 'args, 'args: 'mut_bldr, 'mut_bldr>(
    _fbb: &'mut_bldr mut flatbuffers::FlatBufferBuilder<'bldr>,
    args: &'args ModelArgs<'args>
  ) -> flatbuffers::WIPOffset<Model<'bldr>> {
    let mut builder = ModelBuilder::new(_fbb);
    if let Some(x) = args.metadata { builder.add_metadata(x); }
    if let Some(x) = args.metadata_buffer { builder.add_metadata_buffer(x); }
    if let Some(x) = args.buffers { builder.add_buffers(x); }
    if let Some(x) = args.description { builder.add_description(x); }
    if let Some(x) = args.subgraphs { builder.add_subgraphs(x); }
    if let Some(x) = args.operator_codes { builder.add_operator_codes(x); }
    builder.add_version(args.version);
    builder.finish()
  }

  pub fn unpack(&self) -> ModelT {
    let version = self.version();
    let operator_codes = self.operator_codes().map(|x| {
      x.iter().map(|t| t.unpack()).collect()
    });
    let subgraphs = self.subgraphs().map(|x| {
      x.iter().map(|t| t.unpack()).collect()
    });
    let description = self.description().map(|x| {
      x.to_string()
    });
    let buffers = self.buffers().map(|x| {
      x.iter().map(|t| t.unpack()).collect()
    });
    let metadata_buffer = self.metadata_buffer().map(|x| {
      x.into_iter().collect()
    });
    let metadata = self.metadata().map(|x| {
      x.iter().map(|t| t.unpack()).collect()
    });
    ModelT {
      version,
      operator_codes,
      subgraphs,
      description,
      buffers,
      metadata_buffer,
      metadata,
    }
  }

  #[inline]
  pub fn version(&self) -> u32 {
    self._tab.get::<u32>(Model::VT_VERSION, Some(0)).unwrap()
  }
  #[inline]
  pub fn operator_codes(&self) -> Option<flatbuffers::Vector<'a, flatbuffers::ForwardsUOffset<OperatorCode<'a>>>> {
    self._tab.get::<flatbuffers::ForwardsUOffset<flatbuffers::Vector<'a, flatbuffers::ForwardsUOffset<OperatorCode>>>>(Model::VT_OPERATOR_CODES, None)
  }
  #[inline]
  pub fn subgraphs(&self) -> Option<flatbuffers::Vector<'a, flatbuffers::ForwardsUOffset<SubGraph<'a>>>> {
    self._tab.get::<flatbuffers::ForwardsUOffset<flatbuffers::Vector<'a, flatbuffers::ForwardsUOffset<SubGraph>>>>(Model::VT_SUBGRAPHS, None)
  }
  #[inline]
  pub fn description(&self) -> Option<&'a str> {
    self._tab.get::<flatbuffers::ForwardsUOffset<&str>>(Model::VT_DESCRIPTION, None)
  }
  #[inline]
  pub fn buffers(&self) -> Option<flatbuffers::Vector<'a, flatbuffers::ForwardsUOffset<Buffer<'a>>>> {
    self._tab.get::<flatbuffers::ForwardsUOffset<flatbuffers::Vector<'a, flatbuffers::ForwardsUOffset<Buffer>>>>(Model::VT_BUFFERS, None)
  }
  #[inline]
  pub fn metadata_buffer(&self) -> Option<flatbuffers::Vector<'a, i32>> {
    self._tab.get::<flatbuffers::ForwardsUOffset<flatbuffers::Vector<'a, i32>>>(Model::VT_METADATA_BUFFER, None)
  }
  #[inline]
  pub fn metadata(&self) -> Option<flatbuffers::Vector<'a, flatbuffers::ForwardsUOffset<Metadata<'a>>>> {
    self._tab.get::<flatbuffers::ForwardsUOffset<flatbuffers::Vector<'a, flatbuffers::ForwardsUOffset<Metadata>>>>(Model::VT_METADATA, None)
  }
}

impl flatbuffers::Verifiable for Model<'_> {
  #[inline]
  fn run_verifier(
    v: &mut flatbuffers::Verifier, pos: usize
  ) -> Result<(), flatbuffers::InvalidFlatbuffer> {
    use self::flatbuffers::Verifiable;
    v.visit_table(pos)?
     .visit_field::<u32>("version", Self::VT_VERSION, false)?
     .visit_field::<flatbuffers::ForwardsUOffset<flatbuffers::Vector<'_, flatbuffers::ForwardsUOffset<OperatorCode>>>>("operator_codes", Self::VT_OPERATOR_CODES, false)?
     .visit_field::<flatbuffers::ForwardsUOffset<flatbuffers::Vector<'_, flatbuffers::ForwardsUOffset<SubGraph>>>>("subgraphs", Self::VT_SUBGRAPHS, false)?
     .visit_field::<flatbuffers::ForwardsUOffset<&str>>("description", Self::VT_DESCRIPTION, false)?
     .visit_field::<flatbuffers::ForwardsUOffset<flatbuffers::Vector<'_, flatbuffers::ForwardsUOffset<Buffer>>>>("buffers", Self::VT_BUFFERS, false)?
     .visit_field::<flatbuffers::ForwardsUOffset<flatbuffers::Vector<'_, i32>>>("metadata_buffer", Self::VT_METADATA_BUFFER, false)?
     .visit_field::<flatbuffers::ForwardsUOffset<flatbuffers::Vector<'_, flatbuffers::ForwardsUOffset<Metadata>>>>("metadata", Self::VT_METADATA, false)?
     .finish();
    Ok(())
  }
}
pub struct ModelArgs<'a> {
    pub version: u32,
    pub operator_codes: Option<flatbuffers::WIPOffset<flatbuffers::Vector<'a, flatbuffers::ForwardsUOffset<OperatorCode<'a>>>>>,
    pub subgraphs: Option<flatbuffers::WIPOffset<flatbuffers::Vector<'a, flatbuffers::ForwardsUOffset<SubGraph<'a>>>>>,
    pub description: Option<flatbuffers::WIPOffset<&'a str>>,
    pub buffers: Option<flatbuffers::WIPOffset<flatbuffers::Vector<'a, flatbuffers::ForwardsUOffset<Buffer<'a>>>>>,
    pub metadata_buffer: Option<flatbuffers::WIPOffset<flatbuffers::Vector<'a, i32>>>,
    pub metadata: Option<flatbuffers::WIPOffset<flatbuffers::Vector<'a, flatbuffers::ForwardsUOffset<Metadata<'a>>>>>,
}
impl<'a> Default for ModelArgs<'a> {
  #[inline]
  fn default() -> Self {
    ModelArgs {
      version: 0,
      operator_codes: None,
      subgraphs: None,
      description: None,
      buffers: None,
      metadata_buffer: None,
      metadata: None,
    }
  }
}

pub struct ModelBuilder<'a: 'b, 'b> {
  fbb_: &'b mut flatbuffers::FlatBufferBuilder<'a>,
  start_: flatbuffers::WIPOffset<flatbuffers::TableUnfinishedWIPOffset>,
}
impl<'a: 'b, 'b> ModelBuilder<'a, 'b> {
  #[inline]
  pub fn add_version(&mut self, version: u32) {
    self.fbb_.push_slot::<u32>(Model::VT_VERSION, version, 0);
  }
  #[inline]
  pub fn add_operator_codes(&mut self, operator_codes: flatbuffers::WIPOffset<flatbuffers::Vector<'b , flatbuffers::ForwardsUOffset<OperatorCode<'b >>>>) {
    self.fbb_.push_slot_always::<flatbuffers::WIPOffset<_>>(Model::VT_OPERATOR_CODES, operator_codes);
  }
  #[inline]
  pub fn add_subgraphs(&mut self, subgraphs: flatbuffers::WIPOffset<flatbuffers::Vector<'b , flatbuffers::ForwardsUOffset<SubGraph<'b >>>>) {
    self.fbb_.push_slot_always::<flatbuffers::WIPOffset<_>>(Model::VT_SUBGRAPHS, subgraphs);
  }
  #[inline]
  pub fn add_description(&mut self, description: flatbuffers::WIPOffset<&'b  str>) {
    self.fbb_.push_slot_always::<flatbuffers::WIPOffset<_>>(Model::VT_DESCRIPTION, description);
  }
  #[inline]
  pub fn add_buffers(&mut self, buffers: flatbuffers::WIPOffset<flatbuffers::Vector<'b , flatbuffers::ForwardsUOffset<Buffer<'b >>>>) {
    self.fbb_.push_slot_always::<flatbuffers::WIPOffset<_>>(Model::VT_BUFFERS, buffers);
  }
  #[inline]
  pub fn add_metadata_buffer(&mut self, metadata_buffer: flatbuffers::WIPOffset<flatbuffers::Vector<'b , i32>>) {
    self.fbb_.push_slot_always::<flatbuffers::WIPOffset<_>>(Model::VT_METADATA_BUFFER, metadata_buffer);
  }
  #[inline]
  pub fn add_metadata(&mut self, metadata: flatbuffers::WIPOffset<flatbuffers::Vector<'b , flatbuffers::ForwardsUOffset<Metadata<'b >>>>) {
    self.fbb_.push_slot_always::<flatbuffers::WIPOffset<_>>(Model::VT_METADATA, metadata);
  }
  #[inline]
  pub fn new(_fbb: &'b mut flatbuffers::FlatBufferBuilder<'a>) -> ModelBuilder<'a, 'b> {
    let start = _fbb.start_table();
    ModelBuilder {
      fbb_: _fbb,
      start_: start,
    }
  }
  #[inline]
  pub fn finish(self) -> flatbuffers::WIPOffset<Model<'a>> {
    let o = self.fbb_.end_table(self.start_);
    flatbuffers::WIPOffset::new(o.value())
  }
}

impl core::fmt::Debug for Model<'_> {
  fn fmt(&self, f: &mut core::fmt::Formatter<'_>) -> core::fmt::Result {
    let mut ds = f.debug_struct("Model");
      ds.field("version", &self.version());
      ds.field("operator_codes", &self.operator_codes());
      ds.field("subgraphs", &self.subgraphs());
      ds.field("description", &self.description());
      ds.field("buffers", &self.buffers());
      ds.field("metadata_buffer", &self.metadata_buffer());
      ds.field("metadata", &self.metadata());
      ds.finish()
  }
}
#[non_exhaustive]
#[derive(Debug, Clone, PartialEq)]
pub struct ModelT {
  pub version: u32,
  pub operator_codes: Option<Vec<OperatorCodeT>>,
  pub subgraphs: Option<Vec<SubGraphT>>,
  pub description: Option<String>,
  pub buffers: Option<Vec<BufferT>>,
  pub metadata_buffer: Option<Vec<i32>>,
  pub metadata: Option<Vec<MetadataT>>,
}
impl Default for ModelT {
  fn default() -> Self {
    Self {
      version: 0,
      operator_codes: None,
      subgraphs: None,
      description: None,
      buffers: None,
      metadata_buffer: None,
      metadata: None,
    }
  }
}
impl ModelT {
  pub fn pack<'b>(
    &self,
    _fbb: &mut flatbuffers::FlatBufferBuilder<'b>
  ) -> flatbuffers::WIPOffset<Model<'b>> {
    let version = self.version;
    let operator_codes = self.operator_codes.as_ref().map(|x|{
      let w: Vec<_> = x.iter().map(|t| t.pack(_fbb)).collect();_fbb.create_vector(&w)
    });
    let subgraphs = self.subgraphs.as_ref().map(|x|{
      let w: Vec<_> = x.iter().map(|t| t.pack(_fbb)).collect();_fbb.create_vector(&w)
    });
    let description = self.description.as_ref().map(|x|{
      _fbb.create_string(x)
    });
    let buffers = self.buffers.as_ref().map(|x|{
      let w: Vec<_> = x.iter().map(|t| t.pack(_fbb)).collect();_fbb.create_vector(&w)
    });
    let metadata_buffer = self.metadata_buffer.as_ref().map(|x|{
      _fbb.create_vector(x)
    });
    let metadata = self.metadata.as_ref().map(|x|{
      let w: Vec<_> = x.iter().map(|t| t.pack(_fbb)).collect();_fbb.create_vector(&w)
    });
    Model::create(_fbb, &ModelArgs{
      version,
      operator_codes,
      subgraphs,
      description,
      buffers,
      metadata_buffer,
      metadata,
    })
  }
}
#[inline]
#[deprecated(since="2.0.0", note="Deprecated in favor of `root_as...` methods.")]
pub fn get_root_as_model<'a>(buf: &'a [u8]) -> Model<'a> {
  unsafe { flatbuffers::root_unchecked::<Model<'a>>(buf) }
}

#[inline]
#[deprecated(since="2.0.0", note="Deprecated in favor of `root_as...` methods.")]
pub fn get_size_prefixed_root_as_model<'a>(buf: &'a [u8]) -> Model<'a> {
  unsafe { flatbuffers::size_prefixed_root_unchecked::<Model<'a>>(buf) }
}

#[inline]
/// Verifies that a buffer of bytes contains a `Model`
/// and returns it.
/// Note that verification is still experimental and may not
/// catch every error, or be maximally performant. For the
/// previous, unchecked, behavior use
/// `root_as_model_unchecked`.
pub fn root_as_model(buf: &[u8]) -> Result<Model, flatbuffers::InvalidFlatbuffer> {
  flatbuffers::root::<Model>(buf)
}
#[inline]
/// Verifies that a buffer of bytes contains a size prefixed
/// `Model` and returns it.
/// Note that verification is still experimental and may not
/// catch every error, or be maximally performant. For the
/// previous, unchecked, behavior use
/// `size_prefixed_root_as_model_unchecked`.
pub fn size_prefixed_root_as_model(buf: &[u8]) -> Result<Model, flatbuffers::InvalidFlatbuffer> {
  flatbuffers::size_prefixed_root::<Model>(buf)
}
#[inline]
/// Verifies, with the given options, that a buffer of bytes
/// contains a `Model` and returns it.
/// Note that verification is still experimental and may not
/// catch every error, or be maximally performant. For the
/// previous, unchecked, behavior use
/// `root_as_model_unchecked`.
pub fn root_as_model_with_opts<'b, 'o>(
  opts: &'o flatbuffers::VerifierOptions,
  buf: &'b [u8],
) -> Result<Model<'b>, flatbuffers::InvalidFlatbuffer> {
  flatbuffers::root_with_opts::<Model<'b>>(opts, buf)
}
#[inline]
/// Verifies, with the given verifier options, that a buffer of
/// bytes contains a size prefixed `Model` and returns
/// it. Note that verification is still experimental and may not
/// catch every error, or be maximally performant. For the
/// previous, unchecked, behavior use
/// `root_as_model_unchecked`.
pub fn size_prefixed_root_as_model_with_opts<'b, 'o>(
  opts: &'o flatbuffers::VerifierOptions,
  buf: &'b [u8],
) -> Result<Model<'b>, flatbuffers::InvalidFlatbuffer> {
  flatbuffers::size_prefixed_root_with_opts::<Model<'b>>(opts, buf)
}
#[inline]
/// Assumes, without verification, that a buffer of bytes contains a Model and returns it.
/// # Safety
/// Callers must trust the given bytes do indeed contain a valid `Model`.
pub unsafe fn root_as_model_unchecked(buf: &[u8]) -> Model {
  flatbuffers::root_unchecked::<Model>(buf)
}
#[inline]
/// Assumes, without verification, that a buffer of bytes contains a size prefixed Model and returns it.
/// # Safety
/// Callers must trust the given bytes do indeed contain a valid size prefixed `Model`.
pub unsafe fn size_prefixed_root_as_model_unchecked(buf: &[u8]) -> Model {
  flatbuffers::size_prefixed_root_unchecked::<Model>(buf)
}
pub const MODEL_IDENTIFIER: &str = "TFL3";

#[inline]
pub fn model_buffer_has_identifier(buf: &[u8]) -> bool {
  flatbuffers::buffer_has_identifier(buf, MODEL_IDENTIFIER, false)
}

#[inline]
pub fn model_size_prefixed_buffer_has_identifier(buf: &[u8]) -> bool {
  flatbuffers::buffer_has_identifier(buf, MODEL_IDENTIFIER, true)
}

pub const MODEL_EXTENSION: &str = "tflite";

#[inline]
pub fn finish_model_buffer<'a, 'b>(
    fbb: &'b mut flatbuffers::FlatBufferBuilder<'a>,
    root: flatbuffers::WIPOffset<Model<'a>>) {
  fbb.finish(root, Some(MODEL_IDENTIFIER));
}

#[inline]
pub fn finish_size_prefixed_model_buffer<'a, 'b>(fbb: &'b mut flatbuffers::FlatBufferBuilder<'a>, root: flatbuffers::WIPOffset<Model<'a>>) {
  fbb.finish_size_prefixed(root, Some(MODEL_IDENTIFIER));
}
}  // pub mod tflite

